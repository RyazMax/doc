# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../doc/book/box/data_model.rst:5
msgid "Data model"
msgstr ""

#: ../doc/book/box/data_model.rst:7
msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""

#: ../doc/book/box/data_model.rst:10
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""

#: ../doc/book/box/data_model.rst:20
msgid "Space"
msgstr ""

#: ../doc/book/box/data_model.rst:22
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr ""

#: ../doc/book/box/data_model.rst:24
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size, or *vinyl* -- on-disk engine for huge data "
"sets."
msgstr ""

#: ../doc/book/box/data_model.rst:31
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:39
msgid "Tuple"
msgstr ""

#: ../doc/book/box/data_model.rst:41
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""

#: ../doc/book/box/data_model.rst:45
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/book/box/data_model.rst:46
msgid "fields don't need to have names."
msgstr ""

#: ../doc/book/box/data_model.rst:48
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some"
" contexts to refer to the first field of a tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:55
msgid "The number of tuples in a space is unlimited."
msgstr ""

#: ../doc/book/box/data_model.rst:57
msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""

#: ../doc/book/box/data_model.rst:60
msgid ""
"When Tarantool returns a tuple value in the console, by default it uses "
":ref:`YAML <interactive_console>` format, for example: ``[3, 'Ace of "
"Base', 1993]``."
msgstr ""

#: ../doc/book/box/data_model.rst:68
msgid "Index"
msgstr ""

#: ../doc/book/box/data_model.rst:70
msgid "An **index** is a group of key values and pointers."
msgstr ""

#: ../doc/book/box/data_model.rst:72
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/book/box/data_model.rst:75
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:80
msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""

#: ../doc/book/box/data_model.rst:84
msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""

#: ../doc/book/box/data_model.rst:87
msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""

#: ../doc/book/box/data_model.rst:91
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""

#: ../doc/book/box/data_model.rst:95
msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""

#: ../doc/book/box/data_model.rst:98
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {{field "
"= 1, type = 'unsigned'}}}"
msgstr ""

#: ../doc/book/box/data_model.rst:102
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""

#: ../doc/book/box/data_model.rst:107
msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""

#: ../doc/book/box/data_model.rst:110
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {field"
" = 2, type = 'string'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:114
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', so values in field "
"#2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/book/box/data_model.rst:121
msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/book/box/data_model.rst:125
msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""

#: ../doc/book/box/data_model.rst:132
msgid "Data types"
msgstr ""

#: ../doc/book/box/data_model.rst:134
msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/book/box/data_model.rst:143
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/book/box/data_model.rst:153
msgid "Scalar / compound"
msgstr ""

#: ../doc/book/box/data_model.rst:153
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/book/box/data_model.rst:153
msgid "Lua type"
msgstr ""

#: ../doc/book/box/data_model.rst:153
msgid "Example value"
msgstr ""

#: ../doc/book/box/data_model.rst:155 ../doc/book/box/data_model.rst:157
#: ../doc/book/box/data_model.rst:159 ../doc/book/box/data_model.rst:161
#: ../doc/book/box/data_model.rst:163 ../doc/book/box/data_model.rst:165
msgid "scalar"
msgstr ""

#: ../doc/book/box/data_model.rst:155
msgid "nil"
msgstr ""

#: ../doc/book/box/data_model.rst:155
msgid "\"`nil`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:155 ../doc/book/box/data_model.rst:319
msgid "msgpack.NULL"
msgstr ""

#: ../doc/book/box/data_model.rst:157
msgid "boolean"
msgstr ""

#: ../doc/book/box/data_model.rst:157
msgid "\"`boolean`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:157 ../doc/book/box/data_model.rst:311
#: ../doc/book/box/data_model.rst:321
msgid "true"
msgstr ""

#: ../doc/book/box/data_model.rst:159
msgid "string"
msgstr ""

#: ../doc/book/box/data_model.rst:159
msgid "\"`string`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:159
msgid "'A B C'"
msgstr ""

#: ../doc/book/box/data_model.rst:161
msgid "integer"
msgstr ""

#: ../doc/book/box/data_model.rst:161 ../doc/book/box/data_model.rst:163
msgid "\"`number`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:161
msgid "12345"
msgstr ""

#: ../doc/book/box/data_model.rst:163
msgid "double"
msgstr ""

#: ../doc/book/box/data_model.rst:163
msgid "1.2345"
msgstr ""

#: ../doc/book/box/data_model.rst:165
msgid "bin"
msgstr ""

#: ../doc/book/box/data_model.rst:165
msgid "\"`cdata`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:165
msgid "[!!binary 3t7e]"
msgstr ""

#: ../doc/book/box/data_model.rst:167 ../doc/book/box/data_model.rst:169
#: ../doc/book/box/data_model.rst:171
msgid "compound"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "map"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "{'a': 5, 'b': 6}"
msgstr ""

#: ../doc/book/box/data_model.rst:169 ../doc/book/box/data_model.rst:171
msgid "array"
msgstr ""

#: ../doc/book/box/data_model.rst:169
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/book/box/data_model.rst:169
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/book/box/data_model.rst:171
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/book/box/data_model.rst:171
msgid "[12345, 'A B C']"
msgstr ""

#: ../doc/book/box/data_model.rst:181
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/book/box/data_model.rst:189
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""

#: ../doc/book/box/data_model.rst:193
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion --"
" unless there is an optional :ref:`collation <index-collation>`. So, "
"usually, string sorting and comparison are done byte-by-byte, without any"
" special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/book/box/data_model.rst:206
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 trillion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""

#: ../doc/book/box/data_model.rst:217
msgid ""
"A **bin** (binary) value is not directly supported by Lua but there is a "
"Tarantool type ``VARBINARY`` which is encoded as MessagePack binary. For "
"an (advanced) example showing how to insert VARBINARY into a database, "
"see the Cookbook Recipe for :ref:`ffi_varbinary_insert <cookbook-"
"ffi_varbinary_insert>`."
msgstr ""

#: ../doc/book/box/data_model.rst:222
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""

#: ../doc/book/box/data_model.rst:227
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/book/box/data_model.rst:234
msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""

#: ../doc/book/box/data_model.rst:238
msgid "Examples of insert requests with different data types:"
msgstr ""

#: ../doc/book/box/data_model.rst:240
msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:259
msgid "Indexed field types"
msgstr ""

#: ../doc/book/box/data_model.rst:261
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'unsigned' is a separate **indexed field type**, "
"compared to ‘integer’ data type in MsgPack: they both store ‘integer’ "
"values, but an 'unsigned' index contains only *non-negative* integer "
"values and an ‘integer’ index contains *all* integer values."
msgstr ""

#: ../doc/book/box/data_model.rst:267
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/book/box/data_model.rst:280
msgid "Indexed field type"
msgstr ""

#: ../doc/book/box/data_model.rst:280
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/book/box/data_model.rst:280 ../doc/book/box/data_model.rst:918
msgid "Index type"
msgstr ""

#: ../doc/book/box/data_model.rst:280 ../doc/book/box/data_model.rst:496
msgid "Examples"
msgstr ""

#: ../doc/book/box/data_model.rst:283
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/book/box/data_model.rst:283
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""

#: ../doc/book/box/data_model.rst:283 ../doc/book/box/data_model.rst:303
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/book/box/data_model.rst:283
msgid "123456"
msgstr ""

#: ../doc/book/box/data_model.rst:288
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/book/box/data_model.rst:288 ../doc/book/box/data_model.rst:293
#: ../doc/book/box/data_model.rst:324
msgid ""
"**integer** (integer between -9223372036854775808 and "
"18446744073709551615)"
msgstr ""

#: ../doc/book/box/data_model.rst:288 ../doc/book/box/data_model.rst:293
#: ../doc/book/box/data_model.rst:307 ../doc/book/box/data_model.rst:311
#: ../doc/book/box/data_model.rst:319
msgid "TREE or HASH"
msgstr ""

#: ../doc/book/box/data_model.rst:288
msgid "-2^63"
msgstr ""

#: ../doc/book/box/data_model.rst:293
msgid "**number**"
msgstr ""

#: ../doc/book/box/data_model.rst:298 ../doc/book/box/data_model.rst:329
msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""

#: ../doc/book/box/data_model.rst:293 ../doc/book/box/data_model.rst:325
msgid "1.234"
msgstr ""

#: ../doc/book/box/data_model.rst:295
msgid "-44"
msgstr ""

#: ../doc/book/box/data_model.rst:297
msgid "1.447e+44"
msgstr ""

#: ../doc/book/box/data_model.rst:303
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/book/box/data_model.rst:303
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/book/box/data_model.rst:303
msgid "‘A B C’"
msgstr ""

#: ../doc/book/box/data_model.rst:305 ../doc/book/box/data_model.rst:307
msgid "‘\\\\65 \\\\66 \\\\67’"
msgstr ""

#: ../doc/book/box/data_model.rst:307
msgid "**varbinary**"
msgstr ""

#: ../doc/book/box/data_model.rst:307
msgid "**bin** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/book/box/data_model.rst:311
msgid "**boolean**"
msgstr ""

#: ../doc/book/box/data_model.rst:311 ../doc/book/box/data_model.rst:321
msgid "**bool** (true or false)"
msgstr ""

#: ../doc/book/box/data_model.rst:314
msgid "**array**"
msgstr ""

#: ../doc/book/box/data_model.rst:314
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""

#: ../doc/book/box/data_model.rst:314
msgid "RTREE"
msgstr ""

#: ../doc/book/box/data_model.rst:314
msgid "{10, 11}"
msgstr ""

#: ../doc/book/box/data_model.rst:316
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/book/box/data_model.rst:319
msgid "**scalar**"
msgstr ""

#: ../doc/book/box/data_model.rst:319
msgid "**null**"
msgstr ""

#: ../doc/book/box/data_model.rst:334
msgid "**string** (any set of octets)"
msgstr ""

#: ../doc/book/box/data_model.rst:336
msgid "**varbinary** (any set of octets)"
msgstr ""

#: ../doc/book/box/data_model.rst:338
msgid ""
"Note: When there is a mix of types, the key order is: null, then "
"booleans, then numbers, then strings, then varbinary."
msgstr ""

#: ../doc/book/box/data_model.rst:323
msgid "-1"
msgstr ""

#: ../doc/book/box/data_model.rst:327
msgid "‘’"
msgstr ""

#: ../doc/book/box/data_model.rst:329
msgid "‘ру’"
msgstr ""

#: ../doc/book/box/data_model.rst:348
msgid "Collations"
msgstr ""

#: ../doc/book/box/data_model.rst:350
msgid ""
"By default, when Tarantool compares strings, it uses what we call a "
"**\"binary\" collation**. The only consideration here is the numeric "
"value of each byte in the string. Therefore, if the string is encoded "
"with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of "
"'A' (what used to be called the \"ASCII value\") is 65, the encoding of "
"'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you"
" prefer fast deterministic simple maintenance and searching with "
"Tarantool indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:359
msgid ""
"But if you want the ordering that you see in phone books and "
"dictionaries, then you need Tarantool's optional collations, such as "
"``unicode`` and ``unicode_ci``, which allow for ``'a' < 'A' < 'B'`` and "
"``'a' = 'A' < 'B'`` respectively."
msgstr ""

#: ../doc/book/box/data_model.rst:364
msgid ""
"**The unicode and unicode_ci optional collations** use the ordering "
"according to the `Default Unicode Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" and the rules described in `Unicode® Technical Standard #10 Unicode "
"Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. "
"The only difference between the two collations is about `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""

#: ../doc/book/box/data_model.rst:371
msgid ""
"``unicode`` collation observes L1 and L2 and L3 weights (strength = "
"'tertiary'),"
msgstr ""

#: ../doc/book/box/data_model.rst:372
msgid ""
"``unicode_ci`` collation observes only L1 weights (strength = 'primary'),"
" so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""

#: ../doc/book/box/data_model.rst:374
msgid "As an example, take some Russian words:"
msgstr ""

#: ../doc/book/box/data_model.rst:376
msgid ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""

#: ../doc/book/box/data_model.rst:388
msgid "...and show the difference in ordering and selecting by index:"
msgstr ""

#: ../doc/book/box/data_model.rst:390
msgid "with ``unicode`` collation:"
msgstr ""

#: ../doc/book/box/data_model.rst:392
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{field = 1, type = "
"'str', collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:413
msgid "with ``unicode_ci`` collation:"
msgstr ""

#: ../doc/book/box/data_model.rst:415
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{field = 1, type "
"='str', collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:436
msgid ""
"In all, collation involves much more than these simple examples of upper "
"case / lower case and accented / unaccented equivalence in alphabets. We "
"also consider variations of the same character, non-alphabetic writing "
"systems, and special rules that apply for combinations of characters."
msgstr ""

#: ../doc/book/box/data_model.rst:441
msgid ""
"For English: use \"unicode\" and \"unicode_ci\". For Russian: use "
"\"unicode\" and \"unicode_ci\" (although a few Russians might prefer the "
"Kyrgyz collation which says Cyrillic letters 'Е' and 'Ё' are the same "
"with level-1 weights). For Dutch, German (dictionary), French, "
"Indonesian, Irish, Italian, Lingala, Malay, Portuguese, Southern Soho, "
"Xhosa, or Zulu: \"unicode\" and \"unicode_ci\" will do."
msgstr ""

#: ../doc/book/box/data_model.rst:449
msgid ""
"**The tailored optional collations**: For other languages, Tarantool "
"supplies tailored collations for every modern language that has more than"
" a million native speakers, and for specialized situations such as the "
"difference between dictionary order and telephone book order. To see a "
"complete list say ``box.space._collation:select()``. The tailored "
"collation names have the form unicode_[language code]_[strength] where "
"language code is a standard 2-character or 3-character language "
"abbreviation, and strength is s1 for \"primary strength\" (level-1 "
"weights), s2 for \"secondary\", s3 for \"tertiary\". Tarantool uses the "
"same language codes as the ones in the \"list of tailorable locales\" on "
"man pages of `Ubuntu "
"<http://manpages.ubuntu.com/manpages/bionic/man3/Unicode::Collate::Locale.3perl.html>`_"
" and `Fedora "
"<http://www.polarhome.com/service/man/?qf=Unicode%3A%3ACollate%3A%3ALocale&af=0&tf=2&of=Fedora>`_."
" Charts explaining the precise differences from DUCET order are in the "
"`Common Language Data Repository "
"<https://unicode.org/cldr/charts/30/collation>`_."
msgstr ""

#: ../doc/book/box/data_model.rst:469
msgid "Sequences"
msgstr ""

#: ../doc/book/box/data_model.rst:471
msgid "A **sequence** is a generator of ordered integer values."
msgstr ""

#: ../doc/book/box/data_model.rst:473
msgid ""
"As with spaces and indexes, you should specify the sequence **name**, and"
" let Tarantool come up with a unique **numeric identifier** (\"sequence "
"id\")."
msgstr ""

#: ../doc/book/box/data_model.rst:476
msgid ""
"As well, you can specify several options when creating a new sequence. "
"The options determine what value will be generated whenever the sequence "
"is used."
msgstr ""

#: ../doc/book/box/data_model.rst:483
msgid "Options for ``box.schema.sequence.create()``"
msgstr ""

#: ../doc/book/box/data_model.rst:496
msgid "Option name"
msgstr ""

#: ../doc/book/box/data_model.rst:496
msgid "Type and meaning"
msgstr ""

#: ../doc/book/box/data_model.rst:496
msgid "Default"
msgstr ""

#: ../doc/book/box/data_model.rst:498
msgid "**start**"
msgstr ""

#: ../doc/book/box/data_model.rst:498
msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""

#: ../doc/book/box/data_model.rst:498 ../doc/book/box/data_model.rst:502
#: ../doc/book/box/data_model.rst:514
msgid "1"
msgstr ""

#: ../doc/book/box/data_model.rst:498
msgid "start=0"
msgstr ""

#: ../doc/book/box/data_model.rst:502
msgid "**min**"
msgstr ""

#: ../doc/book/box/data_model.rst:502
msgid "Integer. Values smaller than this cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:502
msgid "min=-1000"
msgstr ""

#: ../doc/book/box/data_model.rst:505
msgid "**max**"
msgstr ""

#: ../doc/book/box/data_model.rst:505
msgid "Integer. Values larger than this cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:505
msgid "9223372036854775807"
msgstr ""

#: ../doc/book/box/data_model.rst:505
msgid "max=0"
msgstr ""

#: ../doc/book/box/data_model.rst:508
msgid "**cycle**"
msgstr ""

#: ../doc/book/box/data_model.rst:508
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:508 ../doc/book/box/data_model.rst:518
msgid "false"
msgstr ""

#: ../doc/book/box/data_model.rst:508
msgid "cycle=true"
msgstr ""

#: ../doc/book/box/data_model.rst:511
msgid "**cache**"
msgstr ""

#: ../doc/book/box/data_model.rst:511
msgid "Integer. The number of values to store in a cache"
msgstr ""

#: ../doc/book/box/data_model.rst:511
msgid "0"
msgstr ""

#: ../doc/book/box/data_model.rst:511
msgid "cache=0"
msgstr ""

#: ../doc/book/box/data_model.rst:514
msgid "**step**"
msgstr ""

#: ../doc/book/box/data_model.rst:514
msgid ""
"Integer. What to add to the previous generated value, when generating a "
"new value"
msgstr ""

#: ../doc/book/box/data_model.rst:514
msgid "step=-1"
msgstr ""

#: ../doc/book/box/data_model.rst:518
msgid "**if_not_exists**"
msgstr ""

#: ../doc/book/box/data_model.rst:518
msgid ""
"Boolean. If this is true and a sequence with this name exists already, "
"ignore other options and use the existing values"
msgstr ""

#: ../doc/book/box/data_model.rst:518
msgid "if_not_exists=true"
msgstr ""

#: ../doc/book/box/data_model.rst:524
msgid ""
"Once a sequence exists, it can be altered, dropped, reset, forced to "
"generate the next value, or associated with an index."
msgstr ""

#: ../doc/book/box/data_model.rst:527
msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""

#: ../doc/book/box/data_model.rst:529
msgid ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:544
msgid ""
"The result shows that the new sequence has all default values, except for"
" the two that were specified, ``min`` and ``start``."
msgstr ""

#: ../doc/book/box/data_model.rst:547
msgid "Then we get the next value, with the ``next()`` function."
msgstr ""

#: ../doc/book/box/data_model.rst:549
msgid ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:556
msgid ""
"The result is the same as the start value. If we called ``next()`` again,"
" we would get 6 (because the previous value plus the step value is 6), "
"and so on."
msgstr ""

#: ../doc/book/box/data_model.rst:560
msgid ""
"Then we create a new table, and say that its primary key may be generated"
" from the sequence."
msgstr ""

#: ../doc/book/box/data_model.rst:563
msgid ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:569
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr ""

#: ../doc/book/box/data_model.rst:571
msgid ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:578
msgid ""
"The result is a new tuple where the first field has a value of 6. This "
"arrangement, where the system automatically generates the values for a "
"primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""

#: ../doc/book/box/data_model.rst:583
msgid ""
"For syntax and implementation details, see the reference for "
":ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""

#: ../doc/book/box/data_model.rst:590
msgid "Persistence"
msgstr ""

#: ../doc/book/box/data_model.rst:592
msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
":ref:`write ahead log (WAL) <internals-wal>` files. This ensures data "
"persistence. When a power outage occurs or the Tarantool instance is "
"killed incidentally, the in-memory database is lost. In this situation, "
"WAL files are used to restore the data. Namely, Tarantool reads the WAL "
"files and redoes the requests (this is called the \"recovery process\"). "
"You can change the timing of the WAL writer, or turn it off, by setting "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/book/box/data_model.rst:601
msgid ""
"Tarantool also maintains a set of :ref:`snapshot files <internals-"
"snapshot>`. These files contain an on-disk copy of the entire data set "
"for a given moment. Instead of reading every WAL file since the databases"
" were created, the recovery process can load the latest snapshot file and"
" then read only those WAL files that were produced after the snapshot "
"file was made. After checkpointing, old WAL files can be removed to free "
"up space."
msgstr ""

#: ../doc/book/box/data_model.rst:608
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of snapshot files, you can use Tarantool's :ref:`checkpoint "
"daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets "
"intervals for forced checkpoints. It makes sure that the states of both "
"memtx and vinyl storage engines are synchronized and saved to disk, and "
"automatically removes old WAL files."
msgstr ""

#: ../doc/book/box/data_model.rst:616
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/book/box/data_model.rst:620
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/book/box/data_model.rst:623
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/book/box/data_model.rst:625
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""

#: ../doc/book/box/data_model.rst:632
msgid "Operations"
msgstr ""

#: ../doc/book/box/data_model.rst:638
msgid "Data operations"
msgstr ""

#: ../doc/book/box/data_model.rst:640
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/book/box/data_model.rst:642
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE), and"
msgstr ""

#: ../doc/book/box/data_model.rst:643
msgid "one data-retrieval operation (SELECT)."
msgstr ""

#: ../doc/book/box/data_model.rst:645
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""

#: ../doc/book/box/data_model.rst:647
msgid "**Examples:**"
msgstr ""

#: ../doc/book/box/data_model.rst:649
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/book/box/data_model.rst:651
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/book/box/data_model.rst:653
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/book/box/data_model.rst:655
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr ""

#: ../doc/book/box/data_model.rst:659
msgid ""
":ref:`UPDATE <box_space-update>`: Update the tuple, changing field "
"field[2]."
msgstr ""

#: ../doc/book/box/data_model.rst:661
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""

#: ../doc/book/box/data_model.rst:665
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""

#: ../doc/book/box/data_model.rst:668
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:672
msgid ""
":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field "
"field[2] again."
msgstr ""

#: ../doc/book/box/data_model.rst:675
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed until after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""

#: ../doc/book/box/data_model.rst:681
msgid ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:685
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/book/box/data_model.rst:687
msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""

#: ../doc/book/box/data_model.rst:690
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/book/box/data_model.rst:694
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:696
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""

#: ../doc/book/box/data_model.rst:699
msgid "tarantool> box.space.tester:select{999}"
msgstr ""

#: ../doc/book/box/data_model.rst:703
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:705
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/book/box/data_model.rst:707
msgid "tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../doc/book/box/data_model.rst:711
msgid "Summarizing the examples:"
msgstr ""

#: ../doc/book/box/data_model.rst:713
msgid ""
"Functions ``insert`` and ``replace`` accept a tuple (where a primary key "
"comes as part of the tuple)."
msgstr ""

#: ../doc/book/box/data_model.rst:715
msgid ""
"Function ``upsert`` accepts a tuple (where a primary key comes as part of"
" the tuple), and also the update operations to execute."
msgstr ""

#: ../doc/book/box/data_model.rst:718
msgid ""
"Function ``delete`` accepts a full key of any unique index (primary or "
"secondary)."
msgstr ""

#: ../doc/book/box/data_model.rst:720
msgid ""
"Function ``update`` accepts a full key of any unique index (primary or "
"secondary), and also the operations to execute."
msgstr ""

#: ../doc/book/box/data_model.rst:723
msgid ""
"Function ``select`` accepts any key: primary/secondary, unique/non-"
"unique, full/partial."
msgstr ""

#: ../doc/book/box/data_model.rst:726
msgid ""
"See reference on ``box.space`` for more :ref:`details on using data "
"operations <box_space-operations-detailed-examples>`."
msgstr ""

#: ../doc/book/box/data_model.rst:731
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""

#: ../doc/book/box/data_model.rst:740
msgid "Index operations"
msgstr ""

#: ../doc/book/box/data_model.rst:742
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:745
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""

#: ../doc/book/box/data_model.rst:784
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ""

#: ../doc/book/box/data_model.rst:752
msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""

#: ../doc/book/box/data_model.rst:755
msgid "The simple SELECT request that we've illustrated before is:"
msgstr ""

#: ../doc/book/box/data_model.rst:794
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ""

#: ../doc/book/box/data_model.rst:762
msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one."
msgstr ""

#: ../doc/book/box/data_model.rst:765
msgid "The following SELECT variations exist:"
msgstr ""

#: ../doc/book/box/data_model.rst:767
msgid "The search can use comparisons other than equality."
msgstr ""

#: ../doc/book/box/data_model.rst:806
msgid ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"
msgstr ""

#: ../doc/book/box/data_model.rst:774
msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, "
"EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", "
"\"reversed equal\", \"greater than or equal\", \"greater than\" "
"respectively). Comparisons make sense if and only if the index type is "
"‘TREE'."
msgstr ""

#: ../doc/book/box/data_model.rst:779
msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""

#: ../doc/book/box/data_model.rst:783
msgid "The search can use a secondary index."
msgstr ""

#: ../doc/book/box/data_model.rst:822
msgid ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"
msgstr ""

#: ../doc/book/box/data_model.rst:790
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""

#: ../doc/book/box/data_model.rst:793
msgid "The search may be for some or all key parts."
msgstr ""

#: ../doc/book/box/data_model.rst:832
msgid ""
"-- Suppose an index has two parts\n"
":samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"---\n"
"- - type: unsigned\n"
"    fieldno: 1\n"
"  - type: string\n"
"    fieldno: 2\n"
"...\n"
"-- Suppose the space has three tuples\n"
":samp:`box.space.{space-name}:select()`\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [2, '']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:814
msgid "The search may be for all fields, using a table for the value:"
msgstr ""

#: ../doc/book/box/data_model.rst:853
msgid ":extsamp:`box.space.{*{space-name}*}:select({1, 'A'})`"
msgstr ""

#: ../doc/book/box/data_model.rst:821
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""

#: ../doc/book/box/data_model.rst:860
msgid ":samp:`box.space.{space-name}:select(1)`"
msgstr ""

#: ../doc/book/box/data_model.rst:828
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1,"
" 'B'}``."
msgstr ""

#: ../doc/book/box/data_model.rst:831
msgid ""
"You can specify even zero fields, causing all three tuples to be "
"returned. (Notice that partial key searches are available only in TREE "
"indexes.)"
msgstr ""

#: ../doc/book/box/data_model.rst:834
msgid "**Examples**"
msgstr ""

#: ../doc/book/box/data_model.rst:836
msgid "BITSET example:"
msgstr ""

#: ../doc/book/box/data_model.rst:838
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={field = 2, type = 'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""

#: ../doc/book/box/data_model.rst:849 ../doc/book/box/data_model.rst:871
msgid "The result will be:"
msgstr ""

#: ../doc/book/box/data_model.rst:851
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:858
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr ""

#: ../doc/book/box/data_model.rst:860
msgid "RTREE example:"
msgstr ""

#: ../doc/book/box/data_model.rst:862
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={field = 2, type = 'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""

#: ../doc/book/box/data_model.rst:873
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:879
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""

#: ../doc/book/box/data_model.rst:882
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:888
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and"
" :ref:`drop() <box_index-drop>` in reference for :ref:`box.index "
"<box_index>` submodule."
msgstr ""

#: ../doc/book/box/data_model.rst:893
msgid "Complexity factors"
msgstr ""

#: ../doc/book/box/data_model.rst:895
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""

#: ../doc/book/box/data_model.rst:907
msgid "Complexity factor"
msgstr ""

#: ../doc/book/box/data_model.rst:907
msgid "Effect"
msgstr ""

#: ../doc/book/box/data_model.rst:910
msgid "Index size"
msgstr ""

#: ../doc/book/box/data_model.rst:910
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""

#: ../doc/book/box/data_model.rst:918
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""

#: ../doc/book/box/data_model.rst:922
msgid "Number of indexes accessed"
msgstr ""

#: ../doc/book/box/data_model.rst:922
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:926
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary "
"index fields are unchanged by the update. So, this complexity factor "
"applies only to memtx, since it always makes a full-tuple copy on every "
"update."
msgstr ""

#: ../doc/book/box/data_model.rst:932
msgid "Number of tuples accessed"
msgstr ""

#: ../doc/book/box/data_model.rst:932
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""

#: ../doc/book/box/data_model.rst:936
msgid "WAL settings"
msgstr ""

#: ../doc/book/box/data_model.rst:936
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""

