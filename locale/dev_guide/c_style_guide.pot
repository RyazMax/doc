# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/dev_guide/c_style_guide.rst:3
msgid "C Style Guide"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:5
msgid "The project's coding style is based on a version of the Linux kernel coding style."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:7
msgid "The latest version of the Linux style can be found at: http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:10
msgid "Since it is open for changes, the version of style that we follow, one from 2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:13
msgid "There are a few additional guidelines, either unique to Tarantool or deviating from the Kernel guidelines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:16
msgid "Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 \"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-invent the kernel macros\" do not apply, since they are specific to Linux kernel programming environment."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:21
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:25
msgid "General guidelines"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:27
msgid "We use Git for revision control. The latest development is happening in the default branch (currently ``master``). Our git repository is hosted on GitHub, and can be checked out with ``git clone git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:32
msgid "If you have any questions about Tarantool internals, please post them on the developer discussion list, https://groups.google.com/forum/#!forum/tarantool. However, please be warned: Launchpad silently deletes posts from non-subscribed members, thus please be sure to have subscribed to the list prior to posting. Additionally, some engineers are always present on #tarantool channel on irc.freenode.net."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:40
msgid "Commenting style"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:42
msgid "Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than `\\tag`. The main tags in use are @param, @retval, @return, @see, @note and @todo."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:45
msgid "Every function, except perhaps a very short and obvious one, should have a comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:48
msgid "/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:63
msgid "Public structures and important structure members should be commented as well."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:67
msgid "Header files"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:69
msgid "Use header guards. Put the header guard in the first line in the header, before the copyright or declarations. Use all-uppercase name for the header guard. Derive the header guard name from the file name, and append _INCLUDED to get a macro name. For example, core/log_io.h -> CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the respective declaration header before all other headers, to ensure that the header is self- sufficient. Header \"header.h\" is self-sufficient if the following compiles without errors:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:77
msgid "#include \"header.h\""
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:83
msgid "Allocating memory"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:85
msgid "Prefer the supplied slab (salloc) and pool (palloc) allocators to malloc()/free() for any performance-intensive or large  memory allocations. Repetitive use of malloc()/free() can lead to memory fragmentation and should therefore be avoided."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:89
msgid "Always free all allocated memory, even allocated  at start-up. We aim at being valgrind leak-check clean, and in most cases it's just as easy to free() the allocated memory as it is to write a valgrind suppression. Freeing all allocated memory is also dynamic-load friendly: assuming a plug-in can be dynamically loaded and unloaded multiple times, reload should not lead to a memory leak."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:97
msgid "Function naming"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:99
msgid "Our convention is to use:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:101
msgid "``new``/``delete`` for functions which allocate + initialize and destroy + deallocate an object,"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:103
msgid "``create``/``destroy`` for functions which initialize/destroy an object but do not handle memory management,"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:105
msgid "``init``/``free`` for functions which initialize/destroy libraries and subsystems."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:109
msgid "Other"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:111
msgid "Select GNU C99 extensions are acceptable. It's OK to mix declarations and statements, use true and false."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:114
msgid "The not-so-current list of all GCC C extensions can be found at: http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:119
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:121
msgid "This is a short document describing the preferred coding style for the linux kernel.  Coding style is very personal, and I won't _force_ my views on anybody, but this is what goes for anything that I have to be able to maintain, and I'd prefer it for most other things too.  Please at least consider the points made here."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:127
msgid "First off, I'd suggest printing out a copy of the GNU coding standards, and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:130
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:134
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:136
msgid "Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:141
msgid "Rationale: The whole idea behind indentation is to clearly define where a block of control starts and ends.  Especially when you've been looking at your screen for 20 straight hours, you'll find it a lot easier to see how the indentation works if you have large indentations."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:146
msgid "Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen.  The answer to that is that if you need more than 3 levels of indentation, you're screwed anyway, and should fix your program."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:152
msgid "In short, 8-char indents make things easier to read, and have the added benefit of warning you when you're nesting your functions too deep. Heed that warning."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:156
msgid "The preferred way to ease multiple indentation levels in a switch statement is to align the \"switch\" and its subordinate \"case\" labels in the same column instead of \"double-indenting\" the \"case\" labels. e.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:160
msgid "switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:180
msgid "Don't put multiple statements on a single line unless you have something to hide:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:183
msgid "if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:188
msgid "Don't put multiple assignments on a single line either. Kernel coding style is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:191
msgid "Outside of comments, documentation and except in Kconfig, spaces are never used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:194
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:199
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:201
msgid "Coding style is all about readability and maintainability using commonly available tools."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:204
msgid "The limit on the length of lines is 80 columns, reduced to 66 columns for comments, and this is a strongly preferred limit."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:207
msgid "Statements longer than 80 columns will be broken into sensible chunks. Descendants are always substantially shorter than the parent and are placed substantially to the right. The same applies to function headers with a long argument list. Long strings are as well broken into shorter strings. The only exception to this is where exceeding 80 columns significantly increases readability and does not hide information."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:214
msgid "void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:228
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:230
msgid "The other issue that always comes up in C styling is the placement of braces.  Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:236
msgid "if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:242
msgid "This applies to all non-function statement blocks (if, switch, for, while, do). e.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:245
msgid "switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:258
msgid "However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:261
msgid "int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:268
msgid "Heretic people all over the world have claimed that this inconsistency is ...  well ...  inconsistent, but all right-thinking people know that (a) K&R are _right_ and (b) K&R are right.  Besides, functions are special anyway (you can't nest them in C)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:273
msgid "Note that the closing brace is empty on a line of its own, _except_ in the cases where it is followed by a continuation of the same statement, ie a \"while\" in a do-statement or an \"else\" in an if-statement, like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:278
msgid "do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:284
msgid "and"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:286
msgid "if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:296
msgid "Rationale: K&R."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:298
msgid "Also, note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability.  Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:304
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:306
msgid "if (condition)\n"
"    action();"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:311
msgid "This does not apply if one branch of a conditional statement is a single statement. Use braces in both branches."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:314
msgid "if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:325
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:327
msgid "Linux kernel style for use of spaces depends (mostly) on function-versus-keyword usage.  Use a space after (most) keywords.  The notable exceptions are sizeof, typeof, alignof, and __attribute__, which look somewhat like functions (and are usually used with parentheses in Linux, although they are not required in the language, as in: \"sizeof info\" after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:334
msgid "So use a space after these keywords: if, switch, case, for, do, while but not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:337
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:341
msgid "Do not add spaces around (inside) parenthesized expressions. This example is **bad**:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:344
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:348
msgid "When declaring pointer data or a function that returns a pointer type, the preferred use of '*' is adjacent to the data name or function name and not adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:352
msgid "char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:358
msgid "Use one space around (on each side of) most binary and ternary operators, such as any of these:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:361
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:363
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:365
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:367
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:369
#: ../doc/dev_guide/c_style_guide.rst:373
msgid "++  --"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:371
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:375
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:377
msgid "Do not leave trailing whitespace at the ends of lines.  Some editors with \"smart\" indentation will insert whitespace at the beginning of new lines as appropriate, so you can start typing the next line of code right away. However, some such editors do not remove the whitespace if you end up not putting a line of code there, such as if you leave a blank line.  As a result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:384
msgid "Git will warn you about patches that introduce trailing whitespace, and can optionally strip the trailing whitespace for you; however, if applying a series of patches, this may make later patches in the series fail by changing their context lines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:392
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:394
msgid "C is a Spartan language, and so should your naming be.  Unlike Modula-2 and Pascal programmers, C programmers do not use cute names like ThisVariableIsATemporaryCounter.  A C programmer would call that variable \"tmp\", which is much easier to write, and not the least more difficult to understand."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:400
msgid "HOWEVER, while mixed-case names are frowned upon, descriptive names for global variables are a must.  To call a global function \"foo\" is a shooting offense."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:404
msgid "GLOBAL variables (to be used only if you _really_ need them) need to have descriptive names, as do global functions.  If you have a function that counts the number of active users, you should call that \"count_active_users()\" or similar, you should _not_ call it \"cntusr()\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:409
msgid "Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer.  No wonder MicroSoft makes buggy programs."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:414
msgid "LOCAL variable names should be short, and to the point.  If you have some random integer loop counter, it should probably be called \"i\". Calling it \"loop_counter\" is non-productive, if there is no chance of it being mis-understood.  Similarly, \"tmp\" can be just about any type of variable that is used to hold a temporary value."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:420
msgid "If you are afraid to mix up your local variable names, you have another problem, which is called the function-growth-hormone-imbalance syndrome. See chapter 6 (Functions)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:427
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:429
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:431
msgid "It's a _mistake_ to use typedef for structures and pointers. When you see a"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:433
msgid "vps_t a;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:437
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:439
msgid "In contrast, if it says"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:441
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:445
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:447
msgid "Lots of people think that typedefs \"help readability\". Not so. They are useful only for:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:450
msgid "totally opaque objects (where the typedef is actively used to _hide_ what the object is)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:453
msgid "Example: \"pte_t\" etc. opaque objects that you can only access using the proper accessor functions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:456
msgid "NOTE! Opaqueness and \"accessor functions\" are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:460
msgid "Clear integer types, where the abstraction _helps_ avoid confusion whether it is \"int\" or \"long\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:463
msgid "u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) better than here."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:466
msgid "NOTE! Again - there needs to be a _reason_ for this. If something is \"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:469
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:473
msgid "but if there is a clear reason for why it under certain circumstances might be an \"unsigned int\" and under other configurations might be \"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:477
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:480
msgid "New types which are identical to standard C99 types, in certain exceptional circumstances."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:483
msgid "Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like 'uint32_t', some people object to their use anyway."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:487
msgid "Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed equivalents which are identical to standard types are permitted -- although they are not mandatory in new code of your own."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:492
msgid "When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:495
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:497
msgid "In certain structures which are visible to userspace, we cannot require C99 types and cannot use the 'u32' form above. Thus, we use __u32 and similar types in all structures which are shared with userspace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:502
msgid "Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:505
msgid "In general, a pointer, or a struct that has elements that can reasonably be directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:511
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:513
msgid "Functions should be short and sweet, and do just one thing.  They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all know), and do one thing and do that well."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:517
msgid "The maximum length of a function is inversely proportional to the complexity and indentation level of that function.  So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it's OK to have a longer function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:523
msgid "However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely.  Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it's performance-critical, and it will probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:531
msgid "Another measure of the function is the number of local variables.  They shouldn't exceed 5-10, or you're doing something wrong.  Re-think the function, and split it into smaller pieces.  A human brain can generally easily keep track of about 7 different things, anything more and it gets confu/sed.  You know you're brilliant, but maybe you'd like to understand what you did 2 weeks from now."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:538
msgid "In source files, separate functions with one blank line.  If the function is exported, the EXPORT* macro for it should follow immediately after the closing function brace line.  E.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:542
msgid "int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:550
msgid "In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in Linux because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:556
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:558
msgid "Albeit deprecated by some people, the equivalent of the goto statement is used frequently by compilers in form of the unconditional jump instruction."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:561
msgid "The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:564
msgid "The rationale is:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:566
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:567
msgid "nesting is reduced"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:568
msgid "errors by not updating individual exit points when making modifications are prevented"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:570
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:572
msgid "int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:597
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:599
msgid "Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment: it's much better to write the code so that the _working_ is obvious, and it's a waste of time to explain badly written code. с Generally, you want your comments to tell WHAT your code does, not HOW. Also, try to avoid putting comments inside a function body: if the function is so complex that you need to separately comment parts of it, you should probably go back to chapter 6 for a while.  You can make small comments to note or warn about something particularly clever (or ugly), but try to avoid excess.  Instead, put the comments at the head of the function, telling people what it does, and possibly WHY it does it."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:613
msgid "When commenting the kernel API functions, please use the kernel-doc format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc for details."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:617
msgid "Linux style for comments is the C89 :code:`/* ... */`` style. Don't use C99-style :code:`// ...` comments."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:620
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:622
msgid "/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:633
msgid "It's also important to comment data, whether they are basic types or derived types.  To this end, use just one data declaration per line (no commas for multiple data declarations).  This leaves you room for a small comment on each item, explaining its use."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:640
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:642
msgid "That's OK, we all do.  You've probably been told by your long-time Unix user helper that \"GNU emacs\" automatically formats the C sources for you, and you've noticed that yes, it does do that, but the defaults it uses are less than desirable (in fact, they are worse than random typing - an infinite number of monkeys typing into GNU emacs would never make a good program)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:649
msgid "So, you can either get rid of GNU emacs, or change it to use saner values.  To do the latter, you can stick the following in your .emacs file:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:652
msgid "(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:683
msgid "This will make emacs go better with the kernel coding style for C files below ~/src/linux-trees."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:686
msgid "But even if you fail in getting emacs to do sane formatting, not everything is lost: use \"indent\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:689
msgid "Now, again, GNU indent has the same brain-dead settings that GNU emacs has, which is why you need to give it a few command line options. However, that's not too bad, because even the makers of GNU indent recognize the authority of K&R (the GNU people aren't evil, they are just severely misguided in this matter), so you just give indent the options \"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use \"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:697
msgid "\"indent\" has a lot of options, and especially when it comes to comment re-formatting you may want to take a look at the man page.  But remember: \"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:704
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:706
msgid "For all of the Kconfig* configuration files throughout the source tree, the indentation is somewhat different.  Lines under a \"config\" definition are indented with one tab, while help text is indented an additional two spaces. Example:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:711
msgid "config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:722
msgid "Features that might still be considered unstable should be defined as dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:725
msgid "config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:732
msgid "while seriously dangerous features (such as write support for certain filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:735
msgid "config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:742
msgid "For full documentation on the configuration files, see the file Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:748
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:750
msgid "Data structures that have visibility outside the single-threaded environment they are created and destroyed in should always have reference counts.  In the kernel, garbage collection doesn't exist (and outside the kernel garbage collection is slow and inefficient), which means that you absolutely _have_ to reference count all your uses."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:756
msgid "Reference counting means that you can avoid locking, and allows multiple users to have access to the data structure in parallel - and not having to worry about the structure suddenly going away from under them just because they slept or did something else for a while."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:761
msgid "Note that locking is _not_ a replacement for reference counting. Locking is used to keep data structures coherent, while reference counting is a memory management technique.  Usually both are needed, and they are not to be confused with each other."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:766
msgid "Many data structures can indeed have two levels of reference counting, when there are users of different \"classes\".  The subclass count counts the number of subclass users, and decrements the global count just once when the subclass count goes to zero."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:771
msgid "Examples of this kind of \"multi-level-reference-counting\" can be found in memory management (\"struct mm_struct\": mm_users and mm_count), and in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:775
msgid "Remember: if another thread can find your data structure, and you don't have a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:780
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:782
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:784
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:788
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:790
msgid "CAPITALIZED macro names are appreciated but macros resembling functions may be named in lower case."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:793
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:795
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:797
msgid "#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:805
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:807
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:809
msgid "#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:817
msgid "is a _very_ bad idea.  It looks like a function call but exits the \"calling\" function; don't break the internal parsers of those who will read the code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:820
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:822
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:826
msgid "might look like a good thing, but it's confusing as hell when one reads the code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:829
msgid "macros with arguments that are used as l-values: FOO(x) = y; will bite you if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:832
msgid "forgetting about precedence: macros defining constants using expressions must enclose the expression in parentheses. Beware of similar issues with macros using parameters."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:836
msgid "#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:841
msgid "The cpp manual deals with macros exhaustively. The gcc internals manual also covers RTL which is used frequently with assembly language in the kernel."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:846
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:848
msgid "Kernel developers like to be seen as literate. Do mind the spelling of kernel messages to make a good impression. Do not use crippled words like \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages concise, clear, and unambiguous."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:853
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:855
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:857
msgid "There are a number of driver model diagnostic macros in <linux/device.h> which you should use to make sure messages are matched to the right device and driver, and are tagged with the right level:  dev_err(), dev_warn(), dev_info(), and so forth.  For messages that aren't associated with a particular device, <linux/kernel.h> defines pr_debug() and pr_info()."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:863
msgid "Coming up with good debugging messages can be quite a challenge; and once you have them, they can be a huge help for remote troubleshooting.  Such messages should be compiled out when the DEBUG symbol is not defined (that is, by default they are not included).  When you use dev_dbg() or pr_debug(), that's automatic.  Many subsystems have Kconfig options to turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:873
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:875
msgid "The kernel provides the following general purpose memory allocators: kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API documentation for further information about them."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:879
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:881
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:885
msgid "The alternative form where struct name is spelled out hurts readability and introduces an opportunity for a bug when the pointer variable type is changed but the corresponding sizeof that is passed to a memory allocator is not."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:889
msgid "Casting the return value which is a void pointer is redundant. The conversion from void pointer to any other pointer type is guaranteed by the C programming language."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:895
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:897
msgid "There appears to be a common misperception that gcc has a magic \"make me faster\" speedup option called \"inline\". While the use of inlines can be appropriate (for example as a means of replacing macros, see Chapter 12), it very often is not. Abundant use of the inline keyword leads to a much bigger kernel, which in turn slows the system as a whole down, due to a bigger icache footprint for the CPU and simply because there is less memory available for the pagecache. Just think about it; a pagecache miss causes a disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:907
msgid "A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them. An exception to this rule are the cases where a parameter is known to be a compiletime constant, and as a result of this constantness you *know* the compiler will be able to optimize most of your function away at compile time. For a good example of this later case, see the kmalloc() inline function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:914
msgid "Often people argue that adding inline to functions that are static and used only once is always a win since there is no space tradeoff. While this is technically correct, gcc is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells gcc to do something it would have done anyway."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:923
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:925
msgid "Functions can return values of many different kinds, and one of the most common is a value indicating whether the function succeeded or failed.  Such a value can be represented as an error-code integer (-Exxx = failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero = success)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:931
msgid "Mixing up these two sorts of representations is a fertile source of difficult-to-find bugs.  If the C language included a strong distinction between integers and booleans then the compiler would find these mistakes for us... but it doesn't.  To help prevent such bugs, always follow this convention:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:973
msgid "If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:943
msgid "For example, \"add work\" is a command, and the add_work() function returns 0 for success or -EBUSY for failure.  In the same way, \"PCI device present\" is a predicate, and the pci_dev_present() function returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:948
msgid "All EXPORTed functions must respect this convention, and so should all public functions.  Private (static) functions need not, but it is recommended that they do."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:952
msgid "Functions whose return value is the actual result of a computation, rather than an indication of whether the computation succeeded, are not subject to this rule.  Generally they indicate failure by returning some out-of-range result.  Typical examples would be functions that return pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:961
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:963
msgid "The header file include/linux/kernel.h contains a number of macros that you should use, rather than explicitly coding some variant of them yourself. For example, if you need to calculate the length of an array, take advantage of the macro"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:968
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:972
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:974
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:978
msgid "There are also min() and max() macros that do strict type checking if you need them.  Feel free to peruse that header file to see what else is already defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:984
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:986
msgid "Some editors can interpret configuration information embedded in source files, indicated with special markers.  For example, emacs interprets lines marked like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:990
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:994
msgid "Or like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:996
msgid "/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1004
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1006
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1010
msgid "Do not include any of these in source files.  People have their own personal editor configurations, and your source files should not override them.  This includes markers for indentation and mode configuration.  People may use their own custom mode, or may have some other magic method for making indentation work correctly."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1018
msgid "Appendix I: References"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1020
msgid "`The C Programming Language, Second Edition <https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1025
msgid "`The Practice of Programming <https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W. Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1030
msgid "`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R and this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1033
msgid "`WG14 International standardization workgroup for the programming language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1036
msgid "`Kernel CodingStyle, by greg@kroah.com at OLS 2002 <http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

