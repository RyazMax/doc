# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-23 12:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/reference/configuration/index.rst:5
#: ../doc/reference/reference_rock/vshard/index.rst:998
msgid "Configuration reference"
msgstr ""

#: ../doc/reference/configuration/index.rst:7
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:10
msgid "Tarantool is started by entering either of the following command:"
msgstr ""

#: ../doc/reference/configuration/index.rst:49
msgid "$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/reference/configuration/index.rst:23
msgid "Command options"
msgstr ""

#: ../doc/reference/configuration/index.rst:27
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/reference/configuration/index.rst:33
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:35
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/reference/configuration/index.rst:42
#: ../doc/reference/reference_sql/sql.rst:4242
msgid "In this example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:44
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../doc/reference/configuration/index.rst:47
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/reference/configuration/index.rst:55
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../doc/reference/configuration/index.rst:60
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/reference/configuration/index.rst:70
msgid "URI"
msgstr ""

#: ../doc/reference/configuration/index.rst:72
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
msgid "URI fragment"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
#: ../doc/reference/reference_lua/digest.rst:353
#: ../doc/reference/reference_lua/fiber.rst:823
#: ../doc/reference/reference_lua/fiber.rst:1020
#: ../doc/reference/reference_lua/fiber.rst:1149
#: ../doc/reference/reference_lua/log.rst:144
#: ../doc/reference/reference_lua/msgpack.rst:172
#: ../doc/reference/reference_lua/net_box.rst:570
#: ../doc/reference/reference_lua/tap.rst:348
#: ../doc/reference/reference_lua/uuid.rst:132
#: ../doc/reference/reference_lua/yaml.rst:68
#: ../doc/reference/reference_rock/dbms.rst:249
#: ../doc/reference/reference_rock/dbms.rst:590
msgid "Example"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "port"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "username:password@host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:100
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/reference/configuration/index.rst:104
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:110
msgid "Initialization file"
msgstr ""

#: ../doc/reference/configuration/index.rst:112
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/reference/configuration/index.rst:120
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/reference/configuration/index.rst:131
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../doc/reference/configuration/index.rst:135
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/reference/configuration/index.rst:149
msgid "If you wish to start an interactive session on the same terminal after initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:165
msgid "Configuration parameters"
msgstr ""

#: ../doc/reference/configuration/index.rst:167
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/reference/configuration/index.rst:169
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/reference/configuration/index.rst:171
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/reference/configuration/index.rst:176
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/reference/configuration/index.rst:181
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/reference/configuration/index.rst:184
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, for logging, and for feedback."
msgstr ""

#: ../doc/reference/configuration/index.rst:190
#: ../doc/reference/reference_rock/vshard/index.rst:1004
msgid "Basic parameters"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:13
msgid ":ref:`strip_core <cfg_basic-strip_core>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:19
msgid "Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../doc/reference/configuration/cfg_basic.rst:112
#: ../doc/reference/configuration/cfg_basic.rst:233
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/reference/configuration/cfg_replication.rst:124
#: ../doc/reference/configuration/cfg_logging.rst:134
#: ../doc/reference/configuration/cfg_logging.rst:291
#: ../doc/reference/configuration/cfg_deprecated.rst:25
#: ../doc/reference/configuration/cfg_deprecated.rst:55
#: ../doc/reference/configuration/cfg_deprecated.rst:66
#: ../doc/reference/reference_rock/vshard/index.rst:1087
msgid "Type: boolean"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:24
#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/reference/configuration/cfg_replication.rst:125
#: ../doc/reference/configuration/cfg_deprecated.rst:26
#: ../doc/reference/reference_rock/vshard/index.rst:1023
#: ../doc/reference/reference_rock/vshard/index.rst:1034
msgid "Default: false"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:25
#: ../doc/reference/configuration/cfg_basic.rst:87
#: ../doc/reference/configuration/cfg_basic.rst:98
#: ../doc/reference/configuration/cfg_basic.rst:142
#: ../doc/reference/configuration/cfg_basic.rst:169
#: ../doc/reference/configuration/cfg_basic.rst:183
#: ../doc/reference/configuration/cfg_basic.rst:208
#: ../doc/reference/configuration/cfg_basic.rst:235
#: ../doc/reference/configuration/cfg_storage.rst:43
#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../doc/reference/configuration/cfg_storage.rst:69
#: ../doc/reference/configuration/cfg_storage.rst:93
#: ../doc/reference/configuration/cfg_storage.rst:115
#: ../doc/reference/configuration/cfg_storage.rst:139
#: ../doc/reference/configuration/cfg_storage.rst:152
#: ../doc/reference/configuration/cfg_storage.rst:164
#: ../doc/reference/configuration/cfg_storage.rst:175
#: ../doc/reference/configuration/cfg_storage.rst:186
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:216
#: ../doc/reference/configuration/cfg_replication.rst:238
#: ../doc/reference/configuration/cfg_logging.rst:112
#: ../doc/reference/configuration/cfg_logging.rst:136
#: ../doc/reference/configuration/cfg_deprecated.rst:27
#: ../doc/reference/configuration/cfg_deprecated.rst:57
#: ../doc/reference/configuration/cfg_deprecated.rst:95
#: ../doc/reference/configuration/cfg_deprecated.rst:110
#: ../doc/reference/reference_rock/vshard/index.rst:1045
#: ../doc/reference/reference_rock/vshard/index.rst:1069
msgid "Dynamic: no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:31
msgid "Add the given string to the server's process title (what’s shown in the COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:35
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:38
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:43
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:46
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:51
#: ../doc/reference/configuration/cfg_basic.rst:85
#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:140
#: ../doc/reference/configuration/cfg_basic.rst:167
#: ../doc/reference/configuration/cfg_basic.rst:181
#: ../doc/reference/configuration/cfg_basic.rst:206
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/reference/configuration/cfg_replication.rst:44
#: ../doc/reference/configuration/cfg_replication.rst:214
#: ../doc/reference/configuration/cfg_replication.rst:236
#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../doc/reference/configuration/cfg_logging.rst:189
#: ../doc/reference/configuration/cfg_logging.rst:302
msgid "Type: string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:52
#: ../doc/reference/configuration/cfg_basic.rst:74
#: ../doc/reference/configuration/cfg_basic.rst:97
#: ../doc/reference/configuration/cfg_basic.rst:168
#: ../doc/reference/configuration/cfg_basic.rst:207
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/reference/configuration/cfg_replication.rst:45
#: ../doc/reference/configuration/cfg_replication.rst:104
#: ../doc/reference/configuration/cfg_replication.rst:215
#: ../doc/reference/configuration/cfg_replication.rst:237
#: ../doc/reference/configuration/cfg_networking.rst:15
#: ../doc/reference/configuration/cfg_logging.rst:111
msgid "Default: null"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:53
#: ../doc/reference/configuration/cfg_basic.rst:75
#: ../doc/reference/configuration/cfg_basic.rst:114
#: ../doc/reference/configuration/cfg_basic.rst:159
#: ../doc/reference/configuration/cfg_basic.rst:222
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:100
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:112
#: ../doc/reference/configuration/cfg_deprecated.rst:68
#: ../doc/reference/reference_rock/vshard/index.rst:1024
#: ../doc/reference/reference_rock/vshard/index.rst:1035
#: ../doc/reference/reference_rock/vshard/index.rst:1079
#: ../doc/reference/reference_rock/vshard/index.rst:1089
#: ../doc/reference/reference_rock/vshard/index.rst:1101
#: ../doc/reference/reference_rock/vshard/index.rst:1116
#: ../doc/reference/reference_rock/vshard/index.rst:1137
msgid "Dynamic: yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:59
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:66
msgid "A typical value is 3301."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:70
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:73
msgid "Type: integer or string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:81
msgid "A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:86
#: ../doc/reference/configuration/cfg_basic.rst:141
#: ../doc/reference/configuration/cfg_basic.rst:182
msgid "Default: \".\""
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:93
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:104
msgid "Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. After this, any requests that try to change persistent data will fail with error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :ref:`replication <replication>`. Read-only mode does not affect data-change requests for spaces defined as :ref:`temporary <box_schema-space_create>`. Although read-only mode prevents the server from writing to the :ref:`WAL <internals-wal>`, it does not prevent writing diagnostics with the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:116
msgid "Setting ``read_only == true`` affects spaces differently depending on the options that were used during :ref:`box.schema.space.create <box_schema-space_create>`, as summarized by this chart:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Option"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be created?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be written to?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is replicated?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is persistent?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
msgid "(default)"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:127
msgid "temporary"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "is_local"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:136
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:148
msgid "The vinyl storage engine has a scheduler which does compaction. When vinyl is low on available memory, the compaction scheduler may be unable to keep up with incoming update requests. In that situation, queries may time out after ``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would throttle inserts when it is running low on compaction bandwidth. Compaction can also be ordered manually with :ref:`index_object:compact() <box_index-compact>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:157
#: ../doc/reference/configuration/cfg_storage.rst:28
#: ../doc/reference/configuration/cfg_storage.rst:67
#: ../doc/reference/configuration/cfg_storage.rst:162
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/reference/configuration/cfg_replication.rst:75
#: ../doc/reference/configuration/cfg_replication.rst:148
#: ../doc/reference/configuration/cfg_replication.rst:165
#: ../doc/reference/configuration/cfg_networking.rst:14
#: ../doc/reference/configuration/cfg_logging.rst:146
#: ../doc/reference/configuration/cfg_logging.rst:312
#: ../doc/reference/configuration/cfg_deprecated.rst:93
#: ../doc/reference/configuration/cfg_deprecated.rst:108
msgid "Type: float"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:158
msgid "Default: 60"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:165
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:175
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:189
msgid "A directory where database working files will be stored. The server instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:195
msgid "box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:203
msgid "will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:215
msgid "The maximum number of threads to use during execution of certain internal processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:220
#: ../doc/reference/configuration/cfg_storage.rst:41
#: ../doc/reference/configuration/cfg_storage.rst:53
#: ../doc/reference/configuration/cfg_storage.rst:78
#: ../doc/reference/configuration/cfg_storage.rst:91
#: ../doc/reference/configuration/cfg_storage.rst:101
#: ../doc/reference/configuration/cfg_storage.rst:113
#: ../doc/reference/configuration/cfg_storage.rst:137
#: ../doc/reference/configuration/cfg_storage.rst:150
#: ../doc/reference/configuration/cfg_storage.rst:173
#: ../doc/reference/configuration/cfg_storage.rst:184
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:110
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:58
#: ../doc/reference/configuration/cfg_replication.rst:103
#: ../doc/reference/configuration/cfg_networking.rst:50
#: ../doc/reference/configuration/cfg_networking.rst:67
#: ../doc/reference/configuration/cfg_logging.rst:28
msgid "Type: integer"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:221
#: ../doc/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:228
msgid "Whether coredump files should include memory allocated for tuples. (This can be large if Tarantool runs under heavy load.) Setting to ``true`` means \"do not include\". In an older version of Tarantool the default value of this parameter was ``false``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:234
#: ../doc/reference/configuration/cfg_logging.rst:292
#: ../doc/reference/configuration/cfg_deprecated.rst:56
#: ../doc/reference/configuration/cfg_deprecated.rst:67
msgid "Default: true"
msgstr ""

#: ../doc/reference/configuration/index.rst:196
msgid "Configuring the storage"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:19
msgid "How much memory Tarantool allocates to actually store tuples, in bytes. When the limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the ``memtx_memory`` limit to allocate tuples, but there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:30
#: ../doc/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:36
msgid "Size of the largest allocation unit, in bytes, for the memtx storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:42
#: ../doc/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:49
msgid "Size of the smallest allocation unit, in bytes. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:61
msgid "Bloom filter false positive rate -- the suitable probability of the `bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:75
msgid "The cache size for the vinyl storage engine, in bytes. The cache can be resized dynamically."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:79
#: ../doc/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:80
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/reference/configuration/cfg_replication.rst:46
#: ../doc/reference/configuration/cfg_replication.rst:60
#: ../doc/reference/configuration/cfg_replication.rst:77
#: ../doc/reference/configuration/cfg_replication.rst:105
#: ../doc/reference/configuration/cfg_replication.rst:126
#: ../doc/reference/configuration/cfg_replication.rst:150
#: ../doc/reference/configuration/cfg_replication.rst:167
#: ../doc/reference/configuration/cfg_networking.rst:16
#: ../doc/reference/configuration/cfg_networking.rst:52
#: ../doc/reference/configuration/cfg_networking.rst:69
#: ../doc/reference/configuration/cfg_logging.rst:30
#: ../doc/reference/configuration/cfg_logging.rst:148
#: ../doc/reference/configuration/cfg_logging.rst:191
#: ../doc/reference/configuration/cfg_logging.rst:293
#: ../doc/reference/configuration/cfg_logging.rst:304
#: ../doc/reference/configuration/cfg_logging.rst:314
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:86
msgid "Size of the largest allocation unit, in bytes, for the vinyl storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:99
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:109
msgid "Page size, in bytes. Page is a read/write unit for vinyl disk operations. The ``vinyl_page_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:114
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:121
msgid "The default maximum range size for a vinyl index, in bytes. The maximum range size affects the decision whether to :ref:`split <engines-vinyl_split>` a range."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:125
msgid "If ``vinyl_range_size`` is not nil and not 0, then it is used as the default value for the ``range_size`` option in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:130
msgid "If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified when the index is created, then Tarantool sets a value later depending on performance considerations. To see the actual value, use :ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:135
msgid "In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value was 1073741824."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:138
msgid "Default = nil"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:145
msgid "The maximal number of runs per level in vinyl LSM tree. If this number is exceeded, a new level is created. The ``vinyl_run_count_per_level`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:151
#: ../doc/reference/configuration/cfg_storage.rst:185
msgid "Default = 2"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:158
msgid "Ratio between the sizes of different levels in the LSM tree. The ``vinyl_run_size_ratio`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:163
msgid "Default = 3.5"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:170
msgid "The maximum number of read threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:174
msgid "Default = 1"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:181
msgid "The maximum number of write threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/index.rst:204
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:3
msgid ":ref:`checkpoint_wal_threshold <cfg_checkpoint_daemon-checkpoint_wal_threshold>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:5
msgid "The checkpoint daemon is a fiber which is constantly running. At intervals, it may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may delete old snapshot files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:9
msgid "The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before deletions occur."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:16
msgid "**Tarantool garbage collector**"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:18
msgid "The checkpoint daemon may activate the Tarantool garbage collector which deletes old files. This garbage collector is distinct from the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ which is for Lua objects, and distinct from a Tarantool garbage collector which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:25
msgid "If the checkpoint daemon deletes an old snapshot file, then the Tarantool garbage collector will also delete any :ref:`write-ahead log (.xlog) <internals-wal>` files which are older than the snapshot file and which contain information that is present in the snapshot file. It will also delete obsolete vinyl ``.run`` files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:31
msgid "The checkpoint daemon and the Tarantool garbage collector will not delete a file if:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:33
msgid "a **backup** is ongoing and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:36
msgid "**replication** is ongoing and the file has not been relayed to a replica (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:39
msgid "a replica is connecting, or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:41
msgid "a replica has fallen behind. The progress of each replica is tracked; if a replica's position is far from being up to date, then the server stops to give it a chance to catch up. If an administrator concludes that a replica is permanently down, then the correct procedure is to restart the server, or (preferably) :ref:`remove the replica from the cluster <replication-remove_instances>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:53
msgid "The interval between actions by the checkpoint daemon, in seconds. If ``checkpoint_interval`` is set to a value greater than zero, and there is activity which causes change to a database, then the checkpoint daemon will call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, creating a new snapshot file each time. If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:60
#: ../doc/reference/reference_lua/box_error.rst:70
#: ../doc/reference/reference_lua/digest.rst:227
#: ../doc/reference/reference_rock/dbms.rst:82
#: ../doc/reference/reference_rock/dbms.rst:435
#: ../doc/reference/reference_rock/vshard/index.rst:843
#: ../doc/reference/reference_sql/sql.rst:2374
#: ../doc/reference/reference_sql/sql.rst:3092
#: ../doc/reference/reference_sql/sql.rst:4132
msgid "For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:62
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:66
msgid "will cause the checkpoint daemon to create a new database snapshot once per minute, if there is activity."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:70
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:77
msgid "The maximum number of snapshots that may exist on the :ref:`memtx_dir <cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does not delete old snapshots. For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:83
msgid "box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:90
msgid "will cause the checkpoint daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will delete the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:94
msgid "Remember that, as noted earlier, snapshots will not be deleted if replication is ongoing and the file has not been relayed to a replica. Therefore ``checkpoint_count`` has no effect unless all replicas are alive."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:97
msgid "Default: 2"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:106
msgid "The threshold for the total size in bytes of all WAL files created since the last checkpoint. Once the configured threshold is exceeded, the WAL thread notifies the checkpoint daemon that it must make a new checkpoint and delete old WAL files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:111
msgid "Default: 10^18 (a large number so in effect there is no limit by default)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:114
msgid "This parameter was added in version 2.1. It enables administrators to handle a problem that could occur with calculating how much disk space to allocate for a partition containing WAL files. For example, suppose :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` = 2 and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` = 5 and the average amount that Tarantool writes between each checkpoint interval = 1 GB. Then one could calculate that the necessary amount is (2*5*1) 10GB. But this calculation would be wrong if, instead of writing 1 GB during one checkpoint interval, Tarantool encounters an unusual spike and tries to write 11 GB, causing an operating-system ENOSPC (\"no space\") error. By setting checkpoint_wal_threshold to a lower value, say 9 GB, an administrator could prevent the error."
msgstr ""

#: ../doc/reference/configuration/index.rst:210
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If ``force_recovery`` equals true, Tarantool tries to continue if there is an error while reading a :ref:`snapshot file<index-box_persistence>` (at server instance start) or a :ref:`write-ahead log file<internals-wal>` (at server instance start or when applying an update at a replica): skips invalid records, reads as much data as possible and lets the process finish with a warning. Users can prevent the error from recurring by writing to the database and executing :ref:`box.snapshot() <box-snapshot>`."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid "The maximum number of bytes in a single write-ahead log file. When a request would cause an .xlog file to become larger than ``wal_max_size``, Tarantool creates another WAL file -- the same effect that happens when the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit is reached."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid "Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and moving snapshots to a separate disk. The limit also affects what :ref:`box.stat.vinyl().regulator <box_introspection-box_stat_vinyl_regulator>` may show for the write rate of dumps to .run and .index files."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of :ref:`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:218
msgid "Hot standby"
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:5
msgid "Hot standby is a feature which provides a simple form of failover without :ref:`replication <replication>`."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:8
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:12
msgid "To initiate the standby instance, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings -- including the same directories and same non-null URIs -- and with the additional configuration setting ``hot_standby = true``. Expect to see a notification ending with the words ``I> Entering hot standby mode``. This is fine. It means that the standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:22
msgid "The standby instance will initialize and will try to take a lock on :ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has made a lock on ``wal_dir``. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in sync), and trying to take the lock. If the primary instance goes down for any reason, the lock will be released. In this case, the standby instance will succeed in taking the lock, will connect on the :ref:`listen <cfg_basic-listen>` address and will become the primary instance. Expect to see a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:39
msgid "if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:43
msgid "if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:45
msgid "for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/reference/configuration/index.rst:224
msgid "Replication"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:3
msgid ":ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:4
msgid ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:5
msgid ":ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:15
msgid "If ``replication`` is not an empty string, the instance is considered to be a Tarantool :ref:`replica <replication>`. The replica will try to connect to the master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:22
msgid "If there is more than one replication source in a replica set, specify an array of URIs, for example (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:28
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it is possible to use the same ``replication`` specification on multiple server instances, as shown in :ref:`these examples <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:36
msgid "A read-only replica does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:39
msgid "The ``replication`` parameter is dynamic, that is, to enter master mode, simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:52
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:59
#: ../doc/reference/reference_rock/vshard/index.rst:1100
#: ../doc/reference/reference_rock/vshard/index.rst:1115
#: ../doc/reference/reference_rock/vshard/index.rst:1166
msgid "Default: 1"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:66
msgid "The number of seconds that a replica will wait when trying to connect to a master in a cluster. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:70
msgid "This parameter is different from :ref:`replication_timeout <cfg_replication-replication_timeout>`, which is only used to automatically reconnect replication when it gets no heartbeats."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:83
msgid "By default a replica will try to connect to all the masters, or it will not start. (The default is recommended so that all replicas will receive the same replica set UUID.)"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:87
msgid "However, by specifying ``replication_connect_quorum = N``, where N is a number greater than or equal to zero, users can state that the replica only needs to connect to N masters."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:91
msgid "This parameter has effect during bootstrap and during :ref:`configuration update <replication-configuration_update>`. Setting ``replication_connect_quorum = 0`` makes Tarantool require no immediate reconnect only in case of recovery. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:97
#: ../doc/reference/configuration/cfg_replication.rst:118
#: ../doc/reference/configuration/cfg_replication.rst:208
#: ../doc/reference/configuration/cfg_replication.rst:230
#: ../doc/reference/reference_lua/other.rst:163
#: ../doc/reference/reference_lua/swim.rst:142
#: ../doc/reference/reference_lua/swim.rst:225
#: ../doc/reference/reference_lua/swim.rst:238
#: ../doc/reference/reference_lua/swim.rst:336
#: ../doc/reference/reference_lua/swim.rst:517
#: ../doc/reference/reference_lua/swim.rst:549
#: ../doc/reference/reference_lua/swim.rst:711
#: ../doc/reference/reference_lua/swim.rst:736
#: ../doc/reference/reference_lua/swim.rst:921
#: ../doc/reference/reference_sql/sql.rst:2722
#: ../doc/reference/reference_sql/sql.rst:3306
#: ../doc/reference/reference_sql/sql.rst:3397
#: ../doc/reference/reference_sql/sql.rst:4229
#: ../doc/reference/reference_sql/sql.rst:4254
#: ../doc/reference/reference_sql/sql.rst:4307
#: ../doc/reference/reference_sql/sql.rst:4389
#: ../doc/reference/reference_sql/sql.rst:4430
#: ../doc/reference/reference_sql/sql.rst:4460
#: ../doc/reference/reference_sql/sql.rst:4489
#: ../doc/reference/reference_sql/sql.rst:4848
#: ../doc/reference/reference_sql/sql.rst:4908
#: ../doc/reference/reference_sql/sql.rst:5979
#: ../doc/reference/reference_sql/sql.rst:6050
#: ../doc/reference/reference_sql/sql.rst:6152
#: ../doc/reference/reference_sql/sql.rst:6210
#: ../doc/reference/reference_sql/sql.rst:6262
#: ../doc/reference/reference_sql/sql.rst:6317
#: ../doc/reference/reference_sql/sql.rst:6367
msgid "Example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:111
msgid "By default, if a replica adds a unique key that another replica has added, replication :ref:`stops <replication-replication_stops>` with error = ER_TUPLE_FOUND."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:115
msgid "However, by specifying ``replication_skip_conflict = true``, users can state that such errors may be ignored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:133
msgid "The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a replica. When a replica :ref:`syncs <replication-orphan_status>` (gets updates from a master), it may not catch up completely. The number of seconds that the replica is behind the master is called the \"lag\". Syncing is considered to be complete when the replica's lag is less than or equal to ``replication_sync_lag``."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:140
msgid "If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 (TIMEOUT_INFINITY), then lag does not matter -- the replica is always considered to be \"synced\". Also, the lag is ignored (assumed to be infinite) in case the master is running Tarantool older than 1.7.7, which does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:145
msgid "This parameter is ignored during bootstrap. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:156
msgid "The number of seconds that a replica will wait when trying to sync with a master in a cluster, or a :ref:`quorum <cfg_replication-replication_connect_quorum>` of masters, after connecting or during :ref:`configuration update <replication-configuration_update>`. This could fail indefinitely if ``replication_sync_lag`` is smaller than network latency, or if the replica cannot keep pace with master updates. If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan status <replication-orphan_status>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:173
msgid "As described in section :ref:`\"Replication architecture\" <replication-architecture>`, each replica set is identified by a `universally unique identifier <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called **replica set UUID**, and each instance is identified by an **instance UUID**."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:180
msgid "Ordinarily it is sufficient to let the system generate and format the UUID strings which will be permanently stored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:183
msgid "However, some administrators may prefer to store Tarantool configuration information in a central repository, for example `Apache ZooKeeper <https://zookeeper.apache.org>`_. Such administrators can assign their own UUID values for either -- or both -- instances (:ref:`instance_uuid <cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), when starting up for the first time."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:192
msgid "The values must be true unique identifiers, not shared by other instances or replica sets within the common infrastructure."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:195
msgid "The values must be used consistently, not changed after initial setup (the initial values are stored in :ref:`snapshot files <index-box_persistence>` and are checked whenever the system is restarted)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:199
msgid "The values must comply with `RFC 4122 <https://tools.ietf.org/html/rfc4122>`_. The `nil UUID <https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:203
msgid "The UUID format includes sixteen octets represented as 32 hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric characters and four hyphens)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:222
msgid "For replication administration purposes, it is possible to set the `universally unique identifiers <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the instance (``instance_uuid``) and the replica set (``replicaset_uuid``), instead of having the system generate the values."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:227
msgid "See the description of :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` parameter for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr ""

#: ../doc/reference/configuration/index.rst:230
msgid "Networking"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:9
msgid "The instance will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:22
msgid "To handle messages, Tarantool allocates fibers. To prevent fiber overhead from affecting the whole system, Tarantool restricts how many messages the fibers handle, so that some pending requests are blocked."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:27
msgid "On powerful systems, increase ``net_msg_max`` and the scheduler will immediately start processing pending requests."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:30
msgid "On weaker systems, decrease ``net_msg_max`` and the overhead may decrease although this may take some time because the scheduler must wait until already-running requests finish."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:34
msgid "When ``net_msg_max`` is reached, Tarantool suspends processing of incoming packages until it has processed earlier messages. This is not a direct restriction of the number of fibers that handle network messages, rather it is a system-wide restriction of channel bandwidth. This in turn causes restriction of the number of incoming network messages that the :ref:`transaction processor thread <atomic-threads_fibers_yields>` handles, and therefore indirectly affects the fibers that handle network messages. (The number of fibers is smaller than the number of messages because messages can be released as soon as they are delivered, while incoming requests might not be processed until some time after delivery.)"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:58
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr ""

#: ../doc/reference/configuration/index.rst:236
msgid "Logging"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:13
msgid "What level of detail the :ref:`log <admin-logs>` will have. There are seven levels:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:15
#: ../doc/reference/reference_lua/log.rst:91
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:17
#: ../doc/reference/reference_lua/log.rst:93
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:23
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:32
msgid "Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:41
msgid "By default, Tarantool sends the log to the standard error stream (``stderr``). If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:47
msgid "box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:53
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``log`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:59
msgid "box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:65
msgid "This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:73
msgid "box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:83
msgid "If the ``log`` string begins with \"syslog:\", then it is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. The setting can be 'syslog:', 'syslog:facility=...', 'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:90
msgid "The ``syslog:identity`` setting is an arbitrary string which will be placed at the beginning of all messages. The default value is: tarantool."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:93
msgid "The ``syslog:facility`` setting is currently ignored but will be used in the future. The value must be one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd where the message should go. The possible values are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7. The default value is: user."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:100
msgid "The ``syslog:server`` setting is the locator for the syslog server. It can be a Unix socket path beginning with \"unix:\", or an ipv4 port number. The default socket value is: dev/log (on Linux) or /var/run/syslog (on Mac OS). The default port value is: 514, the UDP port."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:105
msgid "When logging to a file, Tarantool reopens the log on `SIGHUP <https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:118
msgid "If ``log_nonblock`` equals true, Tarantool does not block during logging when the system is not ready for writing, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go to the log, setting ``log_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:124
msgid "This parameter has effect only if the output is going to \"syslog:\" or \"pipe:\". Setting ``log_nonblock`` to true is illegal if the output is going to a file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:129
msgid "The default ``log_nonblock`` value is nil, which means that blocking behavior corresponds to the type of logger. This is a behavior change: in earlier versions of the Tarantool server, the default value was true."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:135
msgid "Default: nil"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:142
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:147
#: ../doc/reference/reference_rock/vshard/index.rst:1078
msgid "Default: 0.5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:154
msgid "Log entries have two possible formats:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:156
#: ../doc/reference/reference_lua/log.rst:21
msgid "'plain' (the default), or"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:157
#: ../doc/reference/reference_lua/log.rst:22
msgid "'json' (with more detail and with JSON labels)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:159
#: ../doc/reference/reference_lua/log.rst:24
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:161
#: ../doc/reference/reference_lua/log.rst:26
msgid "2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' configuration option to \"plain\""
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:165
#: ../doc/reference/reference_lua/log.rst:30
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:167
#: ../doc/reference/reference_lua/log.rst:32
msgid "{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:179
msgid "The ``log_format='plain'`` entry has time, process id, cord name, :ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:184
msgid "The ``log_format='json'`` entry has the same things along with their labels, and in addition has the file name and line number of the Tarantool source."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:187
msgid "Setting ``log_format`` to 'json' is illegal if the output is going to \"syslog:\"."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:190
msgid "Default: 'plain'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:197
msgid "Logging example"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:199
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:202
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:204
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:207
msgid "box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:213
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1517
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:221
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:223
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:227
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1530
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:234
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool instance. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1540
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:244
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:246
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:250
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1554
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:259
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1562
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:269
msgid "Feedback"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:271
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:272
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:273
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:275
msgid "By default a Tarantool daemon sends a small packet once per hour, to https://feedback.tarantool.io. The packet contains three values from :ref:`box.info <box_introspection-box_info>`: ``box.info.version``, ``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the feedback configuration parameters, users can adjust or turn off this feature."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:286
msgid "Whether to send feedback."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:288
msgid "If this is set to ``true``, feedback will be sent as described above. If this is set to ``false``, no feedback will be sent."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:299
msgid "The address to which the packet is sent. Usually the recipient is Tarantool, but it can be any URL."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:303
msgid "Default: 'https://feedback.tarantool.io'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:310
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:313
msgid "Default: 3600"
msgstr ""

#: ../doc/reference/configuration/index.rst:242
msgid "Deprecated parameters"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:8
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:9
msgid ":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:33
msgid "**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:41
msgid "**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:49
#: ../doc/reference/configuration/cfg_deprecated.rst:63
msgid "**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:52
msgid "If there is an error while reading a snapshot file (at server instance start), abort."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:74
msgid "**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:86
msgid "How much memory Tarantool allocates to actually store tuples, **in gigabytes**. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:103
msgid "The multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:116
msgid "**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:125
msgid "**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:134
msgid "**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:142
msgid "**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:151
msgid "**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/index.rst:5
msgid "Reference"
msgstr ""

#: ../doc/reference/interactive_console.rst:5
msgid "Interactive console"
msgstr ""

#: ../doc/reference/interactive_console.rst:7
msgid "The \"interactive console\" is Tarantool's basic \"command-line interface\" for entering requests and seeing results. It is what users see when they start the server without an :ref:`instance file <admin-instance_file>`, or start :ref:`tarantoolctl <tarantoolctl>` with ``enter``. It is often called the Lua console to distinguish it from the administrative console, but in fact it can handle both Lua and SQL input. The majority of examples in this manual show what users see with the interactive console, including the prompt (which can be \"tarantool> \"), the instruction (which can be a Lua request or an SQL statement), and the response (which can be a display in either YAML format or Lua format)."
msgstr ""

#: ../doc/reference/interactive_console.rst:18
msgid "-- Typical interactive console example with Lua input and YAML output\n"
"tarantool> box.info().replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: a5d22f66-2d28-4a35-b78f-5bf73baf6c8a\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/reference/interactive_console.rst:29
msgid "The **input language** can be changed to SQL with ``\\set language sql`` or changed to Lua (the default) with ``\\set language lua``."
msgstr ""

#: ../doc/reference/interactive_console.rst:32
msgid "The **delimiter** can be changed to any character with :samp:`\\set delimiter <character>`. The default is nothing, which means input does not need to end with a delimiter. But a common recommendation is to say ``set delimiter ;`` especially if input is SQL."
msgstr ""

#: ../doc/reference/interactive_console.rst:38
msgid "The **output format** can be changed to Lua with ``\\set output lua`` or changed to YAML (the default) with ``\\set output yaml``."
msgstr ""

#: ../doc/reference/interactive_console.rst:41
msgid "Ordinarily. output from the console has `YAML format <http://yaml.org/spec>`_. That means that there is a line for document-start ``\"---\"``, and each item begins on a separate line starting with ``\"- \"``, and each sub-item in a nested structure is indented, and there is a line for document-end ``\"...\"``."
msgstr ""

#: ../doc/reference/interactive_console.rst:47
msgid "Optionally, output from the console can have Lua format. That means that there are no lines for document-start or document-end, and items are not on separate lines (they are only separated by commas), and each sub-item in a nested structure is placed inside \"``{}``\" braces. So, when input is a Lua object description, output will equal input."
msgstr ""

#: ../doc/reference/interactive_console.rst:53
msgid "YAML is good for readability. Lua is good for re-using results as requests. A third format, MsgPack, is good for database storage. Currently the default output format is YAML but it may be Lua in a future version, and it may be Lua if the last :ref:`set_default_output <console-set_default_output>` call was ``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/interactive_console.rst:69
#: ../doc/reference/reference_sql/sql.rst:2124
msgid "Type"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "Lua input"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "Lua output"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "YAML output"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "MsgPack storage"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#: ../doc/reference/reference_sql/sql.rst:1306
msgid "scalar"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#: ../doc/reference/interactive_console.rst:71
msgid ":code:`1`"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
msgid ":code:`---` |br| :code:`- 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
msgid ":code:`\\x01`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid "scalar sequence"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
#: ../doc/reference/interactive_console.rst:75
msgid ":code:`1,2,3`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid ":code:`---` |br| :code:`- 1` |br| :code:`- 2` |br| :code:`- 3` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid ":code:`\\x01 \\x02 \\x03`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid "2-element table"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
#: ../doc/reference/interactive_console.rst:81
msgid ":code:`{1,2}`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`---` |br| :code:`- - 1` |br| :code:`- - 2` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`0x92 0x01 0x02`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid "map"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
#: ../doc/reference/interactive_console.rst:86
msgid ":code:`{key=1}`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`---` |br| :code:`- key: 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`\\x81 \\xa3 \\x6b \\x65 \\x79 \\x01`"
msgstr ""

#: ../doc/reference/lua_tips.rst:5
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/reference/lua_tips.rst:7
msgid "The Lua syntax for :ref:`data-manipulation functions <index-box_data-operations>` can vary. Here are examples of the variations with ``select()`` requests. The same rules exist for the other data-manipulation functions."
msgstr ""

#: ../doc/reference/lua_tips.rst:11
msgid "Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For these examples, we assume that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/reference/lua_tips.rst:20
msgid "Object reference variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:22
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:24
msgid "-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:34
msgid "Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form (#1). However, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:38
msgid "Also, descriptions in this manual use the syntax \"``space_object:``\" for references to objects which are spaces, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/reference/lua_tips.rst:47
msgid "Parameter variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:49
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:51
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/reference/lua_tips.rst:70
msgid "Lua allows to omit parentheses ``()`` when invoking a function if its only argument is a Lua table, and we use it sometimes in our examples. This is why ``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, as in examples #6 and #7."
msgstr ""

#: ../doc/reference/lua_tips.rst:76
msgid "Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the ``{1}`` form. However, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:85
msgid "Rules for object names"
msgstr ""

#: ../doc/reference/lua_tips.rst:87
msgid "Database objects have loose **rules for names**: the maximum length is 65000 bytes (not characters), and almost any legal Unicode character is allowed, including spaces, ideograms and punctuation."
msgstr ""

#: ../doc/reference/lua_tips.rst:92
msgid "In those cases, to prevent confusion with Lua operators and separators, object references should have the literal-in-square-brackets form (#2), or the variable form (#3). For example:"
msgstr ""

#: ../doc/reference/lua_tips.rst:96
msgid "tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:102
msgid "Disallowed:"
msgstr ""

#: ../doc/reference/lua_tips.rst:104
msgid "characters which are unassigned code points,"
msgstr ""

#: ../doc/reference/lua_tips.rst:105
msgid "line and paragraph separators,"
msgstr ""

#: ../doc/reference/lua_tips.rst:106
msgid "control characters,"
msgstr ""

#: ../doc/reference/lua_tips.rst:107
msgid "the replacement character (U+FFFD)."
msgstr ""

#: ../doc/reference/lua_tips.rst:109
msgid "Not recommended: characters which cannot be displayed."
msgstr ""

#: ../doc/reference/lua_tips.rst:111
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:5
msgid "Module `box`"
msgstr ""

#: ../doc/reference/reference_lua/box.rst:7
msgid "As well as executing Lua chunks or defining your own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:10
msgid "Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:15
msgid "To catch errors that functions in ``box`` submodules may throw, use :ref:`pcall <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:17
msgid "The contents of the ``box`` module can be inspected at runtime with ``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:3
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:9
#: ../doc/reference/reference_lua/clock.rst:9
#: ../doc/reference/reference_lua/console.rst:9
#: ../doc/reference/reference_lua/crypto.rst:11
#: ../doc/reference/reference_lua/csv.rst:9
#: ../doc/reference/reference_lua/debug_facilities.rst:9
#: ../doc/reference/reference_lua/digest.rst:11
#: ../doc/reference/reference_lua/errno.rst:11
#: ../doc/reference/reference_lua/fiber.rst:9
#: ../doc/reference/reference_lua/fio.rst:11
#: ../doc/reference/reference_lua/http.rst:11
#: ../doc/reference/reference_lua/iconv.rst:11
#: ../doc/reference/reference_lua/json.rst:9
#: ../doc/reference/reference_lua/log.rst:11
#: ../doc/reference/reference_lua/merger.rst:9
#: ../doc/reference/reference_lua/msgpack.rst:9
#: ../doc/reference/reference_lua/net_box.rst:9
#: ../doc/reference/reference_lua/osmodule.rst:11
#: ../doc/reference/reference_lua/socket.rst:9
#: ../doc/reference/reference_lua/string.rst:9
#: ../doc/reference/reference_lua/swim.rst:9
#: ../doc/reference/reference_lua/tap.rst:7
#: ../doc/reference/reference_lua/uri.rst:7
#: ../doc/reference/reference_lua/utf8.rst:9
#: ../doc/reference/reference_lua/uuid.rst:7
#: ../doc/reference/reference_lua/yaml.rst:9
msgid "Overview"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:11
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:19
#: ../doc/reference/reference_lua/clock.rst:18
#: ../doc/reference/reference_lua/console.rst:17
#: ../doc/reference/reference_lua/crypto.rst:22
#: ../doc/reference/reference_lua/csv.rst:41
#: ../doc/reference/reference_lua/debug_facilities.rst:33
#: ../doc/reference/reference_lua/digest.rst:22
#: ../doc/reference/reference_lua/errno.rst:19
#: ../doc/reference/reference_lua/fiber.rst:22
#: ../doc/reference/reference_lua/fio.rst:27
#: ../doc/reference/reference_lua/http.rst:19
#: ../doc/reference/reference_lua/iconv.rst:24
#: ../doc/reference/reference_lua/json.rst:18
#: ../doc/reference/reference_lua/log.rst:46
#: ../doc/reference/reference_lua/merger.rst:16
#: ../doc/reference/reference_lua/msgpack.rst:18
#: ../doc/reference/reference_lua/net_box.rst:71
#: ../doc/reference/reference_lua/osmodule.rst:28
#: ../doc/reference/reference_lua/pickle.rst:7
#: ../doc/reference/reference_lua/socket.rst:28
#: ../doc/reference/reference_lua/string.rst:22
#: ../doc/reference/reference_lua/tap.rst:17
#: ../doc/reference/reference_lua/uri.rst:35
#: ../doc/reference/reference_lua/uuid.rst:17
#: ../doc/reference/reference_lua/yaml.rst:16
msgid "Index"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:21
msgid "Below is a list of all ``box.error`` functions."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:29
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Name"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:29
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Use"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid ":ref:`box.error() <box_error-error>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid "Throw an error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid "Get a description of the last error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid "Clear the record of errors"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid "Create an error but do not throw"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:46
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_once.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Parameters"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:54
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:61
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:67
#: ../doc/reference/reference_lua/box_error.rst:157
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:68
#: ../doc/reference/reference_lua/box_error.rst:158
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:72
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:0
msgid "except"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:78
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:80
#: ../doc/reference/reference_lua/box_error.rst:120
#: ../doc/reference/reference_lua/box_error.rst:160
#: ../doc/reference/reference_lua/box_snapshot.rst:49
#: ../doc/reference/reference_lua/buffer.rst:23
#: ../doc/reference/reference_lua/clock.rst:78
#: ../doc/reference/reference_lua/clock.rst:103
#: ../doc/reference/reference_lua/clock.rst:124
#: ../doc/reference/reference_lua/clock.rst:145
#: ../doc/reference/reference_lua/clock.rst:167
#: ../doc/reference/reference_lua/console.rst:89
#: ../doc/reference/reference_lua/console.rst:120
#: ../doc/reference/reference_lua/console.rst:145
#: ../doc/reference/reference_lua/console.rst:184
#: ../doc/reference/reference_lua/crypto.rst:71
#: ../doc/reference/reference_lua/crypto.rst:103
#: ../doc/reference/reference_lua/crypto.rst:132
#: ../doc/reference/reference_lua/csv.rst:77
#: ../doc/reference/reference_lua/csv.rst:159
#: ../doc/reference/reference_lua/csv.rst:204
#: ../doc/reference/reference_lua/errno.rst:60
#: ../doc/reference/reference_lua/fiber.rst:203
#: ../doc/reference/reference_lua/fiber.rst:242
#: ../doc/reference/reference_lua/fiber.rst:265
#: ../doc/reference/reference_lua/fiber.rst:285
#: ../doc/reference/reference_lua/fiber.rst:305
#: ../doc/reference/reference_lua/fiber.rst:320
#: ../doc/reference/reference_lua/fiber.rst:339
#: ../doc/reference/reference_lua/fiber.rst:358
#: ../doc/reference/reference_lua/fiber.rst:470
#: ../doc/reference/reference_lua/fiber.rst:496
#: ../doc/reference/reference_lua/fiber.rst:520
#: ../doc/reference/reference_lua/fiber.rst:545
#: ../doc/reference/reference_lua/fiber.rst:572
#: ../doc/reference/reference_lua/fiber.rst:595
#: ../doc/reference/reference_lua/fiber.rst:621
#: ../doc/reference/reference_lua/fiber.rst:641
#: ../doc/reference/reference_lua/fiber.rst:709
#: ../doc/reference/reference_lua/fiber.rst:759
#: ../doc/reference/reference_lua/fiber.rst:792
#: ../doc/reference/reference_lua/fiber.rst:811
#: ../doc/reference/reference_lua/fio.rst:184
#: ../doc/reference/reference_lua/fio.rst:206
#: ../doc/reference/reference_lua/fio.rst:226
#: ../doc/reference/reference_lua/fio.rst:245
#: ../doc/reference/reference_lua/fio.rst:321
#: ../doc/reference/reference_lua/fio.rst:357
#: ../doc/reference/reference_lua/fio.rst:396
#: ../doc/reference/reference_lua/fio.rst:416
#: ../doc/reference/reference_lua/fio.rst:437
#: ../doc/reference/reference_lua/fio.rst:460
#: ../doc/reference/reference_lua/fio.rst:477
#: ../doc/reference/reference_lua/fio.rst:492
#: ../doc/reference/reference_lua/fio.rst:516
#: ../doc/reference/reference_lua/fio.rst:538
#: ../doc/reference/reference_lua/fio.rst:561
#: ../doc/reference/reference_lua/fio.rst:587
#: ../doc/reference/reference_lua/fio.rst:613
#: ../doc/reference/reference_lua/fio.rst:637
#: ../doc/reference/reference_lua/fio.rst:660
#: ../doc/reference/reference_lua/fio.rst:682
#: ../doc/reference/reference_lua/fio.rst:708
#: ../doc/reference/reference_lua/fio.rst:726
#: ../doc/reference/reference_lua/fio.rst:827
#: ../doc/reference/reference_lua/fio.rst:858
#: ../doc/reference/reference_lua/fio.rst:978
#: ../doc/reference/reference_lua/fio.rst:998
#: ../doc/reference/reference_lua/fio.rst:1023
#: ../doc/reference/reference_lua/fio.rst:1044
#: ../doc/reference/reference_lua/fio.rst:1077
#: ../doc/reference/reference_lua/fio.rst:1099
#: ../doc/reference/reference_lua/http.rst:83
#: ../doc/reference/reference_lua/iconv.rst:57
#: ../doc/reference/reference_lua/iconv.rst:78
#: ../doc/reference/reference_lua/json.rst:56
#: ../doc/reference/reference_lua/json.rst:95
#: ../doc/reference/reference_lua/json.rst:126
#: ../doc/reference/reference_lua/key_def.rst:141
#: ../doc/reference/reference_lua/key_def.rst:167
#: ../doc/reference/reference_lua/key_def.rst:190
#: ../doc/reference/reference_lua/key_def.rst:213
#: ../doc/reference/reference_lua/net_box.rst:232
#: ../doc/reference/reference_lua/net_box.rst:248
#: ../doc/reference/reference_lua/net_box.rst:263
#: ../doc/reference/reference_lua/net_box.rst:304
#: ../doc/reference/reference_lua/net_box.rst:318
#: ../doc/reference/reference_lua/net_box.rst:340
#: ../doc/reference/reference_lua/net_box.rst:354
#: ../doc/reference/reference_lua/net_box.rst:368
#: ../doc/reference/reference_lua/net_box.rst:382
#: ../doc/reference/reference_lua/net_box.rst:480
#: ../doc/reference/reference_lua/net_box.rst:532
#: ../doc/reference/reference_lua/osmodule.rst:88
#: ../doc/reference/reference_lua/osmodule.rst:111
#: ../doc/reference/reference_lua/osmodule.rst:130
#: ../doc/reference/reference_lua/osmodule.rst:147
#: ../doc/reference/reference_lua/osmodule.rst:165
#: ../doc/reference/reference_lua/osmodule.rst:180
#: ../doc/reference/reference_lua/osmodule.rst:193
#: ../doc/reference/reference_lua/osmodule.rst:208
#: ../doc/reference/reference_lua/osmodule.rst:223
#: ../doc/reference/reference_lua/osmodule.rst:238
#: ../doc/reference/reference_lua/osmodule.rst:253
#: ../doc/reference/reference_lua/osmodule.rst:269
#: ../doc/reference/reference_lua/osmodule.rst:284
#: ../doc/reference/reference_lua/other.rst:52
#: ../doc/reference/reference_lua/other.rst:92
#: ../doc/reference/reference_lua/pickle.rst:91
#: ../doc/reference/reference_lua/pickle.rst:138
#: ../doc/reference/reference_lua/socket.rst:138
#: ../doc/reference/reference_lua/socket.rst:156
#: ../doc/reference/reference_lua/socket.rst:175
#: ../doc/reference/reference_lua/socket.rst:257
#: ../doc/reference/reference_lua/socket.rst:416
#: ../doc/reference/reference_lua/strict.rst:18
#: ../doc/reference/reference_lua/string.rst:78
#: ../doc/reference/reference_lua/string.rst:103
#: ../doc/reference/reference_lua/string.rst:126
#: ../doc/reference/reference_lua/string.rst:151
#: ../doc/reference/reference_lua/string.rst:181
#: ../doc/reference/reference_lua/string.rst:211
#: ../doc/reference/reference_lua/string.rst:238
#: ../doc/reference/reference_lua/string.rst:264
#: ../doc/reference/reference_lua/string.rst:291
#: ../doc/reference/reference_lua/string.rst:318
#: ../doc/reference/reference_lua/swim.rst:396
#: ../doc/reference/reference_lua/table.rst:44
#: ../doc/reference/reference_lua/tap.rst:180
#: ../doc/reference/reference_lua/tap.rst:226
#: ../doc/reference/reference_lua/tarantool.rst:20
#: ../doc/reference/reference_lua/uri.rst:65
#: ../doc/reference/reference_lua/uri.rst:92
#: ../doc/reference/reference_lua/utf8.rst:74
#: ../doc/reference/reference_lua/utf8.rst:103
#: ../doc/reference/reference_lua/utf8.rst:132
#: ../doc/reference/reference_lua/utf8.rst:156
#: ../doc/reference/reference_lua/utf8.rst:178
#: ../doc/reference/reference_lua/utf8.rst:200
#: ../doc/reference/reference_lua/utf8.rst:222
#: ../doc/reference/reference_lua/utf8.rst:254
#: ../doc/reference/reference_lua/utf8.rst:278
#: ../doc/reference/reference_lua/utf8.rst:299
#: ../doc/reference/reference_lua/utf8.rst:337
#: ../doc/reference/reference_lua/utf8.rst:359
#: ../doc/reference/reference_lua/xlog.rst:27
#: ../doc/reference/reference_rock/dbms.rst:188
#: ../doc/reference/reference_rock/dbms.rst:212
#: ../doc/reference/reference_rock/dbms.rst:236
#: ../doc/reference/reference_rock/dbms.rst:530
#: ../doc/reference/reference_rock/dbms.rst:554
#: ../doc/reference/reference_rock/dbms.rst:577
#: ../doc/reference/reference_rock/vshard/index.rst:1056
#: ../doc/reference/reference_rock/vshard/index.rst:1127
#: ../doc/reference/reference_rock/vshard/index.rst:1425
#: ../doc/reference/reference_rock/vshard/index.rst:1440
#: ../doc/reference/reference_rock/vshard/index.rst:1457
#: ../doc/reference/reference_rock/vshard/index.rst:1518
msgid "**Example:**"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:82
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:101
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:111
msgid "rtype: table"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:117
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:122
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:152
msgid "Create an error object, but do not throw. This is useful when error information should be saved for later retrieval. The parameters are the same as for :ref:`box.error() <box_error-error>`, see the description there."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:162
msgid "tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = ''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:5
msgid "Function `box.once`"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:9
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:14
msgid "See an example of using ``box.once()`` while :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:17
msgid "If an error occurs inside ``box.once()`` when initializing a database, you can re-execute the failed ``box.once()`` block without stopping the database. The solution is to delete the ``once`` object from the system space :ref:`_schema <box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` object there and delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:24
msgid "When ``box.once()`` is used for initialization, it may be useful to wait until the database is in an appropriate state (read-only or read-write). In that case, see the functions in the :ref:`box.ctl submodule <box_ctl>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:28
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:48
msgid "a value that will be checked"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:49
msgid "a function"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:50
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:5
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:9
msgid "Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` will not remove files which were created before the snapshot started, it will not remove them until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:23
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Users may restrict the speed by changing :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:31
msgid "As long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore you need to have some extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:39
msgid "**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and this view is written to the snapshot file by a separate thread (the \"Write Ahead Log\" thread)."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:45
msgid "Although ``box.snapshot()`` does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:51
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:66
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicated data is up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:72
msgid "An alternative way to save a snapshot is to send a SIGUSR1 signal to the instance. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:7
msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:10
msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time on the server, if the client application has its own routine for decoding MsgPack strings."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "return"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/xlog.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "rtype"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:21
#: ../doc/reference/reference_lua/uuid.rst:61
#: ../doc/reference/reference_lua/uuid.rst:83
#: ../doc/reference/reference_lua/uuid.rst:91
msgid "cdata"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:25
msgid "Assume a Tarantool server is listening on farhost:3301. Assume it has a space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then we create a buffer, and use it as an option for a ``conn.space...select()`` call. The result will be in MsgPack_ format. To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:38
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:50
#: ../doc/reference/reference_lua/buffer.rst:110
msgid "The result of the final request looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:52
#: ../doc/reference/reference_lua/buffer.rst:73
msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:62
msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:69
msgid "**Module buffer and skip-header**"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:71
msgid "The example in the previous section"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:81
msgid "showed that, ordinarily, the response from net.box includes a header -- 48 (hexadecimal 30) is the :ref:`key <internals-unified_packet_structure>` for IPROTO_DATA. But in some situations, for example when passing the buffer to a C function that expects a MsgPack byte array without a header, the header can be skipped. This is done by specifying ``skip-header=true`` as an option to :ref:`conn.space.space-name:select{...} <conn-select>` or :ref:`conn.space.space-name:insert{...} <conn-insert>` or :ref:`conn.space.space-name:replace{...} <conn-replace>` or :ref:`conn.space.space-name:update{...} <conn-update>` or :ref:`conn.space.space-name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-name:delete{...} <conn-delete>`. The default is ``skip-header=false``."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:96
msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:98
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:112
msgid "tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:120
msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:122
msgid "The result is still inside an array, as is clear from the fact that it is shown inside square brackets. It is possible to skip the array header too, with :ref:`msgpack.decode_array_header() <msgpack-decode_array_header>`."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:5
msgid "Module `clock`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:11
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:20
msgid "Below is a list of all ``clock`` functions."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:30
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:31
msgid "Get the wall clock time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:35
msgid ":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:36
msgid "Get the wall clock time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid "Get the monotonic time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid "Get the monotonic time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid "Get the processor time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid "Get the processor time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid "Get the thread time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid "Get the thread time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid "Measure the time a function takes within a processor"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:71
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:75
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:76
#: ../doc/reference/reference_lua/clock.rst:101
#: ../doc/reference/reference_lua/clock.rst:122
#: ../doc/reference/reference_lua/clock.rst:143
msgid "number or number64"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:80
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:86
msgid "See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:94
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:100
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:105
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:116
msgid "The processor time. Derived from C function ``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:121
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:126
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:137
msgid "The thread time. Derived from C function ``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:142
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:147
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:157
msgid "The time that a function takes within a processor. This function uses ``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:161
msgid "function or function reference"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:162
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:164
msgid "**table**. first element - seconds of CPU time, second element - whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:169
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:5
msgid "Module `console`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:11
msgid "The console module allows one Tarantool instance to access another Tarantool instance, and allows one Tarantool instance to start listening on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:19
msgid "Below is a list of all ``console`` functions."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid ":ref:`console.connect() <console-connect>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid "Connect to an instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid ":ref:`console.listen() <console-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid "Listen for incoming requests"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid ":ref:`console.start() <console-start>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid "Start the console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid ":ref:`console.ac() <console-ac>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid "Set the auto-completion flag"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid "Set a delimiter"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:44
msgid ":ref:`console.get_default_output() <console-get_default_output>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:44
msgid "Get default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:47
msgid ":ref:`console.set_default_output() <console-set_default_output>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:47
msgid "Set default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:50
msgid ":ref:`console.eos() <console-eos>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:50
msgid "Set or get end-of-output string"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:61
msgid "Connect to the instance at :ref:`URI <index-uri>`, change the prompt from '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:65
msgid "The console.connect function allows one Tarantool instance, in interactive mode, to access another Tarantool instance. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote instance and the local instance is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote instance. Results are displayed on the local instance. To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:73
msgid "If the Tarantool instance at :samp:`uri` requires authentication, the connection might look something like: ``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:77
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote instance is done with user name = 'guest'. The remote instance could allow for this by granting at least one privilege: ``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:83
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:84
#: ../doc/reference/reference_lua/fiber.rst:570
#: ../doc/reference/reference_lua/fiber.rst:617
#: ../doc/reference/reference_lua/fiber.rst:707
#: ../doc/reference/reference_lua/fiber.rst:1137
#: ../doc/reference/reference_lua/fiber.rst:1145
#: ../doc/reference/reference_lua/log.rst:115
#: ../doc/reference/reference_lua/log.rst:140
#: ../doc/reference/reference_lua/msgpack.rst:281
#: ../doc/reference/reference_lua/tap.rst:130
#: ../doc/reference/reference_lua/tap.rst:164
#: ../doc/reference/reference_lua/tap.rst:224
msgid "nil"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:86
msgid "Possible errors: the connection will fail if the target Tarantool instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:91
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:105
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in ``box.cfg{listen=...}``. The alternative way of listening is via the URI specified in ``console.listen(...)``. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:112
msgid "the URI of the local instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:114
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:122
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:143
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:147
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the Tarantool instance with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:152
msgid "local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:161
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using Tarantool as a client or the user is using Tarantool via ``console.connect()``, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:170
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:172
msgid "The default end-of-request marker is a newline (line feed). Custom markers are not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an end keyword). Nonetheless for special needs, or for entering multi-line requests in older Tarantool versions, you can change the end-of-request marker. As a result, newline alone is not treated as end of request."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:180
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:182
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:186
msgid "tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:205
msgid "Return the current default output format. The result will be ``fmt=\"yaml\"``, or it will be ``fmt=\"lua\"`` if the last :ref:`set_default_output <console-set_default_output>` call was ``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:214
msgid "Set the default output format. The possible values are 'yaml' (the default default) or 'lua'. The output format can be changed within a session by executing :samp:`console.eval('\\\\\\\\set output {yaml}|{lua}')`; see the description of output format in the :ref:`Interactive console <interactive_console_output>` section."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:225
msgid "Set or access the end-of-output string if default output is 'lua'. This is the string that appears at the end of output in a response to any Lua request. The default value is ``;`` semicolon. Saying ``eos()`` will return the current value. For example, after ``require('console').eos('!!')`` responses will end with '!!'."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:5
msgid "Module `crypto`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:13
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``crypto`` module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:24
msgid "Below is a list of all ``crypto`` functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid "Encrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid "Decrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid "Get a digest"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid ":ref:`crypto.hmac.{algorithm}() <crypto-hmac>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid "Get a hash key"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:53
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:56
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:57
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:58
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:59
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:62
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:64
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:65
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:66
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:67
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:69
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:73
msgid "_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:88
msgid "Pass or return a digest derived from the string. The eleven algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:91
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:92
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:93
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:94
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:95
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:96
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:97
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:98
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:99
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:100
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:101
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:105
msgid "crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:118
msgid "Pass a key and a string. The result is an `HMAC <https://en.wikipedia.org/wiki/HMAC>`_ message authentication code. The eight algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:123
msgid "md4 or md4_hex - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:124
msgid "md5 or md5_hex - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:125
msgid "ripemd160 or ripemd160_hex - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:126
msgid "sha1 or sha1_hex - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:127
msgid "sha224 or sha224_hex - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:128
msgid "sha256 or sha256_hex - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:129
msgid "sha384 or sha384_hex - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:130
msgid "sha512 or sha512_hex - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:134
msgid "crypto.hmac.md4('key', 'string')\n"
"crypto.hmac.md4_hex('key', 'string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:141
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:143
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:149
msgid "crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:175
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:177
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:180
msgid "crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:3
msgid "Module `csv`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:11
msgid "The ``csv`` module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:14
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:16
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:18
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:19
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:20
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:21
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:22
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:28
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:30
msgid ":samp:`delimiter = {string}` (default: comma) -- single-byte character to designate end-of-field"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:32
msgid ":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to designate encloser of string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:34
msgid ":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:36
msgid ":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at the start (usually for a header)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:43
msgid "Below is a list of all ``csv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid ":ref:`csv.load() <csv-load>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid "Load a CSV file"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid "Transform input into a CSV-formatted string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid "Iterate over CSV records"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:67
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:71
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:73
#: ../doc/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:75
#: ../doc/reference/reference_lua/fiber.rst:356
#: ../doc/reference/reference_lua/fio.rst:435
#: ../doc/reference/reference_lua/fio.rst:456
#: ../doc/reference/reference_lua/fio.rst:1042
#: ../doc/reference/reference_lua/http.rst:193
#: ../doc/reference/reference_lua/json.rst:93
#: ../doc/reference/reference_lua/key_def.rst:211
#: ../doc/reference/reference_lua/pickle.rst:136
#: ../doc/reference/reference_lua/socket.rst:173
#: ../doc/reference/reference_lua/socket.rst:561
#: ../doc/reference/reference_lua/socket.rst:573
#: ../doc/reference/reference_lua/string.rst:289
#: ../doc/reference/reference_lua/table.rst:42
#: ../doc/reference/reference_lua/utf8.rst:294
#: ../doc/reference/reference_lua/yaml.rst:58
#: ../doc/reference/reference_rock/membership.rst:181
#: ../doc/reference/reference_rock/membership.rst:190
#: ../doc/reference/reference_rock/membership.rst:203
msgid "table"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:79
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:82
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:94
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:97
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:106
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:114
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:118
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:145
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:151
#: ../doc/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:163
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:177
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:193
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:206
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:211
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:5
msgid "Debug facilities"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:11
msgid "Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:13
msgid "Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see details below) and"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:15
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:19
msgid "The ``debug`` library provides an interface for debugging Lua programs. All functions in this library reside in the ``debug`` table. Those functions that operate on a thread have an optional first parameter that specifies the thread to operate on. The default is always the current thread."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:26
msgid "This library should be used only for debugging and profiling and not as a regular programming tool, as the functions provided here can take too long to run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:35
msgid "Below is a list of all ``debug`` functions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid "Enter an interactive mode"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid "Get an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid "Get a thread's current hook settings"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid "Get information about a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid "Get a local variable's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid "Get an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid "Get the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid "Get an upvalue's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid "Set an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid "Set a given function as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid "Assign a value to a local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid "Set an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid "Assign a value to an upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid ":ref:`debug.sourcedir() <debug-sourcedir>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid "Get the source directory name"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:87
msgid ":ref:`debug.sourcefile() <debug-sourcefile>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:87
msgid "Get the source file name"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid "Get a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:99
msgid "Enters an interactive mode and runs each string that the user types in. The user can, among other things, inspect global and local variables, change their values and evaluate expressions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:103
msgid "Enter ``cont`` to exit this function, so that the caller can continue its execution."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:108
msgid "Commands for ``debug.debug()`` are not lexically nested within any function and so have no direct access to local variables."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:115
msgid "object to get the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:118
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:124
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:126
msgid "the current hook function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:127
msgid "the current hook mask"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:128
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:134
msgid "function to get information on"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:136
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:138
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:140
msgid "You can pass in a ``function`` directly, or you can give a number that specifies a function running at level ``function`` of the call stack of the given ``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is the function that called ``getinfo()``, and so on. If ``function`` is a number larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:147
msgid "The default for ``what`` is to get all information available, except the table of valid lines. If present, the option ``f`` adds a field named ``func`` with the function itself. If present, the option ``L`` adds a field named ``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:156
#: ../doc/reference/reference_lua/debug_facilities.rst:233
msgid "level of the stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:157
#: ../doc/reference/reference_lua/debug_facilities.rst:234
msgid "index of the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:159
msgid "the name and the value of the local variable with the index ``local`` of the function at level ``level`` of the stack or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:166
#: ../doc/reference/reference_lua/debug_facilities.rst:244
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:172
msgid "object to get the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:175
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:182
msgid "the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:188
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:189
#: ../doc/reference/reference_lua/debug_facilities.rst:264
msgid "index of the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:191
msgid "the name and the value of the upvalue with the index ``up`` of the function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:199
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:201
msgid "object to change the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:203
msgid "table to set the object environment to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:205
msgid "the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:211
msgid "Sets the given function as a hook.  When called without arguments, turns the hook off."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:214
msgid "function to set as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; may have the following values:  * ``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the ``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:218
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:219
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:220
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:222
msgid "describes when the ``hook`` will be called; when different from zero, the ``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:230
msgid "Assigns the value ``value`` to the local variable with the index ``local`` of the function at level ``level`` of the stack."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:235
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:238
msgid "the name of the local variable or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:250
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:252
msgid "object to change the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:254
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:260
msgid "Assigns the value ``value`` to the upvalue with the index ``up`` of the function ``func``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:263
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:265
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:268
msgid "the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:275
#: ../doc/reference/reference_lua/debug_facilities.rst:294
msgid "the level of the call stack which should contain the path (default is 2)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:278
msgid "a string with the relative path to the source file directory"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:280
msgid "Instead of ``debug.sourcedir()`` one can say ``debug.__dir__`` which means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:282
msgid "Determining the real path to a directory is only possible if the function was defined in a Lua file (this restriction may not apply for `loadstring() <https://www.lua.org/pil/8.html>`_ since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:287
msgid "If ``debug.sourcedir()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcedir())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:297
msgid "a string with the relative path to the source file"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:299
msgid "Instead of ``debug.sourcefile()`` one can say ``debug.__file__`` which means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:301
msgid "Determining the real path to a file is only possible if the function was defined in a Lua file (this restriction may not apply to ``loadstring()`` since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:306
msgid "If ``debug.sourcefile()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcefile())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:313
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:314
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:317
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:319
msgid "**Debug example:**"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:321
msgid "Make a file in the /tmp directory named example.lua, containing:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:323
msgid "function w()\n"
"  print(debug.sourcedir())\n"
"  print(debug.sourcefile())\n"
"  print(debug.traceback())\n"
"  print(debug.getinfo(1)['currentline'])\n"
"end\n"
"w()"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:333
msgid "Execute ``tarantool /tmp/example.lua``. Expect to see this:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:335
msgid "/tmp\n"
"/tmp/example.lua\n"
"stack traceback:\n"
"    /tmp/example.lua:4: in function 'w'\n"
"    /tmp/example.lua:7: in main chunk\n"
"5"
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:5
msgid "Module `decimal`"
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:9
msgid "The ``decimal`` module has functions for working with exact numbers. This is important when numbers are large or even the slighest inaccuracy is unacceptable. For example Lua calculates ``0.16666666666667 * 6`` with floating-point so the result is 1. But with the decimal module (using ``decimal.new`` to convert the number to decimal type) ``decimal.new('0.16666666666667') * 6`` is 1.00000000000002."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:18
msgid "To construct a decimal number, bring in the module with ``require('decimal')`` and then use ``decimal.new(n)`` or any function in the decimal module: :ref:`abs(n) <decimal-abs>` :ref:`exp(n) <decimal-exp>` :ref:`ln(n) <decimal-ln>` :ref:`log10(n) <decimal-log10>` :ref:`new(n) <decimal-new>` :ref:`precision(n) <decimal-precision>` :ref:`rescale(decimal-number, new-scale) <decimal-rescale>` :ref:`scale(n) <decimal-scale>` :ref:`sqrt(n) <decimal-sqrt>` :ref:`trim(decimal-number) <decimal-trim>`, where n can be a string or a non-decimal number or a decimal number. If it is a string or a non-decimal number, Tarantool converts it to a decimal number before working with it. It is best to construct from strings, and to convert back to strings after calculations, because Lua numbers have only 15 digits of precision. Decimal numbers have 38 digits of precision, that is, the total number of digits before and after the decimal point can be 38. Tarantool supports the usual arithmetic and comparison operators + - * / % ^ < > <= >= ~= ==. If an operation has both decimal and non-decimal operands, then the non-decimal operand is converted to decimal before the operation happens."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:46
msgid "Use ``tostring(decimal-number)`` to convert back to a string."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:48
msgid "A decimal operation will fail if overflow happens (when a number is greater than 10^38 - 1 or less than -10^38 - 1). A decimal operation will fail if arithmetic is impossible (such as division by zero or square root of minus 1). A decimal operation will not fail if rounding of post-decimal digits is necessary to get 38-digit precision."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:59
msgid "Returns absolute value of a decimal number. For example if a is -1 then ``decimal.abs(a)`` returns 1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:66
msgid "Returns *e* raised to the power of a decimal number. For example if a is 1 then ``decimal.exp(a)`` returns 2.7182818284590452353602874713526624978. Compare ``math.exp(1)`` from the `Lua math library <https://www.lua.org/pil/18.html>`_, which returns 2.718281828459."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:77
msgid "Returns natural logarithm of a decimal number. For example if a is 1 then ``decimal.ln(a)`` returns 0."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:84
msgid "Returns base-10 logarithm of a decimal number. For example if a is 100 then ``decimal.log10(a)`` returns 2."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:91
msgid "Returns the value of the input as a decimal number. For example if a is 1E-1 then ``decimal.new(a)`` returns 0.1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:99
msgid "Returns the number of digits in a decimal number. For example if a is 123.4560 then ``decimal.precision(a)`` returns 7."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:106
msgid "Returns the number after possible rounding or padding. If the number of post-decimal digits is greater than new-scale, then rounding occurs. The rounding rule is: round half away from zero. If the number of post-decimal digits is less than new-scale, then padding of zeros occurs. For example if a is -123.4550 then ``decimal.rescale(a, 2)`` returns -123.46, and ``decimal.rescale(a, 5)`` returns -123.45500."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:118
msgid "Returns the number of post-decimal digits in a decimal number. For example if a is 123.4560 then ``decimal.scale(a)`` returns 4."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:125
msgid "Returns the square root of a decimal number. For example if a is 2 then ``decimal.sqrt(a)`` returns 1.4142135623730950488016887242096980786."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:133
msgid "Returns a decimal number after possible removing of trailing post-decimal zeros. For example if a is 2.20200 then ``decimal.trim(a)`` returns 2.202."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:5
msgid "Module `digest`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:13
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``digest`` module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>`."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:24
msgid "Below is a list of all ``digest`` functions."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid "Encrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid "Decrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid "Get a digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid "Get a hexadecimal digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid "Get a digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid "Get a hexadecimal digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid "Get a digest made with PBKDF2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid "Get a digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid "Get a hexadecimal digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid "Get a 224-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid "Get a 256-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid "Get a 384-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid "Get a 512-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid "Encode a string to Base64"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid "Decode a Base64-encoded string"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid "Get an array of random bytes"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid "Get a 32-bit checksum made with CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid "Initiate incremental CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid "Get a number made with a consistent hash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid "Get a digest made with MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid "Initiate incremental MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:115
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:121
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:127
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:133
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:139
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:145
msgid "Returns binary string = digest made with PBKDF2. |br| For effective encryption the ``iterations`` value should be at least several thousand. The ``digest-length`` value determines the length of the resulting binary string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:154
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:160
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:166
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:172
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:178
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:184
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:190
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:196
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:202
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:208
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:214
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:216
msgid "The possible options are:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:218
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:219
msgid "``nowrap`` -- result must not include line feed for splitting lines after 72 characters,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:221
msgid "``urlsafe`` -- result must not include '=' or line feed, and may contain '-' or '_' instead of '+' or '/' for positions 62 and 63 in the index table."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:225
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:229
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:237
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:243
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:249
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:251
msgid "The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other settings are: input = reflected, output = reflected, initial value = 0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:258
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:260
msgid ">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:267
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:269
msgid "use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:276
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:282
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:289
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:291
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:296
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:307
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:313
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes. For example:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:317
msgid "murmur.new({seed=0})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:325
msgid "Incremental methods in the ``digest`` module"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:327
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:333
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:355
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:359
msgid "tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:385
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:388
msgid "tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:5
msgid "Database error codes"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:7
msgid "In the current version of the binary protocol, error messages, which are normally more descriptive than error codes, are not present in server responses. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below are general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:18
msgid "**List of error codes**"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been reached."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "The specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:68
msgid "Handling errors"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:70
msgid "Here are some procedures that can make Lua functions more robust when there are errors, particularly database errors."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:73
msgid "Invoke with pcall."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of simply invoking with"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "say"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-name}) ...`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "For some Tarantool box functions, pcall also returns error details including a file-name and line-number within Tarantool's source code. This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``y:unpack()``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:88
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:91
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:93
msgid "To make a new error and pass it on, the box.error module provides :ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:96
msgid "To find the last error, the box.error module provides :ref:`box.error.last() <box_error-last>`. (There is also a way to find the text of the last operating-system error for certain functions -- :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:101
msgid "Log."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:103
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:105
msgid "And filter messages that are automatically generated, with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:109
msgid "Generally, for Tarantool built-in functions which are designed to return objects: the result will be an object, or nil, or `a Lua error <https://www.lua.org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:113
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:127
msgid "After a function call that might fail, like fio.open() above, it is common to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check for common failures. But if there had been a syntax error, for example fio.opex instead of fio.open, then there would have been a Lua error and f would not have been changed. If checking for such an obvious error had been a concern, the programmer would probably have used pcall()."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:137
msgid "All functions in Tarantool modules should work this way, unless the manual explicitly says otherwise."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:5
msgid "Module `errno`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:13
msgid "The ``errno`` module is typically used within a function or within a Lua program, in association with a module whose functions can return operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:21
msgid "Below is a list of all ``errno`` functions."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid ":ref:`errno() <errno-errno>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid "Get an error number for the last OS-related function"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid "Get an error message for the corresponding error number"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:42
msgid "Return an error number for the last operating-system-related function, or 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:45
#: ../doc/reference/reference_sql/sql.rst:1295
msgid "integer"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:51
msgid "Return a string, given an error number. The string will contain the text of the conventional error message for the current operating system. If ``code`` is not supplied, the error message will be for the last operating-system-related function, or 0."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:56
msgid "number of an operating-system error"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:58
#: ../doc/reference/reference_lua/fiber.rst:337
#: ../doc/reference/reference_lua/fiber.rst:541
#: ../doc/reference/reference_lua/fiber.rst:591
#: ../doc/reference/reference_lua/fio.rst:182
#: ../doc/reference/reference_lua/fio.rst:204
#: ../doc/reference/reference_lua/fio.rst:224
#: ../doc/reference/reference_lua/fio.rst:243
#: ../doc/reference/reference_lua/json.rst:54
#: ../doc/reference/reference_lua/msgpack.rst:62
#: ../doc/reference/reference_lua/pickle.rst:83
#: ../doc/reference/reference_lua/socket.rst:294
#: ../doc/reference/reference_lua/socket.rst:328
#: ../doc/reference/reference_lua/socket.rst:344
#: ../doc/reference/reference_lua/string.rst:76
#: ../doc/reference/reference_lua/string.rst:101
#: ../doc/reference/reference_lua/string.rst:124
#: ../doc/reference/reference_lua/string.rst:149
#: ../doc/reference/reference_lua/string.rst:236
#: ../doc/reference/reference_lua/string.rst:262
#: ../doc/reference/reference_lua/string.rst:316
#: ../doc/reference/reference_lua/uri.rst:90
#: ../doc/reference/reference_lua/utf8.rst:90
#: ../doc/reference/reference_lua/utf8.rst:276
#: ../doc/reference/reference_lua/utf8.rst:328
#: ../doc/reference/reference_lua/utf8.rst:352
#: ../doc/reference/reference_lua/yaml.rst:48
#: ../doc/reference/reference_rock/membership.rst:314
#: ../doc/reference/reference_sql/sql.rst:1301
msgid "string"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:62
msgid "This function displays the result of a call to :ref:`fio.open() <fio-open>` which causes error 2 (``errno.ENOENT``). The display includes the error number, the associated error string, and the error name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:66
msgid "tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:91
msgid "To see all possible error names stored in the ``errno`` metatable, say ``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:94
msgid "tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:14
msgid "send and receive messages between different processes (i.e. different connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:16
msgid "use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar to \"condition variables\" and similar to operating-system functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid "Create but do not start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid "Create a communication channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid "Close a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid "Count messages in a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid "Check if a channel is full"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid "Send a message via a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid "Create a condition variable"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:76
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:76
msgid "Wake up all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid "Get information about all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
#: ../doc/reference/reference_lua/fiber.rst:94
msgid "Cancel a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid "Wait for a fiber's state to become 'dead'"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid "Get a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid "Set a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid "Make it possible for a new fiber to join"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid "Get a fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid ":ref:`fiber.top() <fiber-top>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid "Return a table of alive fibers and show their CPU consumption"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:136
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:136
msgid "Yield control"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:144
#: ../doc/reference/reference_rock/vshard/index.rst:935
msgid "Fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:146
msgid "A **fiber** is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:150
msgid "A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber is created with :ref:`fiber.new() <fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:156
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:160
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:171
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:178
msgid "Like all Lua objects, dead fibers are garbage collected. The Lua garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:183
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:195
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:197
#: ../doc/reference/reference_lua/fiber.rst:236
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:198
#: ../doc/reference/reference_lua/fiber.rst:237
msgid "what will be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Return"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:200
#: ../doc/reference/reference_lua/fiber.rst:239
msgid "created fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Rtype"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:201
#: ../doc/reference/reference_lua/fiber.rst:240
#: ../doc/reference/reference_lua/fiber.rst:263
#: ../doc/reference/reference_lua/fiber.rst:283
#: ../doc/reference/reference_lua/fio.rst:786
#: ../doc/reference/reference_lua/http.rst:81
#: ../doc/reference/reference_lua/iconv.rst:53
#: ../doc/reference/reference_lua/net_box.rst:210
#: ../doc/reference/reference_lua/socket.rst:136
#: ../doc/reference/reference_lua/socket.rst:154
#: ../doc/reference/reference_lua/socket.rst:385
#: ../doc/reference/reference_lua/tap.rst:99
msgid "userdata"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:205
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:223
msgid "Create but do not start a fiber: the fiber is created but does not begin to run immediately -- it starts after the fiber creator (that is, the job that is calling ``fiber.new()``) yields, under :ref:`transaction control <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:231
msgid "Ordinarily ``fiber.new()`` is used in conjunction with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:244
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:262
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:267
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:280
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:282
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:287
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:300
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:303
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:307
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:317
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does not."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:322
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:332
msgid "Return the status of the current fiber. Or, if optional fiber_object is passed, return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:336
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:341
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:352
msgid "Return information about all fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:354
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:360
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:378
msgid "Show all alive fibers and their CPU consumption."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:380
msgid "a table with two entries: ``cpu`` and ``cpu_misses``"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:382
msgid "``cpu`` itself is a table whose keys are strings containing fiber ids and names. The three metrics available for each fiber are:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:385
msgid "``instant`` (in per cent), which indicates the share of time the fiber was executing during the previous event loop iteration."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:388
msgid "``average`` (in per cent), which is calculated as an exponential moving average of instant values over all the previous event loop iterations."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:391
msgid "``time`` (in seconds), which estimates how much CPU time each fiber spent processing during its lifetime."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:394
msgid "The ``time`` entry is also added to each fiber's output in ``fiber.info()`` (it duplicates the ``time`` entry from ``fiber.top().cpu`` per fiber)."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:397
msgid "Note that ``time`` is only counted while ``fiber.top()`` is enabled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:399
msgid "``cpu_misses`` indicates the number of times the TX thread detected it was rescheduled on a different CPU core during the last event loop iteration. ``fiber.top()`` uses the CPU timestamp counter to measure each fiber's execution time. However, each CPU core may have its own counter value (you can only rely on counter deltas if both measurements were taken on the same core, otherwise the delta may even get negative). When the TX thread is rescheduled to a different CPU core, Tarantool just assumes the CPU delta was zero for the latest measurement. This lowers the precision of our computations, so the bigger ``cpu misses`` value the lower the precision of ``fiber.top()`` results."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:409
msgid "Let's take a look at the example:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:411
msgid "**Example**"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:413
msgid "tarantool> fiber.top()\n"
"---\n"
"- cpu:\n"
"    107/lua:\n"
"      instant: 30.967324490456\n"
"      time: 0.351821993\n"
"      average: 25.582738345233\n"
"    104/lua:\n"
"      instant: 9.6473633128437\n"
"      time: 0.110869897\n"
"      average: 7.9693406131877\n"
"    101/on_shutdown:\n"
"      instant: 0\n"
"      time: 0\n"
"      average: 0\n"
"    103/lua:\n"
"      instant: 9.8026528631511\n"
"      time: 0.112641118\n"
"      average: 18.138387232255\n"
"    106/lua:\n"
"      instant: 20.071174377224\n"
"      time: 0.226901357\n"
"      average: 17.077908441831\n"
"    102/interactive:\n"
"      instant: 0\n"
"      time: 9.6858e-05\n"
"      average: 0\n"
"    105/lua:\n"
"      instant: 9.2461986412164\n"
"      time: 0.10657528\n"
"      average: 7.7068458630827\n"
"    1/sched:\n"
"      instant: 20.265286315108\n"
"      time: 0.237095335\n"
"      average: 23.141537169257\n"
"  cpu_misses: 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:455
msgid "Enabling ``fiber.top()`` slows down fiber switching by about 15%, so it is disabled by default. To enable it, say ``fiber.top_enable()``. To disable it after you finished debugging, with ``fiber.top_disable()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:463
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:467
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
msgid "Exception"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:468
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:472
msgid "tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:484
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:489
msgid "Even if you catch the exception, the fiber will remain cancelled. Most types of calls will check ``fiber.testcancel()``. However, some functions (``id``, ``status``, ``join`` etc.) will return no error. We recommend application developers to implement occasional checks with :ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:498
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:511
#: ../doc/reference/reference_lua/fiber.rst:536
#: ../doc/reference/reference_lua/fiber.rst:564
#: ../doc/reference/reference_lua/fiber.rst:586
#: ../doc/reference/reference_lua/fiber.rst:613
msgid "generally this is an object referenced in the return from :ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or :ref:`fiber.find <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:515
msgid "id of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:516
#: ../doc/reference/reference_lua/fiber.rst:977
#: ../doc/reference/reference_lua/fio.rst:319
#: ../doc/reference/reference_lua/fio.rst:1019
#: ../doc/reference/reference_lua/socket.rst:274
#: ../doc/reference/reference_lua/socket.rst:400
#: ../doc/reference/reference_lua/utf8.rst:57
#: ../doc/reference/reference_lua/utf8.rst:118
#: ../doc/reference/reference_lua/utf8.rst:241
#: ../doc/reference/reference_rock/vshard/index.rst:1455
#: ../doc/reference/reference_rock/vshard/index.rst:1470
#: ../doc/reference/reference_sql/sql.rst:1299
msgid "number"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:518
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:522
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:540
msgid "name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:543
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:547
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:558
msgid "Change the fiber name. By default a Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:568
msgid "the new name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:574
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:584
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:590
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:593
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:597
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:608
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:619
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:623
msgid "tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:634
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The Lua garbage collector will mark or free the local storage when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:643
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:669
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:675
msgid "``fiber_object:set_joinable(true)`` makes a fiber joinable; ``fiber_object:set_joinable(false)`` makes a fiber not joinable; the default is false."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:679
msgid "A joinable fiber can be waited for, with :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:682
msgid "Best practice is to call ``fiber_object:set_joinable()`` before the fiber function begins to execute, because otherwise the fiber could become 'dead' before ``fiber_object:set_joinable()`` takes effect. The usual sequence could be:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:687
msgid "Call ``fiber.new()`` instead of ``fiber.create()`` to create a new fiber_object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:690
msgid "Do not yield at this point, because that will cause the fiber function to begin."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:693
msgid "Call ``fiber_object:set_joinable(true)`` to make the new fiber_object joinable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:696
msgid "Now it is safe to yield."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:698
msgid "Call ``fiber_object:join()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:700
msgid "Usually ``fiber_object:join()`` should be called, otherwise the fiber's status may become 'suspended' when the fiber function ends, instead of 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:704
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:711
#: ../doc/reference/reference_lua/fiber.rst:761
msgid "The result of the following sequence of requests is:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:713
msgid "the global variable ``d`` will be 6 (which proves that the function was not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` caused a yield);"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:716
msgid "``fiber.status(fi2)`` will be 'suspended' (which proves that after the function was executed the fiber status did not change to 'dead')."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:719
msgid "fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:732
msgid "\"Join\" a joinable fiber. That is, let the fiber's function run and wait until the fiber's status is 'dead' (normally a status becomes 'dead' when the function execution finishes). Joining will cause a yield, therefore, if the fiber is currently in a suspended state, execution of its fiber function will resume."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:740
msgid "This kind of waiting is more convenient than going into a loop and periodically checking the status; however, it works only if the fiber was created with :ref:`fiber.new() <fiber-new>` and was made joinable with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:747
msgid "two values. The first value is boolean. If the first value is true, then the join succeeded because the fiber's function ended normally and the second result has the return value from the fiber's function. If the first value is false, then the join succeeded because the fiber's function ended abnormally and the second result has the details about the error, which one can unpack in the same way that one unpacks :ref:`a pcall result <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:757
msgid "boolean +result type, or boolean + struct error"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:763
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:764
msgid "the ``join()`` call returns true,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:765
msgid "the elapsed time is usually 5 seconds, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:766
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:768
msgid "This proves that the ``join()`` does not return until the function -- which sleeps 5 seconds -- is 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:771
msgid "fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:786
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:790
#: ../doc/reference/reference_lua/fiber.rst:809
msgid "num"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:794
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:806
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:813
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:825
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop. Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:830
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:843
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:846
msgid "tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:854
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:856
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:862
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:867
msgid "tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:874
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:879
msgid "tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:895
msgid "Channels"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:897
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:900
msgid "Call the other routines, via channel, to send messages, receive messages, or check channel status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:903
msgid "Message exchange is synchronous. The Lua garbage collector will mark or free the channel when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:912
msgid "Create a new communication channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:914
msgid "the maximum number of slots (spaces for ``channel:put`` messages) that can be in use at once. The default is 0."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:918
msgid "new channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:919
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:927
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` waits until there is a free slot in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:930
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:931
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:932
msgid "If timeout is specified, and there is no free slot in the channel for the duration of the timeout, then the return value is ``false``. If the channel is closed, then the return value is ``false``. Otherwise, the return value is ``true``, indicating success."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:936
#: ../doc/reference/reference_lua/fiber.rst:968
#: ../doc/reference/reference_lua/fiber.rst:988
#: ../doc/reference/reference_lua/fiber.rst:998
#: ../doc/reference/reference_lua/fiber.rst:1008
#: ../doc/reference/reference_lua/fiber.rst:1016
#: ../doc/reference/reference_lua/fiber.rst:1128
#: ../doc/reference/reference_lua/fio.rst:270
#: ../doc/reference/reference_lua/fio.rst:278
#: ../doc/reference/reference_lua/fio.rst:286
#: ../doc/reference/reference_lua/fio.rst:294
#: ../doc/reference/reference_lua/fio.rst:302
#: ../doc/reference/reference_lua/fio.rst:394
#: ../doc/reference/reference_lua/fio.rst:414
#: ../doc/reference/reference_lua/fio.rst:514
#: ../doc/reference/reference_lua/fio.rst:536
#: ../doc/reference/reference_lua/fio.rst:559
#: ../doc/reference/reference_lua/fio.rst:611
#: ../doc/reference/reference_lua/fio.rst:635
#: ../doc/reference/reference_lua/fio.rst:658
#: ../doc/reference/reference_lua/fio.rst:706
#: ../doc/reference/reference_lua/fio.rst:724
#: ../doc/reference/reference_lua/fio.rst:825
#: ../doc/reference/reference_lua/fio.rst:884
#: ../doc/reference/reference_lua/fio.rst:969
#: ../doc/reference/reference_lua/fio.rst:996
#: ../doc/reference/reference_lua/net_box.rst:230
#: ../doc/reference/reference_lua/net_box.rst:246
#: ../doc/reference/reference_lua/net_box.rst:261
#: ../doc/reference/reference_lua/net_box.rst:278
#: ../doc/reference/reference_lua/socket.rst:255
#: ../doc/reference/reference_lua/socket.rst:361
#: ../doc/reference/reference_lua/socket.rst:437
#: ../doc/reference/reference_lua/socket.rst:449
#: ../doc/reference/reference_lua/string.rst:176
#: ../doc/reference/reference_lua/string.rst:206
#: ../doc/reference/reference_lua/tap.rst:155
#: ../doc/reference/reference_lua/tap.rst:178
#: ../doc/reference/reference_lua/tap.rst:212
#: ../doc/reference/reference_lua/tap.rst:247
#: ../doc/reference/reference_lua/tap.rst:260
#: ../doc/reference/reference_lua/tap.rst:270
#: ../doc/reference/reference_lua/tap.rst:285
#: ../doc/reference/reference_lua/tap.rst:306
#: ../doc/reference/reference_lua/tap.rst:325
#: ../doc/reference/reference_lua/utf8.rst:149
#: ../doc/reference/reference_lua/utf8.rst:174
#: ../doc/reference/reference_lua/utf8.rst:196
#: ../doc/reference/reference_lua/utf8.rst:218
#: ../doc/reference/reference_rock/membership.rst:172
#: ../doc/reference/reference_rock/membership.rst:232
#: ../doc/reference/reference_rock/membership.rst:244
#: ../doc/reference/reference_rock/membership.rst:255
#: ../doc/reference/reference_rock/membership.rst:268
#: ../doc/reference/reference_rock/membership.rst:278
#: ../doc/reference/reference_rock/membership.rst:285
#: ../doc/reference/reference_sql/sql.rst:1293
msgid "boolean"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:942
msgid "Close the channel. All waiters in the channel will stop waiting. All following ``channel:get()`` operations will return ``nil``, and all following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:950
msgid "Fetch and remove a message from a channel. If the channel is empty, ``channel:get()`` waits for a message."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:953
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:954
msgid "If timeout is specified, and there is no message in the channel for the duration of the timeout, then the return value is ``nil``. If the channel is closed, then the return value is ``nil``. Otherwise, the return value is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:959
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:965
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:967
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:974
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:976
msgid "the number of messages."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:983
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:985
msgid "``true`` if the channel is full (the number of messages in the channel equals the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:994
msgid "Check whether readers are waiting for a message because they have issued ``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:997
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1004
msgid "Check whether writers are waiting because they have issued ``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1007
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1014
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1022
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1026
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1092
msgid "Condition variables"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1094
msgid "Call ``fiber.cond()`` to create a named condition variable, which will be called 'cond' for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1097
msgid "Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1099
msgid "Call ``cond:signal()`` to send a signal to wake up a single fiber that has executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1102
msgid "Call ``cond:broadcast()`` to send a signal to all fibers that have executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1109
msgid "Create a new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1111
msgid "new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1112
msgid "Lua object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1120
msgid "Make the current fiber go to sleep, waiting until another fiber invokes the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1124
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1125
msgid "If timeout is provided, and a signal doesn't happen for the duration of the timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1134
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1143
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1151
msgid "Assume that a tarantool instance is running and listening for connections on localhost port 3301. Assume that guest users have privileges to connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1155
msgid "On terminal #1, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1157
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1164
msgid "The job will hang because ``cond:wait()`` -- without an optional timeout argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1167
msgid "On terminal #2, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1169
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1174
msgid "Now look again at terminal #1. It will show that the waiting stopped, and the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1177
msgid "This example depended on the use of a global conditional variable with the arbitrary name ``cond``. In real life, programmers would make sure to use different conditional variable names for different applications."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:5
msgid "Module `fio`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:13
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:17
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:19
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:20
msgid "functions for :ref:`directory or file existence and type checks<fio-checks>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:21
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:22
msgid ":ref:`constants <fio-c>` which are the same as POSIX flag values (for example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:29
msgid "Below is a list of all ``fio`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid "Form a path name from one or more partial strings"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid "Get a file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid "Get a directory name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid "Get a directory and file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
#: ../doc/reference/reference_lua/fio.rst:65
msgid "Check if file or directory exists"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid "Check if file or directory is a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid "Check if file or directory is a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid "Check if file or directory is a link"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:65
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid "Set mask bits"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:71
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:72
msgid "Get information about a file object"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:76
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:77
msgid "Create or delete a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid "Change working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid "List files in a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid "Get files whose names match a given string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid "Get the name of a directory for storing temporary files"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid "Get the name of the current working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:96
msgid ":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:99
msgid "Create and delete directories"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:103
msgid ":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| :ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:106
msgid "Create and delete links"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
#: ../doc/reference/reference_lua/osmodule.rst:43
msgid "Rename a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid ":ref:`fio.utime() <fio-utime>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid "Change file update time"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid "Copy a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:122
msgid "Manage rights to and ownership of file objects"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid "Reduce the file size"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid "Ensure that changes are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid ":ref:`fio.open() <fio-open>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid "Open a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:135
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:135
msgid "Close a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:138
msgid ":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-handle:pwrite() <file_handle-pwrite>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:139
msgid "Perform random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:143
msgid ":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-handle:write() <file_handle-write>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:144
msgid "Perform non-random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid "Change the size of an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid "Change position in a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:154
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:154
msgid "Get statistics about an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:157
msgid ":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-handle:fdatasync() <file_handle-fsync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:158
msgid "Ensure that changes made to an open file are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:162
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:162
msgid "Table of constants similar to POSIX flag values"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:172
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:178
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:180
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:181
#: ../doc/reference/reference_lua/fio.rst:200
#: ../doc/reference/reference_lua/fio.rst:221
msgid "path name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:186
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:197
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:201
msgid "suffix"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:203
#: ../doc/reference/reference_lua/fio.rst:240
msgid "file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:208
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:219
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:223
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:228
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:238
msgid "Given a final part (the file name), return the full path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:242
msgid "directory name, that is, path name including file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:247
msgid "tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:258
msgid "Directory or file existence and type checks"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:260
msgid "Functions in this section are similar to some `Python os.path <https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:268
#: ../doc/reference/reference_lua/fio.rst:276
#: ../doc/reference/reference_lua/fio.rst:284
#: ../doc/reference/reference_lua/fio.rst:292
#: ../doc/reference/reference_lua/fio.rst:300
msgid "path to directory or file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:269
msgid "true if path-name refers to a directory or file that exists and is not a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:277
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:285
msgid "true if path-name refers to a file; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:293
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:301
msgid "true if path-name refers to a directory or file that exists or is a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:308
msgid "Common file manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:314
msgid "Set the mask bits used when creating files or directories. For a detailed description type ``man 2 umask``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:317
msgid "mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:318
msgid "previous mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:323
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:335
msgid "Returns information about a file object. For details type ``man 2 lstat`` or ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:338
msgid "path name of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:339
msgid "(If no error) table of fields which describe the file's block size, creation time, size, and other attributes. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:342
msgid "table."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:344
msgid "Additionally, the result of ``fio.stat('file-name')`` will include methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:347
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:348
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:349
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:350
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:351
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:352
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:353
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:355
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:359
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:385
msgid "Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2 rmdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:388
#: ../doc/reference/reference_lua/fio.rst:412
#: ../doc/reference/reference_lua/fio.rst:432
msgid "path of directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:389
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:392
#: ../doc/reference/reference_lua/fio.rst:512
#: ../doc/reference/reference_lua/fio.rst:534
#: ../doc/reference/reference_lua/fio.rst:609
#: ../doc/reference/reference_lua/fio.rst:633
#: ../doc/reference/reference_lua/fio.rst:656
#: ../doc/reference/reference_lua/fio.rst:704
msgid "(If no error) true. |br| (If error) two return values: false, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:398
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:409
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:413
msgid "(If success) true. (If failure) false."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:418
msgid "tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:429
msgid "List files in directory. The result is similar to the result from the ``ls`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:433
msgid "(If no error) a list of files. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:439
msgid "tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:450
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:454
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:455
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:458
#: ../doc/reference/reference_lua/fio.rst:788
#: ../doc/reference/reference_lua/fio.rst:1021
msgid "**Possible errors:** nil."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:462
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:475
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:479
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:490
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:494
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:505
msgid "Copy everything in the from-path, including subdirectory contents, to the to-path. The result is similar to the result that one gets from the ``cp -r`` command. The to-path should be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:510
#: ../doc/reference/reference_lua/fio.rst:511
#: ../doc/reference/reference_lua/fio.rst:533
#: ../doc/reference/reference_lua/fio.rst:556
msgid "path-name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:518
msgid "tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:529
msgid "Create the path, including subdirectories, but without file contents. The result is similar to the result that one gets from the ``mkdir`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:540
msgid "tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:551
msgid "Remove the directory indicated by path-name, including subdirectories. The result is similar to the result that one gets from the ``rmdir`` command, recursively. The directory must be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:557
msgid "(If no error) true. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:563
msgid "tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:577
msgid "Functions to create and delete links. For details type ``man readlink``, ``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:580
msgid "existing file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:581
msgid "linked name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:583
msgid "(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true, ``fio.readlink`` returns the link value. |br| (If error) two return values: false|null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:589
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:604
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:606
msgid "original name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:607
msgid "new name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:615
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:626
msgid "Change the access time and possibly also change the update time of a file. For details type ``man 2 utime``. Times should be expressed as number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:629
msgid "name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:630
msgid "time of last access. default current time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:631
msgid "time of last update. default = access time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:639
msgid "tarantool> fio.utime('/home/username/tmp.txt')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:650
msgid "Copy a file. The effect is similar to the effect that one gets with the ``cp`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:653
msgid "path to original file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:654
msgid "path to new file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:662
msgid "tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:674
msgid "Manage the rights to file objects, or ownership of file objects. For details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:677
msgid "new user uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:678
msgid "new group uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:679
msgid "new permissions"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:680
msgid "null"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:684
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:699
msgid "Reduce file size to a specified value. For details type ``man 2 truncate``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:710
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:721
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:723
#: ../doc/reference/reference_lua/fio.rst:824
#: ../doc/reference/reference_lua/fio.rst:883
#: ../doc/reference/reference_lua/fio.rst:968
#: ../doc/reference/reference_lua/fio.rst:995
#: ../doc/reference/reference_lua/fio.rst:1075
msgid "true if success, false if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:728
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:743
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:745
msgid "Full path to the file to open."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:746
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT (create file if it doesn't exist), * O_DIRECT (do less caching or no caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * O_PATH (get a path for low-level use), * O_SYNC (force writing if it's possible), * O_TMPFILE (the file will be temporary and nameless), * O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:746
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:755
msgid "O_APPEND (start at end of file),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:756
msgid "O_ASYNC (signal when IO is possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:757
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:758
msgid "O_CREAT (create file if it doesn't exist),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:759
msgid "O_DIRECT (do less caching or no caching),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:760
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:761
msgid "O_EXCL (fail if file cannot be created),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:762
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:763
msgid "O_NOATIME (no access-time updating),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:764
msgid "O_NOCTTY (no console tty),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:765
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:766
msgid "O_NONBLOCK (no blocking),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:767
msgid "O_PATH (get a path for low-level use),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:768
msgid "O_SYNC (force writing if it's possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:769
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:770
msgid "O_TRUNC (truncate)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:772
msgid "... and, always, one of:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:774
msgid "O_RDONLY (read only),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:775
msgid "O_WRONLY (write only), or"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:776
msgid "O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:778
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or ``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:783
msgid "(If no error) file handle (abbreviated as 'fh' in later description). |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:790
#: ../doc/reference/reference_lua/http.rst:242
msgid "**Example 1:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:792
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:802
#: ../doc/reference/reference_lua/http.rst:271
msgid "**Example 2:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:804
msgid "Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an octal number:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:807
msgid "tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:820
msgid "Close a file that was opened with ``fio.open``. For details type ``man 2 close``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:823
#: ../doc/reference/reference_lua/fio.rst:845
#: ../doc/reference/reference_lua/fio.rst:878
#: ../doc/reference/reference_lua/fio.rst:919
#: ../doc/reference/reference_lua/fio.rst:964
#: ../doc/reference/reference_lua/fio.rst:994
#: ../doc/reference/reference_lua/fio.rst:1014
#: ../doc/reference/reference_lua/fio.rst:1040
#: ../doc/reference/reference_lua/fio.rst:1074
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:829
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:841
msgid "Perform random-access read operation on a file, without affecting the current seek position of the file. For details type ``man 2 pread``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:846
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:848
#: ../doc/reference/reference_lua/fio.rst:922
msgid "number of bytes to read"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:849
msgid "offset within file where reading begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:851
msgid "If the format is ``pread(count, offset)`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:854
msgid "If the format is ``pread(buffer, count, offset)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:860
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:874
msgid "Perform random-access write operation on a file, without affecting the current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:879
#: ../doc/reference/reference_lua/fio.rst:965
msgid "value to write"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:880
msgid "number of bytes to write (if the format is ``pwrite(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:882
msgid "offset within file where writing begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:886
msgid "If the format is ``pwrite(new-string, offset)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:889
msgid "If the format is ``pwrite(buffer, count, offset)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:893
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:909
msgid "Perform non-random-access read on a file. For details type ``man 2 read`` or ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:914
#: ../doc/reference/reference_lua/fio.rst:959
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:920
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:924
msgid "If the format is ``read()`` -- omitting ``count`` -- then read all bytes in the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:927
msgid "If the format is ``read()``  or ``read([count])`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:930
msgid "If the format is ``read(buffer, count)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:934
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:954
msgid "Perform non-random-access write on a file. For details type ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:966
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:971
msgid "If the format is ``write(new-string)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:974
msgid "If the format is ``write(buffer, count)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:980
msgid "tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:991
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1000
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1011
msgid "Shift position in the file to the specified position. For details type ``man 2 seek``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1015
msgid "position to seek to"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1016
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1018
msgid "the new position if success"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1025
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1036
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1041
msgid "details about the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1046
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1070
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type ``man 2 fsync`` or ``man 2 fdatasync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1079
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1090
msgid "FIO constants"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1096
msgid "Table with constants which are the same as POSIX flag values on the target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1101
msgid "tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:5
msgid "Module `fun`"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:7
msgid "Luafun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:17
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual ``require`` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:23
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:5
msgid "Module `http`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:13
msgid "The ``http`` module, specifically the ``http.client`` submodule, provides the functionality of an HTTP client with support for HTTPS and keepalive. It uses routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:21
msgid "Below is a list of all ``http`` functions."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid ":ref:`http.client.new() <http-new>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid "Create an HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid "Perform an HTTP request"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid "Get a table with statistics"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:47
msgid "integer settings which are passed to libcurl."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:49
msgid "The two possible options are ``max_connections`` and ``max_total_connections``."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:51
msgid "``max_connections`` is the maximum number of entries in the cache. It affects libcurl `CURLMOPT_MAXCONNECTS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_. The default is -1."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:55
msgid "``max_total_connections`` is the maximum number of active connections. It affects libcurl  `CURLMOPT_MAX_TOTAL_CONNECTIONS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_. It is ignored if the curl version is less than 7.30. The default is 0, which allows libcurl to scale according to easy handles count."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:60
msgid "The default option values are usually good enough but in rare cases it might be good to set them. In that case here are two tips."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:63
msgid "1. You may want to control the maximum number of sockets that a particular http client uses simultaneously. If a system passes many requests to distinct hosts, then libcurl cannot reuse sockets. In this case setting ``max_total_connections`` may be useful, since it causes curl to avoid creating too many sockets which would not be used anyway."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:68
msgid "2. Do not set ``max_connections`` less than ``max_total_connections`` unless you are confident about your actions. When ``max_connections`` is less then ``max_total_connections``, in some cases libcurl will not reuse sockets for requests that are going to the same host. If the limit is reached and a new request occurs, then libcurl will first create a new socket, send the request, wait for the first connection to be free, and close it, in order to avoid exceeding the ``max_connections`` cache size. In the worst case, libcurl will create a new socket for every request, even if all requests are going to the same host. See `this Tarantool issue on github <https://github.com/tarantool/tarantool/issues/3945>`_ for details."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:80
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:85
msgid "tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:97
msgid "If ``http_client`` is an HTTP client instance, ``http_client:request()`` will perform an HTTP request and, if there is a successful connection, will return a table with connection information."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:101
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:102
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:103
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:   * ``ca_file`` - path to an SSL certificate file to verify the peer with  * ``ca_path`` - path to a directory holding one or more certificates to    verify the peer with  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the operating system    will wait while the connection is idle before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the note below about keepalive_interval.  * ``keepalive_interval`` - the interval, in seconds, that the operating    system will wait between sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both keepalive_idle and keepalive_interval are set, then    Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send Connection:close  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    transfer speed in bytes per second that the transfer should be below    during \"low speed time\" seconds for the library to consider it to be    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``low_speed_time`` - set the \"low speed time\" -- the time that the    transfer speed should be below the \"low speed limit\" for the library    to consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * ``max_header_name_len`` - the maximal length of a header name. If a header    name is bigger than this value, it is truncated to this length.    The default value is '32'.  * ``no_proxy`` - a comma-separated list of hosts that do not require proxies, or '*', or ''.    Set :samp:`no_proxy = {host} [, {host} ...]` to specify    hosts that can be reached without requiring a proxy, even if ``proxy`` has    been set to a non-blank value and/or if a proxy-related environment variable    has been set.    Set ``no__proxy = '*'`` to specify that all hosts can be reached    without requiring a proxy, which is equivalent to setting ``proxy=''``.    Set ``no_proxy = ''`` to specify that no hosts can be reached    without requiring a proxy, even if a proxy-related environment variable    (HTTP_PROXY) is used.    If ``no_proxy`` is not set, then a proxy-related environment variable    (HTTP_PROXY) may be used. See also    `CURLOPT_NOPROXY <https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html>`_  * ``proxy`` - a proxy server host or IP address, or ''.    If ``proxy`` is a host or IP address, then it may begin with a scheme,    for example 'https://' for an https proxy or 'http:// for an http proxy.    If ``proxy`` is set to '' an empty string, then proxy use is disabled,    and no proxy-related environment variable will be used.    If ``proxy`` is not set, then a proxy-related environment variable may be used, such as    HTTP_PROXY or HTTPS_PROXY or FTP_PROXY, or ALL_PROXY if the    protocol can be any protocol. See also    `CURLOPT_PROXY <https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html>`_  * ``proxy_port`` -- a proxy server port.    The default is 443 for an https proxy and 1080 for a non-https proxy.    See also    `CURLOPT_PROXYPORT <https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html>`_  * ``proxy_user_pwd`` -- a proxy server user name and/or password.    Format: :samp:`proxy_user_pwd = {user_name}:`    or :samp:`proxy_user_pwd = :{password}`    or :samp:`proxy_user_pwd = {user_name}:{password}`. See also    `CURLOPT_USERPWD <https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``timeout`` - number of seconds to wait for a curl API read request    before timing out  * ``unix_socket`` - a socket name to use instead of an Internet address,    for a local connection. The Tarantool server must be built with    ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>`    later in this section.  * ``verbose`` - set on/off verbose mode  * ``verify_host`` - set on/off verification of the certificate's name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off verification of the peer's SSL    certificate. See also    `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:107
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:108
msgid "``ca_path`` - path to a directory holding one or more certificates to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:110
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:111
msgid "``keepalive_idle`` - delay, in seconds, that the operating system will wait while the connection is idle before sending keepalive probes. See also `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note below about keepalive_interval."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:116
msgid "``keepalive_interval`` - the interval, in seconds, that the operating system will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both keepalive_idle and keepalive_interval are set, then Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive and Keep-Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send Connection:close"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:123
msgid "``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed in bytes per second that the transfer should be below during \"low speed time\" seconds for the library to consider it to be too slow and abort. See also `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:128
msgid "``low_speed_time`` - set the \"low speed time\" -- the time that the transfer speed should be below the \"low speed limit\" for the library to consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:132
msgid "``max_header_name_len`` - the maximal length of a header name. If a header name is bigger than this value, it is truncated to this length. The default value is '32'."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:135
msgid "``no_proxy`` - a comma-separated list of hosts that do not require proxies, or '*', or ''. Set :samp:`no_proxy = {host} [, {host} ...]` to specify hosts that can be reached without requiring a proxy, even if ``proxy`` has been set to a non-blank value and/or if a proxy-related environment variable has been set. Set ``no__proxy = '*'`` to specify that all hosts can be reached without requiring a proxy, which is equivalent to setting ``proxy=''``. Set ``no_proxy = ''`` to specify that no hosts can be reached without requiring a proxy, even if a proxy-related environment variable (HTTP_PROXY) is used. If ``no_proxy`` is not set, then a proxy-related environment variable (HTTP_PROXY) may be used. See also `CURLOPT_NOPROXY <https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:148
msgid "``proxy`` - a proxy server host or IP address, or ''. If ``proxy`` is a host or IP address, then it may begin with a scheme, for example 'https://' for an https proxy or 'http:// for an http proxy. If ``proxy`` is set to '' an empty string, then proxy use is disabled, and no proxy-related environment variable will be used. If ``proxy`` is not set, then a proxy-related environment variable may be used, such as HTTP_PROXY or HTTPS_PROXY or FTP_PROXY, or ALL_PROXY if the protocol can be any protocol. See also `CURLOPT_PROXY <https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:157
msgid "``proxy_port`` -- a proxy server port. The default is 443 for an https proxy and 1080 for a non-https proxy. See also `CURLOPT_PROXYPORT <https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:161
msgid "``proxy_user_pwd`` -- a proxy server user name and/or password. Format: :samp:`proxy_user_pwd = {user_name}:` or :samp:`proxy_user_pwd = :{password}` or :samp:`proxy_user_pwd = {user_name}:{password}`. See also `CURLOPT_USERPWD <https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:166
msgid "``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:168
msgid "``ssl_key`` - path to a private key file for a TLS and SSL client certificate. See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:171
msgid "``timeout`` - number of seconds to wait for a curl API read request before timing out"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:173
msgid "``unix_socket`` - a socket name to use instead of an Internet address, for a local connection. The Tarantool server must be built with ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` later in this section."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:177
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:178
msgid "``verify_host`` - set on/off verification of the certificate's name (CN) against host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:181
msgid "``verify_peer`` - set on/off verification of the peer's SSL certificate. See also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:185
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:187
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:188
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:189
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:190
msgid "``body`` - response body"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:191
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:195
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:197
msgid "``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:199
msgid "``http_client:post (url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:201
msgid "``http_client:put(url, body, options)`` - shortcut for ``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:203
msgid "``http_client:patch(url, body, options)`` - shortcut for ``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:205
msgid "``http_client:options(url, options)`` - shortcut for ``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:207
msgid "``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:209
msgid "``http_client:delete(url, options)`` - shortcut for ``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:211
msgid "``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:213
msgid "``http_client:connect:(url, options)`` - shortcut for ``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:216
msgid "Requests may be influenced by environment variables, for example users can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before initiating any requests, unless a ``proxy`` connection option has priority. See the web page document `Environment variables libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:227
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:229
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:230
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:231
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:232
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:233
msgid "``http_200_responses`` - total number of requests which have returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:235
msgid "``http_other_responses`` - total number of requests which have not returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:237
msgid "``failed_requests`` - total number of requests which have failed including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:244
msgid "Connect to an HTTP server, look at the size of the response for a 'GET' request, and look at the statistics for the session."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:247
msgid "tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:273
msgid "Start two Tarantool instances on the same computer."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:275
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:277
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:281
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:283
msgid "box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:289
msgid "Terminal #1 will show an error message: \"Invalid MsgPack\". This is not useful but demonstrates the syntax and demonstrates that was sent was received."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:5
msgid "Module `iconv`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:13
msgid "The ``iconv`` module provides a way to convert a string with one encoding to a string with another encoding, for example from ASCII to UTF-8. It is based on the POSIX iconv routines."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:17
msgid "An exact list of the available encodings may depend on environment. Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:26
msgid "Below is a list of all ``iconv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid "Create an iconv instance"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid "Perform conversion on a string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:47
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:49
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:50
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:52
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:55
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:59
msgid "tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:69
msgid "Convert."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:0
msgid "param string input-string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:71
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:73
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:75
msgid "If anything in input-string cannot be converted, there will be an error message and the result string will be unchanged."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:80
msgid "We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is hexadecimal 0414 according to the character database of Unicode_. Therefore that is what it will look like in UTF-16. We know that Tarantool typically uses the UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 target. Since the result is 0414, we see that iconv conversion works. (Different iconv implementations might use different names, for example UTF-16BE instead of UTF16BE.)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:90
msgid "tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:3
msgid "Built-in modules reference"
msgstr ""

#: ../doc/reference/reference_lua/index.rst:7
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:11
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:15
msgid "List of Lua modules"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:5
msgid "Module `json`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:11
msgid "The ``json`` module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford <http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. For a complete manual on Lua-CJSON please read `the official documentation <http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:20
msgid "Below is a list of all ``json`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid ":ref:`json.encode() <json-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid "Convert a Lua object to a JSON string"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid ":ref:`json.decode() <json-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid "Convert a JSON string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
msgid ":ref:`json.NULL <json-null>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
#: ../doc/reference/reference_lua/msgpack.rst:39
#: ../doc/reference/reference_lua/yaml.rst:34
msgid "Analog of Lua's \"nil\""
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid ":ref:`json.cfg() <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid "Set global flags"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:49
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:51
#: ../doc/reference/reference_lua/msgpack.rst:60
#: ../doc/reference/reference_lua/yaml.rst:46
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:52
#: ../doc/reference/reference_lua/json.rst:91
msgid "see :ref:`json.cfg <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:53
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:58
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:88
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:90
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:92
#: ../doc/reference/reference_lua/yaml.rst:57
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:97
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:115
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:123
#: ../doc/reference/reference_lua/msgpack.rst:111
#: ../doc/reference/reference_lua/yaml.rst:64
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:128
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:150
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:152
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:153
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:155
#: ../doc/reference/reference_lua/yaml.rst:101
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:158
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:181
msgid "Set values affecting behavior of :ref:`json.encode <json-encode>` and :ref:`json.decode <json-decode>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:184
msgid "The values are all either integers or boolean ``true``/``false`` values."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:186
msgid "``cfg.encode_deep_as_nil`` (default is false) -- see :ref:`below <json-module.cfg_encode_deep_as_nil>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:187
msgid "``cfg.encode_invalid_as_nil`` (default is false) -- use ``null`` for all unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:189
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:190
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:191
msgid "``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:192
msgid "``cfg.encode_number_precision`` (default is 14) -- maximum post-decimal digits"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:193
msgid "``cfg.encode_sparse_convert`` (default is true) -- handle excessively sparse arrays as maps"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:194
msgid "``cfg.encode_sparse_ratio`` (default is 2) -- how sparse an array can be"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:195
msgid "``cfg.encode_sparse_safe`` (default is 10) -- how much can safely be sparse"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:196
msgid "``cfg.encode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:198
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:199
msgid "``cfg.decode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:200
msgid "``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:201
msgid "``cfg.decode_save_metatables`` (default is true) -- like ``encode_load_metatables``"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:202
msgid "``cfg.decode_sparse_convert`` (default is true) -- like ``encode_sparse_convert``"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:203
msgid "``cfg.decode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:206
msgid "For example, the following code will encode 0/0 as nan (\"not a number\") and 1/0 as inf (\"infinity\"), rather than returning nil or an error message:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:209
msgid "json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:217
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:219
msgid "tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:226
msgid "To achieve the same effect for only one call to ``json.encode()`` without changing the configuration persistently, one could say ``json.encode({1, x, y, 2}, {encode_invalid_numbers = true})``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:230
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:237
msgid "**Behavior change:** Before Tarantool version 1.10.4, if a nested structure was deeper than ``cfg.encode_max_depth``, the deeper levels were cropped (encoded as nil)."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:241
msgid "Now, the result is an error suggesting that ``cfg.encode_max_depth`` is not deep enough. To return to the old behavior, say ``cfg.encode_deep_as_nil = true``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:245
msgid "This option is ignored for ``YAML``."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:5
msgid "Module `key_def`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:9
msgid "The `key_def` module has a function for making a definition of the field numbers and types of a tuple. The definition is usually used in conjunction with an index definition to extract or compare the index key values."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:18
msgid "Create a new key_def instance."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:20
msgid "field numbers and types. There must be at least one part and it must have at least fieldno and type."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/xlog.rst:0
msgid "returns"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:24
msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:26
msgid "The parts table has components which are the same as the ``parts`` option in :ref:`Options for space_object:create_index() <box_space-create_index-options>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:30
msgid "fieldno (integer) for example fieldno = 1. It is legal to say field instead of fieldno."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:32
msgid "type (string) for example type = 'string'."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:34
msgid "Other components are optional."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:36
msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:38
msgid "Example: ``key_def.new({{type = 'string', collation = 'unicode', field = 2}})``"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:45
msgid "A key_def object is an object returned by :ref:`key_def.new() <key_def-new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, :ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() <key_def-totable>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:57
msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:59
#: ../doc/reference/reference_lua/key_def.rst:134
#: ../doc/reference/reference_lua/key_def.rst:135
#: ../doc/reference/reference_lua/key_def.rst:160
#: ../doc/reference/reference_lua/key_def.rst:161
#: ../doc/reference/reference_lua/merger.rst:160
msgid "tuple or Lua table with field contents"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:61
msgid "the fields that were defined for the key_def object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:63
msgid "**Example #1:**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:65
msgid "-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:88
msgid "**Example #2**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:90
msgid "-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:104
msgid "**Example #3**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:106
msgid "-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:128
msgid "Compare the key fields of tuple_1 to the key fields of tuple_2. This is a tuple-by-tuple comparison so users do not have to write code which compares a field at a time. Each field's type and collation wll be taken into account. In effect it is a comparison of extract_key(tuple_1) with extract_key(tuple_2)."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:137
msgid "> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:143
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:155
msgid "Compare the key fields of tuple_1 to all the fields of tuple_2. This is the same as :ref:`key_def_object:compare() <key_def-compare>` except that tuple_2 contains only the key fields. In effect it is a comparison of extract_key(tuple_1) with tuple_2."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:163
msgid "> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:169
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:181
msgid "Combine the main key_def_object with other_key_def_object. The return value is a new key_def_object containing all the fields of the main key_def_object, then all the fields of other_key_def_object which are not in the main key_def_object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:186
msgid "definition of fields to add"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:188
msgid "key_def_object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:192
msgid "-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:205
msgid "Return a table containing what is in the key_def_object. This is the reverse of ``key_def.new()`` -- ``key_def.new()`` takes a table and returns a key_def object, ``key_def_object:totable()`` takes a key_def object and returns a table. This is useful for input to ``_serialize`` methods."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:215
msgid "-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:5
msgid "Module `log`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:13
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:18
msgid "As explained in the description of :ref:`log_format <cfg_logging-log_format>` configuration setting, there are two possible formats for log entries:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:48
msgid "Below is a list of all ``log`` functions."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:58
msgid ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:62
msgid "Write a user-generated message to a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid "Get the PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid "Rotate a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:84
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or ``debug``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:88
msgid "As explained in the description of the configuration setting for :ref:`log_level <cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:92
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:94
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:95
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:96
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:97
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:99
msgid "For example, if ``box.cfg.log_level`` is currently 5 (the default value), then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string.  Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string.  Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:107
msgid "Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:111
msgid "Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:117
msgid "The actual output will be a line in the log, containing:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:119
msgid "the current timestamp,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:120
msgid "a module name,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:121
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:122
msgid "``message``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:124
msgid "Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:132
msgid "PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:138
msgid "Rotate the log."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:146
msgid "$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:155
msgid "$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:162
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:164
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:5
msgid "Module `merger`"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:11
msgid "The ``merger`` module takes a stream of tuples and provides access to them as tables."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:18
msgid "The four functions for creating a merger object instance are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:20
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:21
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:22
msgid ":ref:`merger.new_table_source <merger-new_table_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:23
#: ../doc/reference/reference_lua/merger.rst:111
msgid ":ref:`merger.new(merger_source...) <merger-new_merger_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:25
msgid "The methods for using a merger object are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:27
msgid ":ref:`merger_object:select() <merger-select>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:28
#: ../doc/reference/reference_lua/merger.rst:116
msgid ":ref:`merger_object:pairs() <merger-pairs>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:36
msgid "Create a new merger instance from a tuple source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:38
msgid "A tuple source just returns one tuple."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:40
msgid "The generator function ``gen()`` allows creation of multiple tuples via an iterator."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:43
msgid "The ``gen()`` function should return:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:45
msgid "state, tuple each time it is called and a new tuple is available,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:46
msgid "nil when no more tuples are available."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:48
msgid "function for iteratively returning tuples"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:49
msgid "parameter for the gen function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:51
#: ../doc/reference/reference_lua/merger.rst:95
msgid "merger-object :ref:`a merger object <merger-object>`"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:53
#: ../doc/reference/reference_lua/merger.rst:100
msgid "Example: see :ref:`merger_object:pairs() <merger-pairs>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:59
msgid "Create a new merger instance from a buffer source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:61
#: ../doc/reference/reference_lua/merger.rst:73
msgid "Parameters and return: same as for :ref:`merger.new_tuple_source <merger-new_tuple_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:64
msgid "To set up a buffer, or a series of buffers, use :ref:`the buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:71
msgid "Create a new merger instance from a table source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:76
msgid "Example: see :ref:`merger_object:select() <merger-select>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:82
msgid "Create a new merger instance from a merger source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:84
msgid "A merger source is created from a :ref:`key_def <key_def-module>` object and a set of (tuple or buffer or table or merger) sources. It performs a kind of merge sort. It chooses a source with a minimal / maximal tuple on each step, consumes a tuple from this source, and repeats."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:91
msgid "object created with ``key_def``"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:92
msgid "parameter for the ``gen()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:93
msgid "``reverse=true`` if descending, false or nil if ascending"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:97
msgid "A ``key_def`` can be cached across requests with the same ordering rules (typically these would be requests accessing the same space)."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:106
msgid "A merger object is an object returned by:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:108
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:109
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:110
msgid ":ref:`merger.new_table_source <merger-new_table_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:113
msgid "It has methods:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:115
msgid ":ref:`merger_object:select() <merger-select>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:122
msgid "Access the contents of a merger object with familiar ``select`` syntax."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:124
#: ../doc/reference/reference_lua/merger.rst:125
msgid "as in ``net.box`` client :ref:`conn:select <conn-select>` method"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:127
msgid "a table of tuples, similar to what ``select`` would return"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:129
msgid "**Example with new_table_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:131
msgid "-- Source via new_table_source, simple generator function\n"
"-- tarantool> s:select()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger=require('merger')\n"
"k=0\n"
"function merger_function(param)\n"
"  k = k + 1\n"
"  if param[k] == nil then return nil end\n"
"  return box.NULL, param[k]\n"
"  end\n"
"chunks={}\n"
"chunks[1] = {{100}} chunks[2] = {{200}} chunks[3] = nil\n"
"s = merger.new_table_source(merger_function, chunks)\n"
"s:select()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:155
msgid "The ``pairs()`` method (or the equivalent ``ipairs() alias`` method) returns a luafun iterator. It is a Lua iterator, but also provides a set of handy methods to operate in functional style."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:162
msgid "the tuples that can be found with a standard ``pairs()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:164
msgid "**Example with new_tuple_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:166
msgid "-- Source via new_tuple_source, from a space of tables\n"
"-- The result will look like this:\n"
"-- tarantool> so:pairs():totable()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger = require('merger')\n"
"box.schema.space.create('s')\n"
"box.space.s:create_index('i')\n"
"box.space.s:insert({100})\n"
"box.space.s:insert({200})\n"
"so = merger.new_tuple_source(box.space.s:pairs())\n"
"so:pairs():totable()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:183
msgid "**Example with two mergers:**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:185
msgid "-- Source via key_def, and table data\n"
"\n"
"-- Create the key_def object\n"
"merger = require('merger')\n"
"key_def_lib = require('key_def')\n"
"key_def = key_def_lib.new({{\n"
"    fieldno = 1,\n"
"    type = 'string',\n"
"}})\n"
"-- Create the table source\n"
"data = {{'a'}, {'b'}, {'c'}}\n"
"source = merger.new_source_fromtable(data)\n"
"i1 = merger.new(key_def, {source}):pairs()\n"
"i2 = merger.new(key_def, {source}):pairs()\n"
"-- t1 will be 'a' (tuple 1 from merger 1)\n"
"t1 = i1:head():totable()\n"
"-- t3 will be 'c' (tuple 3 from merger 2)\n"
"t3 = i2:head():totable()\n"
"-- t2 will be 'b' (tuple 2 from merger 1)\n"
"t2 = i1:head():totable()\n"
"-- i1:is_null() will be true (merger 1 ends)\n"
"i1:is_null()\n"
"-- i2:is_null() will be true (merger 2 ends)\n"
"i2:is_null()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:212
msgid "**More examples:**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:214
msgid "See `https://github.com/Totktonada/tarantool-merger-examples <https://github.com/Totktonada/tarantool-merger-examples>`_ which, in addition to discussing the merger API in detail, shows Lua code for handling many more situations than are in this manual's brief examples."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:5
msgid "Module `msgpack`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:11
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them. Tarantool makes heavy internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:20
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid "Convert a Lua object to an MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
#: ../doc/reference/reference_lua/msgpack.rst:36
msgid "Convert a MsgPack string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:36
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:39
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid ":ref:`msgpack.decode_array_header <msgpack-decode_array_header>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid "Skip array header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
msgid ":ref:`msgpack.decode_map_header <msgpack-decode_map_header>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
msgid "Skip map header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid "Change configuration"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:58
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:61
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:68
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:70
#: ../doc/reference/reference_lua/msgpack.rst:98
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:71
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:76
msgid "(if ``msgpack_string`` is in valid MsgPack format) the original contents of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar value, such as a string or a number;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:79
msgid "\"next_start_position\". If ``decode`` stops after parsing as far as byte N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, and ``decode(msgpack_string, next_start_position)`` will continue parsing from where the previous ``decode`` stopped, plus 1. Normally ``decode`` parses all of ``msgpack_string``, so \"next_start_position\" will equal ``string.len(msgpack_string)`` + 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:86
msgid "table and number"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:92
msgid "Convert a MsgPack string to a Lua object. Because checking is skipped, ``decode_unchecked()`` can operate with string pointers to buffers which ``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-module>` module."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:102
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:103
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:105
msgid "lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:118
msgid "Call the mp_decode_array function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the array size and a pointer to the first array component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole array."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:122
#: ../doc/reference/reference_lua/msgpack.rst:150
msgid "a pointer to a byte array formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:123
msgid "a number greater than or equal to the string's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:127
msgid "the size of the array;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:128
msgid "a pointer to after the array header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:130
msgid "-- Example of decode_array_header\n"
"-- Suppose we have the raw data '\\x93\\x01\\x02\\x03'.\n"
"-- \\x93 is MsgPack encoding for a header of a three-item array.\n"
"-- We want to skip it and decode the next three items.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_array_header(ffi.cast('char*','\\x93\\x01\\x02\\x03'),4)\n"
"a=msgpack.decode(y,1);b=msgpack.decode(y+1,1);c=msgpack.decode(y+2,1);\n"
"a,b,c\n"
"-- The result will be: 1,2,3."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:146
msgid "Call the mp_decode_map function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the map size and a pointer to the first map component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole map."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:151
msgid "a number greater than or equal to the byte array's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:155
msgid "the size of the map;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:156
msgid "a pointer to after the map header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:158
msgid "-- Example of decode_map_header\n"
"-- Suppose we have the raw data '\\x81\\xa2\\x41\\x41\\xc3'.\n"
"-- \\x81 is MsgPack encoding for a header of a one-item map.\n"
"-- We want to skip it and decode the next map item.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_map_header(ffi.cast('char*','\\x81\\xa2\\x41\\x41\\xc3'),5)\n"
"a=msgpack.decode(y,3);b=msgpack.decode(y+3,1)\n"
"x,a,b\n"
"-- The result will be: 1,\"AA\", true."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:174
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:199
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:201
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:202
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:204
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:208
msgid "function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:228
msgid "**Result:**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:267
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:236
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:243
msgid "and the second encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:282
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:250
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:258
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "{}"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'a'"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "false"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "'false' = c2"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "true"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "'true' = c3"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "127"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "65535"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "4294967295"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:281
msgid "'nil' = c0"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "msgpack.NULL"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "same as nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid "[0] = 5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "[0] = nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "1.5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:298
msgid "Some MsgPack configuration settings can be changed, in the same way that they can be changed for json. See :ref:`Module JSON <json-module_cfg>` for a list of some configuration settings. (The same configuration settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:303
msgid "For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the default), then nan and inf are legal values. If that is not desirable, then ensure that ``msgpack.encode()`` will not accept them, by saying ``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:308
msgid " tarantool> msgpack = require('msgpack'); msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:11
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is for connecting to Tarantool server instances via a network."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:19
msgid "``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:21
msgid "``net_box.connect()`` to connect and get a connection object (named ``conn`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:23
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote database system,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:27
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact that is perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. However for some cases a single connection is not enough —- for example, when it is necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:36
msgid "Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:38
msgid "``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:42
msgid "``{is_async=...}``. For example, a method whose final argument is ``{is_async=true}`` will not wait for the result of a request. See the :ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:45
msgid "``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See the :ref:`box.session.push <box_session-push>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:60
msgid "``net_box.connect()`` method changes the state to 'connecting' and spawns a worker fiber."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:62
msgid "If authentication and schema upload are required, it's possible later on to re-enter the 'fetch_schema' state from 'active' if a request fails due to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:66
msgid "``conn.close()`` method sets the state to 'closed' and kills the worker. If the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:83
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid "Execute a PING command"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid "Wait for a target state"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid "Close a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid "Select one or more tuples"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid "Select a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid "Insert a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
#: ../doc/reference/reference_lua/net_box.rst:118
msgid "Update a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:118
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid "Delete a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid "Call a stored procedure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid "Set a timeout"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:146
msgid "The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is preferred; ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:149
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:155
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:167
msgid "Possible options:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:169
msgid "`wait_connected`: by default, connection creation is blocked until the connection is established, but passing ``wait_connected=false`` makes it return immediately. Also, passing a timeout makes it wait before returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:175
msgid "In the presence of ``reconnect_after``, ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:178
msgid "`reconnect_after`: a ``net.box`` instance automatically reconnects any time the connection is broken or if a connection attempt fails. This makes transient network failures become transparent to the application. Reconnect happens automatically in the background, so queries/requests that suffered due to connectivity loss are transparently retried. The number of retries is unlimited, connection attempts are done over the specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed, or once the Lua garbage collector removes it, reconnects stop."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:188
msgid "`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new binary protocol command for CALL, which is not backward compatible with previous versions. The new CALL no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:197
msgid "`console`: depending on the option's value, the connection supports different methods (as if instances of different classes were returned). With ``console = true``, you can use ``conn`` methods ``close()``, ``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary and Lua console network protocols are supported). With ``console = false`` (default), you can also use ``conn`` database methods (in this case, only the binary protocol is supported). Deprecation notice: ``console = true`` is deprecated, users should use :ref:`console.connect() <console-connect>` instead."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:205
msgid "`connect_timeout`: number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:207
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:208
msgid "possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:209
msgid "conn object"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:212
#: ../doc/reference/reference_lua/net_box.rst:280
#: ../doc/reference/reference_lua/net_box.rst:417
#: ../doc/reference/reference_lua/net_box.rst:451
#: ../doc/reference/reference_rock/vshard/index.rst:1293
msgid "**Examples:**"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:214
msgid "conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:226
msgid "Execute a PING command."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:228
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:229
msgid "true on success, false on error"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:234
msgid "net_box.self:ping({timeout = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:244
#: ../doc/reference/reference_lua/net_box.rst:276
msgid "in seconds"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:245
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:250
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:258
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:260
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:265
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:273
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:275
msgid "target states"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:277
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:282
msgid "-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:297
msgid "Close a connection."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:299
msgid "Connection objects are destroyed by the Lua garbage collector, just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:306
msgid "conn:close()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:314
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:320
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:326
msgid "Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:337
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:342
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:350
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:356
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:364
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:370
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:378
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:384
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:392
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:400
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:408
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:414
msgid "To ensure that the return from ``conn:eval`` is whatever the Lua expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:419
msgid "tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:443
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call. The return from ``conn:call`` is whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:447
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:453
msgid "tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:476
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it. Since version 1.7.4 this method is deprecated -- it is better to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:482
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:486
msgid "Although ``timeout(...)`` is deprecated, all remote calls support its use. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:498
msgid "``{is_async=true|false}`` is an option which is applicable for all ``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn.space.space-name`` requests."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:502
msgid "The default is ``is_async=false``, meaning requests are synchronous for the fiber. The fiber is blocked, waiting until there is a reply to the request or until timeout expires. Before Tarantool version 1.10, the only way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:508
msgid "The non-default is ``is_async=true``, meaning requests are asynchronous for the fiber. The request causes a yield but there is no waiting. The immediate return is not the result of the request, instead it is an object that the calling program can use later to get the result of the request."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:514
msgid "This immediately-returned object, which we'll call \"future\", has its own methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:517
msgid "``future:is_ready()`` which will return true when the result of the request is available,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:519
msgid "``future:result()`` to get the result of the request (returns the response or **nil** in case it's not ready yet or there has been an error),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:521
msgid "``future:wait_result(timeout)`` to wait until the result of the request is available and then get it,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:523
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:525
msgid "Typically a user would say ``future=request-name(...{is_async=true})``, then either loop checking ``future:is_ready()`` until it is true and then say ``request_result=future:result()``, or say ``request_result=future:wait_result(...)``. Alternatively the client could check for \"out-of-band\" messages from the server by calling ``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-push>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:534
msgid "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:556
msgid "Typically ``{is_async=true}`` is used only if the load is large (more than 100,000 requests per second) and latency is large (more than 1 second), or when it is necessary to send multiple requests in parallel then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:564
msgid "Although the final result of an async request is the same as the result of a sync request, it is structured differently: as a table, instead of as the unpacked values."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:572
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:574
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:576
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:577
msgid "there is a space named ``tester`` with a numeric primary key and with a tuple that contains a key value = 800,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:579
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:581
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:583
msgid "box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:591
msgid "And here starts the example:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:593
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:5
msgid "Module `os`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:13
msgid "The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:30
msgid "Below is a list of all ``os`` functions."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid ":ref:`os.execute() <os-execute>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid "Execute by passing to the shell"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:43
msgid ":ref:`os.rename() <os-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid "Get an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid ":ref:`os.remove() <os-remove>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid "Remove a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid ":ref:`os.date() <os-date>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid "Get a formatted date"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid ":ref:`os.exit() <os-exit>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid "Exit the program"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid ":ref:`os.time() <os-time>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid "Get the number of seconds since the epoch"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid ":ref:`os.clock() <os-clock>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid "Get the number of CPU seconds since the program start"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid "Get the name of a temporary file"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid ":ref:`os.environ() <os-environ>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid "Get a table with all environment variables"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid "Set an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid "Change the locale"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid "Get the number of seconds between two times"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:84
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:86
msgid "what to execute."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:90
msgid "tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:106
msgid "Rename a file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:108
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:109
msgid "changed name of file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:113
msgid "tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:126
msgid "Get environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:128
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:132
msgid "tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:143
msgid "Remove file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:145
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:149
msgid "tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:160
msgid "Return a formatted date."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:167
msgid "tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:178
msgid "Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:182
msgid "tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:191
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:195
msgid "tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:206
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:210
msgid "tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:221
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:225
msgid "tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:236
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:240
msgid "tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:251
msgid "Set an environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:255
msgid "tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:266
msgid "Change the locale. If new-locale-string is not specified, return the current locale."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:271
msgid "tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:282
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:286
msgid "tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:3
msgid "Other package components"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:5
msgid "All the Tarantool modules are, at some level, inside a package which, appropriately, is named ``package``. There are also miscellaneous functions and variables which are outside all modules."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:17
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:17
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:20
msgid ":ref:`dostring() <other-dostring>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:20
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:23
msgid ":ref:`package.path <other-package_path>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:23
msgid "Where Tarantool looks for Lua additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid ":ref:`package.cpath <other-package_cpath>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid "Where Tarantool looks for C additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:29
msgid ":ref:`package.loaded <other-package_loaded>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:29
msgid "What Tarantool has already looked for and found"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid ":ref:`package.setsearchroot <other-package_setsearchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid "Set the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid ":ref:`package.searchroot <other-package_searchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid "Get the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:44
msgid "Convert a string or a Lua number to a 64-bit integer. The input value can be expressed in decimal, binary (for example 0b1010), or hexadecimal (for example -0xffff). The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:54
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:79
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:83
msgid "Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:84
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:87
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:89
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:94
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:127
msgid "This is a string that Tarantool uses to search for Lua modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:135
msgid "This is a string that Tarantool uses to search for C modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:143
msgid "This is a string that shows what Lua or C modules Tarantool has loaded, so that their functions and members are available. Initially it has all the pre-loaded modules, which don't need ``require()``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:152
msgid "Set the search root. The search root is the root directory from which dependencies are loaded."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:155
msgid "the path. Default = current directory."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:157
msgid "The search-root string must contain a relative or absolute path. If it is a relative path, then it will be expanded to an absolute path. If search-root is omitted, or is box.NULL, then the search root is reset to the current directory, which is found with debug.sourcedir()."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:165
msgid "Suppose that a Lua file ``myapp/init.lua`` is the project root. |br| Suppose the current path is ``/home/tara``. |br| Add this as the first line of ``myapp/init.lua``: |br| :code:`package.setsearchroot()` |br| Start the project with |br| :code:`$ tarantool myapp/init.lua` |br| The search root will be the default, made absolute: ``/home/tara/myapp``. Within the Lua application all dependencies will be searched relative to ``/home/tara/myapp``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:179
msgid "Return a string with the current search root. After ``package.setsearchroot('/home')`` the returned string will be ``/home'``."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:3
msgid "Module `pickle`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:9
msgid "Below is a list of all ``pickle`` functions."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid "Convert Lua variables to binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid "Convert Lua variables back from binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:32
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:38
msgid "**Format specifiers**"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "b, B"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "converts Lua scalar value to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "s, S"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "i, I"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "l, L"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "n"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "N"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "q, Q"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "f"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "converts Lua scalar value to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "d"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "converts Lua scalar value to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "a, A"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "converts Lua scalar value to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:79
msgid "string containing format specifiers"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:80
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:81
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:85
msgid "A scalar value can be either a variable or a literal. Remember that large integers should be entered with :ref:`tonumber64() or LL or ULL suffixes <index-box_number>`."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:89
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:93
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:129
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:135
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:140
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:5
msgid "Module `socket`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:11
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:17
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:30
msgid "Below is a list of all ``socket`` functions."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid "Create a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
#: ../doc/reference/reference_lua/socket.rst:51
msgid "Connect a socket to a remote host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid "Get information about a remote site"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid "Make Tarantool act as a TCP server"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:51
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid ":ref:`socket_object:send() <socket-send>` |br| :ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid "Send data over a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid "Write data to the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid "Read from a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid "Read data from the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid "Bind a socket to the given host/port"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid "Start listening for incoming connections"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid "Accept a client connection + create a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid "Send a message on a UDP socket to a specified host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid "Receive a message on a UDP socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid "Shut down a reading end, a writing end, or both"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid "Close a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:error() <socket-error>` |br| :ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid "Get information about the last error on a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid "Set socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid "Get socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid "Set/clear the SO_LINGER flag"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid "Set/get the flag value"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid "Wait until something is readable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid "Wait until something is writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid "Wait until something is either readable or writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid "Get information about the connection's near side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid "Get information about the connection's far side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid "Wait for read/write activity"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:114
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will cause a yield so that other processes may take over, as is the norm for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:123
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:132
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:135
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:140
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:148
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:150
#: ../doc/reference/reference_lua/socket.rst:355
#: ../doc/reference/reference_lua/socket.rst:395
msgid "URL or IP address"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:151
#: ../doc/reference/reference_lua/socket.rst:356
#: ../doc/reference/reference_lua/socket.rst:396
msgid "port number"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:152
msgid "timeout"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:153
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:158
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:166
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:172
#: ../doc/reference/reference_lua/socket.rst:560
#: ../doc/reference/reference_lua/socket.rst:572
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:177
msgid "tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:197
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with :ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:201
msgid "host name or IP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:202
msgid "host port, may be 0"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:203
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:205
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:208
msgid "The handler-function-or-table parameter may be simply a function name / function declaration: :code:`handler_function`. Or it may be a table: :code:`{handler =` :samp:`{handler_function} [, prepare = {prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is mandatory; it may have a single parameter = the socket; it is for continuous operation after the connection is made. ``prepare_function`` is optional; it is executed once before any connection is made. Examples:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:220
msgid "socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:226
msgid "For a fuller example see :ref:`Use tcp_server to accept file contents sent with socat <socket_socat>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:235
msgid "Connect an existing socket to a remote host. The argument values are the same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:252
msgid "Parameters:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:242
msgid "Either:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:241
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:243
msgid "port - a number."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
#: ../doc/reference/reference_lua/socket.rst:252
msgid "Or:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:246
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:248
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:250
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:254
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:259
msgid "socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:270
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:272
#: ../doc/reference/reference_lua/socket.rst:397
msgid "what is to be sent"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:273
#: ../doc/reference/reference_lua/socket.rst:399
msgid "the number of bytes sent."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:276
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:282
msgid "Write as much data as possible to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:289
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:292
#: ../doc/reference/reference_lua/socket.rst:410
msgid "maximum number of bytes to receive. See :ref:`Recommended size <socket-recommended>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:293
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:296
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:307
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired. Unlike ``socket_object:recv`` (which uses an internal read-ahead buffer), ``socket_object:read`` depends on the socket's buffer."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:314
#: ../doc/reference/reference_lua/socket.rst:339
msgid "maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:316
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:318
msgid "maximum number of seconds to wait, for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:320
msgid ":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example :code:`{chunk=5,delimiter='x'}`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:324
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:334
msgid "Return data from the socket buffer if non-blocking. In case the socket is blocking, ``sysread()`` can block the calling process. Rarely used. For details, see also `this description <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:342
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:350
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:358
msgid "true for success, false for error. If return is false, use :ref:`socket_object:errno() <socket-error>` or :ref:`socket_object:error() <socket-error>` to see details."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:367
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:369
msgid "on Linux the listen ``backlog`` backlog may be from ``/proc/sys/net/core/somaxconn``, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:373
msgid "true for success, false for error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:374
msgid "boolean."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:380
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:384
msgid "new socket if success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:387
msgid "Possible errors: nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:393
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:402
msgid "Possible errors: on error, returns nil and may return status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:408
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:411
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:412
msgid "string, table"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:414
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:418
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:422
msgid "message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:432
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:434
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:436
#: ../doc/reference/reference_lua/tap.rst:154
#: ../doc/reference/reference_lua/tap.rst:177
#: ../doc/reference/reference_lua/tap.rst:211
#: ../doc/reference/reference_lua/tap.rst:246
#: ../doc/reference/reference_lua/tap.rst:259
#: ../doc/reference/reference_lua/tap.rst:269
#: ../doc/reference/reference_lua/tap.rst:284
#: ../doc/reference/reference_lua/tap.rst:305
#: ../doc/reference/reference_lua/tap.rst:324
msgid "true or false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:443
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when the Lua garbage collector removes its user data."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:447
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:456
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:459
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:461
msgid "number, string"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:467
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:471
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:472
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:473
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:474
msgid "SO_DEBUG"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:475
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:476
msgid "SO_ERROR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:477
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:478
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:479
msgid "SO_MARK"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:480
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:481
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:482
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:483
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:484
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:485
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:486
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:487
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:488
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:489
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:490
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:491
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:492
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:493
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:494
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:495
msgid "SO_TYPE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:497
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:503
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:509
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:514
msgid "new active and timeout values."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:520
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:521
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:522
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:524
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:531
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:533
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:539
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:541
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:547
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:549
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:555
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:567
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:579
msgid "The ``socket.iowait()`` function is used to wait until read-or-write activity occurs for a file descriptor."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:582
msgid "file descriptor"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:583
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:584
msgid "number of seconds to wait"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:586
msgid "If the fd parameter is nil, then there will be a sleep until the timeout. If the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:589
msgid "Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:593
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:599
msgid "Recommended size"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:601
msgid "For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to limit the number of bytes to receive. A fixed size such as 512 is often reasonable; a pre-calculated size that depends on context -- such as the message format or the state of the network -- is often better. For ``recvfrom``, be aware that a size greater than the `Maximum Transmission Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can cause inefficient transport. For Mac OS X, be aware that the size can be tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:612
msgid "If ``size`` is not stated: Tarantool will make an extra call to calculate how many bytes are necessary. This extra call takes time, therefore not stating ``size`` may be inefficient."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:616
msgid "If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a TCP socket, excess bytes are not discarded and can be received by the next call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:622
msgid "Examples"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:626
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:628
msgid "In this example a connection is made over the internet between a Tarantool instance and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has moved. This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:634
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:665
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:667
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:673
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:712
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:714
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:719
msgid "Start two shells. The first shell will be a server instance. The second shell will be the client."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:722
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:724
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:746
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:753
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:758
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server instance's host and port:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:761
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:765
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:5
msgid "Module `strict`"
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:9
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:14
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:20
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:5
msgid "Module `string`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:13
msgid "The :code:`string` module has everything in the `standard Lua string library <https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:17
msgid "In this section we only discuss the additional functions that the Tarantool developers have added."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:24
msgid "Below is a list of all additional ``string`` functions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:34
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:34
msgid "Left-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:37
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:37
msgid "Right-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:40
msgid ":ref:`string.hex() <string-hex>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:40
msgid "Given a string, return hexadecimal values"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:43
msgid ":ref:`string.fromhex() <string-fromhex>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:43
msgid "Given hexadecimal values, return a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:46
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:46
msgid "Check if a string starts with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:49
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:49
msgid "Check if a string ends with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:52
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:52
msgid "Remove characters from the left of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:55
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:55
msgid "Remove characters from the right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:58
msgid ":ref:`string.split() <string-split>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:58
msgid "Split a string into a table of strings"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:61
msgid ":ref:`string.strip() <string-strip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:61
msgid "Remove spaces on the left and right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:69
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:71
msgid "(string) the string to left-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:72
msgid "(integer) the width of the string after left-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:73
#: ../doc/reference/reference_lua/string.rst:98
msgid "(string) a single character, default = 1 space"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:75
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:80
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:94
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:96
msgid "(string) the string to right-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:97
msgid "(integer) the width of the string after right-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:100
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:105
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:119
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:121
#: ../doc/reference/reference_lua/string.rst:232
#: ../doc/reference/reference_lua/string.rst:258
#: ../doc/reference/reference_lua/string.rst:312
msgid "(string) the string to process"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:123
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:128
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:142
msgid "Given a string containing pairs of hexadecimal digits, return a string with one byte for each pair. This is the reverse of ``string.hex()``. The hexadecimal-input-string must contain an even number of hexadecimal digits."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:146
msgid "(string) string with pairs of hexadecimal digits"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:148
msgid "string with one byte for each pair of hexadecimal digits"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:153
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.fromhex('41424320')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:167
msgid "Return True if ``input-string`` starts with ``start-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:170
msgid "(string) the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:171
#: ../doc/reference/reference_lua/string.rst:201
msgid "(string) the string to look for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:172
#: ../doc/reference/reference_lua/string.rst:202
msgid "(integer) position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:173
#: ../doc/reference/reference_lua/string.rst:203
msgid "(integer) position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:175
#: ../doc/reference/reference_lua/string.rst:205
#: ../doc/reference/reference_lua/utf8.rst:148
#: ../doc/reference/reference_lua/utf8.rst:173
#: ../doc/reference/reference_lua/utf8.rst:195
#: ../doc/reference/reference_lua/utf8.rst:217
msgid "true or false"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:178
#: ../doc/reference/reference_lua/string.rst:208
msgid "``start-pos`` and ``end-pos`` may be negative, meaning the position should be calculated from the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:183
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:197
msgid "Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:200
msgid "(string) the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:213
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:228
msgid "Return the value of the input string, after removing characters on the left. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.lstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:233
#: ../doc/reference/reference_lua/string.rst:259
#: ../doc/reference/reference_lua/string.rst:313
msgid "(string) what characters can be stripped. Default = space."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:235
#: ../doc/reference/reference_lua/string.rst:261
#: ../doc/reference/reference_lua/string.rst:315
msgid "result after stripping characters from input string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:240
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:254
msgid "Return the value of the input string, after removing characters on the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.rstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:266
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:280
msgid "Split ``input-string`` into one or more output strings in a table. The places to split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:284
msgid "(string) the string to split"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:285
msgid "(string) the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:288
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:293
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:308
msgid "Return the value of the input string, after removing characters on the left and the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.strip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:320
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:5
msgid "Module `swim`"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:11
msgid "The ``swim`` module contains Tarantool's implementation of SWIM -- Scalable Weakly-consistent Infection-style Process Group Membership Protocol. It is recommended for any type of Tarantool cluster where the number of nodes can be large. Its job is to discover and monitor the other members in the cluster and keep their information in a \"member table\". It works by sending and receiving, in a background event loop, periodically, via UDP, messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:19
msgid "Each message has several parts, including:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:21
msgid "the ping such as \"I am checking whether you are alive\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:22
msgid "the event such as \"I am joining\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:23
msgid "the anti-entropy such as \"I know that another member exists\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:24
msgid "the payload such as \"I or another member could have user-generated data\"."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:26
msgid "The maximum message size is about 1500 bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:28
msgid "SWIM sends messages periodically to a random subset of the member table. SWIM processes replies from those members asynchronously."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:31
msgid "Each entry in the member table has:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:33
msgid "a UUID,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:34
msgid "a status (\"alive\", \"suspected\", \"dead\", or \"left\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:36
msgid "When a member fails to acknowledge a certain number of pings, its status is changed from \"alive\" to \"suspected\", that is, suspected of being dead. But SWIM tries to **avoid false positives** (misidentifying members as dead) which could happen when a member is overloaded and responds to pings too slowly, or when there is network trouble and packets can not go through some channels. When a member is suspected, SWIM randomly chooses other members and sends requests to them: \"please ping this suspected member\". This is called an **indirect ping**. Thus via different routes and additional hops the suspected member gets additional chances to reply, and thus \"refute\" the suspicion."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:47
msgid "Because selection is random there is an **even network load** of about one message per member per protocol step, regardless of the cluster size. This is a major feature of SWIM. Because the protocol depends on members passing information on, also known as \"gossiping\", members do not need to broadcast messages to every member, which would cause a network load of N messages per member per protocol step, where N is the number of members in the cluster. However, selection is not entirely random, there is a preference for selecting least-recently-pinged members, like a round-robin."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:56
msgid "Regarding the **anti-entropy** part of a message: this is necessary for maintaining the status in entries of the member table. Consider an example where two members, #1 and #2, are both alive. No events happen so only pings are being sent periodically. Then a third member, #3 appears. It knows about one of the existing members, #2. How can it discover the other member? Certainly #1 could notify #2 and #2 could notify #3, but messages go via UDP, so any notification event can be lost. However, regular messages containing \"ping\" and/or \"event\" also can contain an \"anti-entropy\" section, which is taken from a randomly-chosen part of the member table. So for this example, #2 will eventually randomly add to a regular message the anti-entropy note that #1 is alive, and thus #3 will discover #1 even though it did not receive a direct \"I am alive\" event message from #1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:72
msgid "Regarding the **UUID** part of an entry in the member table: this is necessary for stable identification, because UUID changes more rarely than URI (a combination of IP and port number). But if the UUID does change, SWIM will include both the new and old UUID in messages, so all other members will eventually learn about the new UUID and change the member table accordingly."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:80
msgid "Regarding the **payload** part of a message: this is not always necessary, it is a feature which allows passing user-generated information via SWIM instead of via node-to-node communication. The swim module has methods for specifying a \"payload\", which is arbitrary user data with a maximum size of about 1.2 KB. The payload can be anything, and it will be eventually disseminated over the cluster and available at other members. Each member can have its own payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:90
msgid "Messages can be **encrypted**. Encryption may not be necessary in a closed network but is necessary for safety if the cluster is on the public Internet. Users can specify an encryption algorithm, an encryption mode, and a private key. All parts of all messages (including ping, acknowledgment, event, payload, URI, and UUID) will be encrypted with that private key, as well as a random public key generated for each message to prevent pattern attacks."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:98
msgid "In theory the event dissemination speed (the number of hops to pass information throughout the cluster) is ``O(log(cluster_size))``. For that and other theoretical information see the Cornell University `paper <https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>`_ which originally described SWIM."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:110
msgid "Create a new SWIM instance. A SWIM instance maintains a member table and interacts with other members. Multiple SWIM instances can be created in a single Tarantool process."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
msgid "an optional configuration parameter.  If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-object_cfg>` is called.  If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``, except for generation. For configuration description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
msgid "an optional configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:116
msgid "If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-object_cfg>` is called."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:122
msgid "If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``, except for generation. For configuration description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:128
msgid "The generation part of ``cfg`` can only be specified during ``new()``, it cannot be specified later during ``cfg()``. Generation is part of :ref:`incarnation <swim-incarnation_description>`. Usually generation is not specified because the default value (a timestamp) is sufficient, but if there is reason to mistrust timestamps (because the time is changed or because the instance is started on a different machine), then users may say :samp:`swim.new({generation = {new-value}`. In that case the latest value should be persisted somehow (for example in a file, or in a space, or in a global service), and the new value must be greater than any previous value of generation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:140
msgid "swim-object :ref:`a swim object <swim-object>`"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:144
msgid "swim_object = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:152
msgid "A swim object is an object returned by :ref:`swim.new() <swim-new>`. It has methods: :ref:`cfg() <swim-object_cfg>`, :ref:`delete() <swim-delete>`, :ref:`is_configured() <swim-is_configured>`, :ref:`size() <swim-size>`, :ref:`quit() <swim-quit>`, :ref:`add_member() <swim-add_member>`, :ref:`remove_member() <swim-remove_member>`, :ref:`probe_member() <swim-probe_member>`, :ref:`broadcast() <swim-broadcast>`, :ref:`set_payload() <swim-set_payload>`, :ref:`set_payload_raw() <swim-set_payload_raw>`, :ref:`set_codec() <swim-set_codec>`, :ref:`self() <swim-self>`, :ref:`member_by_uuid() <swim-member_by_uuid>`, :ref:`pairs() <swim-pairs>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:174
msgid "Configure or reconfigure a SWIM instance."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:176
msgid "the options to describe instance behavior"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:178
msgid "The ``cfg`` table may have these components:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:180
msgid "``heartbeat_rate`` (double) -- rate of sending round messages, in seconds. Setting ``heartbeat_rate`` to X does not mean that every member will be checked every X seconds, instead X is the protocol speed. Protocol period depends on member count and heartbeat_rate. Default = 1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:186
msgid "``ack_timeout`` (double) -- time in seconds after which a ping is considered to be unacknowledged. Default = 30."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:189
msgid "``gc_mode`` (enum) -- dead member collection mode."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:191
msgid "If ``gc_mode == 'off'`` then SWIM never removes dead members from the member table (though users may remove them with :ref:`swim_object:remove_member() <swim-remove_member>`), and SWIM will continue to ping them as if they were alive."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:196
msgid "If ``gc_mode == 'on'`` then SWIM removes dead members from the member table after one round."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:199
msgid "Default = ``'on'``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:201
msgid "``uri`` (string or number) -- either an ``'ip:port'`` address, or just a port number (if ip is omitted then 127.0.0.1 is assumed). If ``port == 0``, then the kernel will select any free port for the IP address."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:206
msgid "``uuid`` (string or cdata struct tt_uuid) -- a value which should be unique among SWIM instances. Users may choose any value but the recommendation is: use :ref:`box.cfg.instance_uuid <cfg_replication-instance_uuid>`, the Tarantool instance's UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:212
msgid "All the ``cfg`` components are dynamic -- ``swim_object:cfg()`` may be called more than once. If it is not being called for the first time and a component is not specified, then the component retains its previous value. If it is being called for the first time then uri and uuid are mandatory, since a SWIM instance cannot operate without URI and UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:219
msgid "``swim_object:cfg()`` is atomic -- if there is an error, then nothing changes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:222
msgid "true if configuration succeeds"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:223
#: ../doc/reference/reference_lua/swim.rst:334
#: ../doc/reference/reference_lua/swim.rst:515
#: ../doc/reference/reference_lua/swim.rst:547
msgid "nil, ``err`` if an error occurred. ``err`` is an error object"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:227
msgid "swim_object:cfg({heartbeat_rate = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:231
msgid "After ``swim_object:cfg()``, all other ``swim_object`` methods are callable."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:235
msgid "Expose all non-nil components of the read-only table which was set up or changed by :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:240
msgid "tarantool> swim_object.cfg\n"
"---\n"
"- gc_mode: off\n"
"  uri: 3333\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:253
msgid "Delete a SWIM instance immediately. Its memory is freed, its member table entry is deleted, and it can no longer be used. Other members will treat this member as 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:258
msgid "After ``swim_object:delete()`` any attempt to use the deleted instance will cause an exception to be thrown."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:261
msgid "none, this method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:263
msgid "Example: ``swim_object:delete()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:269
msgid "Return false if a SWIM instance was created via :ref:`swim.new() <swim-new>` without an optional ``cfg`` argument, and was not configured with :ref:`swim_object:cfg() <swim-object_cfg>`. Otherwise return true."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:275
msgid "boolean result, true if configured, otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:277
msgid "Example: ``swim_object:is_configured()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:283
msgid "Return the size of the member table. It will be at least 1 because the \"self\" member is included."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:286
msgid "integer size"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:288
msgid "Example: ``swim_object:size()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:294
msgid "Leave the cluster."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:296
msgid "This is a graceful equivalent of :ref:`swim_object:delete() <swim-delete>` -- the instance is deleted, but before deletion it sends to each member in its member table a message, that this instance has left the cluster, and should not be considered dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:302
msgid "Other instances will mark such a member in their tables as 'left', and drop it after one round of dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:306
msgid "Consequences to the caller are the same as after ``swim_object:delete()`` -- the instance is no longer usable, and an error will be thrown if there is an attempt to use it."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:310
msgid "none, the method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:312
msgid "Example: ``swim_object:quit()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:318
msgid "Explicitly add a member into the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:320
msgid "This method is useful when a new member is joining the cluster and does not yet know what members already exist. In that case it can start interaction explicitly by adding the details about an already-existing member into its member table. Subsequently SWIM will discover other members automatically via messages from the already-existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:328
msgid "description of the member"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:330
msgid "The ``cfg`` table has two mandatory components, ``uuid`` and ``uri``, which have the same format as ``uuid`` and ``uri`` in the table for :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:333
msgid "true if member is added"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:338
msgid "swim_member_object = swim_object:add_member({uuid = ..., uri = ...})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:346
msgid "Explicitly and immediately remove a member from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:349
#: ../doc/reference/reference_lua/swim.rst:707
msgid "UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:351
msgid "true if member is removed"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:352
#: ../doc/reference/reference_lua/swim.rst:374
#: ../doc/reference/reference_lua/swim.rst:394
msgid "nil, ``err`` if an error occurred. ``err`` is an error object."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:354
msgid "Example: ``swim_object:delete('00000000-0000-1000-8000-000000000001')``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:360
msgid "Send a ping request to the specified ``uri`` address. If another member is listening at that address, it will receive the ping, and respond with an ACK (acknowledgment) message containing information such as UUID. That information will be added to the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:366
msgid "``swim_object:probe_member()`` is similar to :ref:`swim_object:add_member() <swim-add_member>`, but it does not require UUID, and it is not reliable because it uses UDP."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:370
msgid "URI. Format is the same as for ``uri`` in :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:373
msgid "true if member is pinged"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:376
msgid "Example: ``swim_object:probe_member(3333)``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:382
msgid "Broadcast a ping request to all the network interfaces in the system."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:385
msgid "``swim_object:broadcast()`` is like :ref:`swim_object:probe_member() <swim-probe_member>` to many members at once."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:389
msgid "All the sent ping requests have this port as destination port in their UDP headers. By default a currently bound port is used."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:393
msgid "true if broadcast is sent"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:398
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 3334, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> s1:probe_member(s2:self():uri())\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:broadcast(3334)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:499
msgid "Set a payload, as formatted data."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:501
msgid "Payload is arbitrary user defined data up to 1200 bytes in size and disseminated over the cluster. So each cluster member will eventually learn what is the payload of other members in the cluster, because it is stored in the member table and can be queried with :ref:`swim_member_object:payload() <swim-payload>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:507
msgid "Different members may have different payloads."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:509
msgid "Arbitrary Lua object to disseminate. Set to nil to remove the payload, in which case it will be eventually removed on other instances. The object is serialized in MessagePack."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:514
#: ../doc/reference/reference_lua/swim.rst:546
msgid "true if payload is set"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:519
msgid "swim_object:set_payload({field1 = 100, field2 = 200})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:527
msgid "Set a payload, as raw data."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:529
msgid "Sometimes a payload does not need to be a Lua object. For example, a user may already have a well formatted MessagePack object and just wants to set it as a payload. Or cdata needs to be exposed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:534
msgid "``set_payload_raw`` allows setting a payload as is, without MessagePack serialization."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:537
msgid "any value"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:539
msgid "Payload size in bytes. If ``payload`` is string then ``size`` is optional, and if specified, then should not be larger than actual ``payload`` size. If ``size`` is less than actual ``payload`` size, then only the first ``size`` bytes of ``payload`` are used. If ``payload`` is cdata then ``size`` is mandatory."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:551
msgid "tarantool> tarantool> ffi = require('ffi')\n"
"---\n"
"...\n"
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:set_payload({a = 100, b = 200})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s2:set_payload('any payload')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1_view = s2:member_by_uuid(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s2_view = s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1_view:payload()\n"
"---\n"
"- {'a': 100, 'b': 200}\n"
"...\n"
"tarantool> s2_view:payload()\n"
"---\n"
"- any payload\n"
"...\n"
"tarantool> cdata = ffi.new('char[?]', 2)\n"
"---\n"
"...\n"
"tarantool> cdata[0] = 1\n"
"---\n"
"...\n"
"tarantool> cdata[1] = 2\n"
"---\n"
"...\n"
"tarantool> s1:set_payload_raw(cdata, 2)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> cdata, size = s1_view:payload_cdata()\n"
"---\n"
"...\n"
"tarantool> cdata[0]\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> cdata[1]\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> size\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:633
msgid "Enable encryption for all following messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:635
msgid "For a brief description of encryption algorithms see \"enum_crypto_algo\" and \"enum crypto_mode\" in the Tarantool source code file `crypto.h <https://github.com/tarantool/tarantool/blob/master/src/lib/crypto/crypto.h>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:640
msgid "When encryption is enabled, all the messages are encrypted with a chosen private key, and a randomly generated and updated public key."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:644
msgid "description of the encryption"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:646
msgid "The components of the ``codec_cfg`` table may be:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:648
msgid "``algo`` (string) -- encryption algorithm name. All the names in :ref:`module crypto <crypto>` are supported: 'aes128', 'aes192', 'aes256', 'des'. Specify 'none' to disable encryption."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:653
msgid "``mode`` (string) -- encryption algorithm mode. All the modes in module ``crypto`` are supported: 'ecb', 'cbc', 'cfb', 'ofb'. Default = 'cbc'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:657
msgid "``key`` (cdata or string) -- a private secret key which is kept secret and should never be stored hard-coded in source code."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:660
msgid "``key_size`` (integer) -- size of the key in bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:662
msgid "``key_size`` is mandatory if key is cdata."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:664
msgid "``key_size`` is optional if key is string, and if ``key_size`` is shorter than than actual key size then the key is truncated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:668
msgid "All of ``algo``, ``mode``, ``key``, and ``key_size`` should be the same for all SWIM instances, so that members can understand each others' messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:672
msgid "Example;"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:674
msgid "tarantool> tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> s1:set_codec({algo = 'aes128', mode = 'cbc', key = '1234567812345678'})\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:691
msgid "Return a :ref:`swim member object <swim-member_object>` (of self) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:695
msgid ":ref:`swim member object <swim-member_object>`, not nil because self() will not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:697
msgid "Example: ``swim_member_object = swim_object:self()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:703
msgid "Return a :ref:`swim member object <swim-member_object>` (given UUID) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:709
msgid ":ref:`swim member object <swim-member_object>`, or nil if not found"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:713
msgid "swim_member_object = swim_object:member_by_uuid('00000000-0000-1000-8000-000000000001')"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:721
msgid "Set up an iterator for returning :ref:`swim member objects <swim-member_object>` from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:726
msgid "``swim_object:pairs()`` should be in a 'for' loop, and there should only be one iterator in operation at one time. (The iterator is implemented in an extra light fashion so only one iterator object is available per SWIM instance.)"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:731
msgid "as for any Lua pairs() iterators. generator function, iterator object (a swim member object), and initial key (a UUID)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:738
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:self()\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s1:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:53666\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431865138ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000002\n"
"  payload_size: 0\n"
"...\n"
"tarantool> t = {}\n"
"---\n"
"...\n"
"tarantool> for k, v in s1:pairs() do table.insert(t, {k, v}) end\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- - - 00000000-0000-1000-8000-000000000002\n"
"    - uri: 127.0.0.1:53666\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431865138ULL, version = 1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000002\n"
"      payload_size: 0\n"
"  - - 00000000-0000-1000-8000-000000000001\n"
"    - uri: 127.0.0.1:55845\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000001\n"
"      payload_size: 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:809
msgid "Methods :ref:`swim_object:member_by_uuid() <swim-member_by_uuid>`, :ref:`swim_object:self() <swim-self>`, and :ref:`swim_object:pairs() <swim-pairs>` return swim member objects."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:815
msgid "A swim member object has methods for reading its attributes: :ref:`status() <swim-status>`, :ref:`uuid <swim-uuid>`, :ref:`uri() <swim-uri>`, :ref:`incarnation() <swim-incarnation>`, :ref:`payload_cdata <swim-payload_cdata>`, :ref:`payload_str() <swim-payload_str>`, :ref:`payload() <swim-payload>`, :ref:`is_dropped() <swim-is_dropped>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:830
msgid "Return the status, which may be 'alive', 'suspected', 'left', or 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:833
msgid "string 'alive' | 'suspected' | 'left' | dead'"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:839
msgid "Return the UUID as cdata struct tt_uuid."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:841
msgid "cdata-struct-tt-uuid UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:847
msgid "Return the URI as a string 'ip:port'. Via this method a user can learn a real assigned port, if port = 0 was specified in :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:852
msgid "string ip:port"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:858
msgid "Return a cdata object with the :ref:`incarnation <swim-incarnation_description>`. The cdata object has two attributes: incarnation().generation and incarnation().version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:862
msgid "Incarnations can be compared to each other with any comparison operator (==, <, >, <=, >=, ~=)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:865
msgid "Incarnations, when printed, will appear as strings with both generation and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:868
msgid "cdata incarnation"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:874
msgid "Return member's payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:876
msgid "pointer-to-cdata payload and size in bytes"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:882
msgid "Return payload as a string object. Payload is not decoded. It is just returned as a string instead of cdata. If payload was not specified by :ref:`swim_object:set_payload() <swim-set_payload>` or by :ref:`swim_object:set_payload_raw() <swim-set_payload_raw>`, then its size is 0 and nil is returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:889
msgid "string-object payload, or nil if there is no payload"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:895
msgid "Since the ``swim`` module is a Lua module, a user is likely to use Lua objects as a payload -- tables, numbers, strings etc. And it is natural to expect that :ref:`swim_member_object:payload() <swim-payload>` should return the same object which was passed into :ref:`swim_object:set_payload() <swim-set_payload>` by another instance. ``swim_member_object:payload()`` tries to interpret payload as MessagePack, and if that fails then it returns the payload as a string."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:906
msgid "``swim_member_object:payload()`` caches its result. Therefore only the first call actually decodes cdata payload. All following calls return a pointer to the same result, unless payload is changed with a new incarnation. If payload was not specified (its size is 0), then nil is returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:916
msgid "Returns true if this member object is a stray reference to a member which has already been dropped from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:919
msgid "boolean true if member is dropped, otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:923
msgid "tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> self = s:self()\n"
"---\n"
"...\n"
"tarantool> self:status()\n"
"---\n"
"- alive\n"
"...\n"
"tarantool> self:uuid()\n"
"---\n"
"- 00000000-0000-1000-8000-000000000001\n"
"...\n"
"tarantool> self:uri()\n"
"---\n"
"- 127.0.0.1:56367\n"
"...\n"
"tarantool> self:incarnation()\n"
"---\n"
"- - cdata {generation = 1569354463981551ULL, version = 1ULL}\n"
"...\n"
"tarantool> self:is_dropped()\n"
"---\n"
"- false\n"
"...\n"
"tarantool> s:set_payload_raw('123')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 3\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> s:set_payload({a = 100})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 4\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- !!binary gaFhZA==\n"
"...\n"
"tarantool> self:payload()\n"
"---\n"
"- {'a': 100}\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:989
msgid "Create an \"on_member :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed when a member in the member table is updated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:992
msgid "this will become the trigger function"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:993
msgid "(optional) this will be passed to trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:995
msgid "nil or function pointer."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:997
msgid "The **trigger-function** should have three parameter declarations (Tarantool will pass values for them when it invokes the function):"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1000
msgid "the member which is having the member event,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1001
msgid "the event object,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1002
msgid "the ``ctx`` which will be the same value as what is passed to ``swim_object:on_member_event``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1005
msgid "A **member event** is any of:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1007
msgid "appearance of a new member,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1008
msgid "drop of an existing member, or"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1009
msgid "update of an existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1011
msgid "An **event object** is an object which the trigger-function can use for determining what type of member event has happened. The object's methods -- such as ``is_new_status()``, ``is_new_uri()``, ``is_new_incarnation()``, ``is_new_payload()``, ``is_drop()`` -- return boolean values."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1017
msgid "A member event may have more than one associated **trigger**. Triggers are executed sequentially. Therefore if a trigger function causes yields or sleeps, other triggers may be forced to wait. However, since trigger execution is done in a separate fiber, SWIM itself is not forced to wait."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1024
msgid "Example of an on-member trigger function:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1026
msgid "tarantool> swim = require('swim')\n"
"\n"
"local function on_event(member, event, ctx)\n"
"    if event:is_new() then\n"
"        ...\n"
"    elseif event:is_drop() then\n"
"        ...\n"
"    end\n"
"\n"
"    if event:is_update() then\n"
"        -- All next conditions can be\n"
"        -- true simultaneously.\n"
"        if event:is_new_status() then\n"
"...\n"
"        end\n"
"        if event:is_new_uri() then\n"
"...\n"
"        end\n"
"        if event:is_new_incarnation() then\n"
"...\n"
"        end\n"
"        if event:is_new_payload() then\n"
"...\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1055
msgid "Notice in the above example that the function is ready for the possibility that multiple events can happen simultaneously for a single trigger activation. ``is_new()`` and ``is_drop()`` can not both be true, but ``is_new()`` and ``is_update()`` can both be true, or ``is_drop()`` and ``is_update()`` can both be true. Multiple simultaneous events are especially likely if there are many events and trigger functions are slow -- in that case, for example, a member might be added and then updated after a while, and then after a while there will be a single trigger activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1067
msgid "Also: ``is_new()`` and ``is_new_payload()`` can both be true. This case is not due to trigger functions that are slow. It occurs because \"omitted payload\" and \"size-zero payload\" are not the same thing. For example: when a ping is received, a new member might be added, but ping messages do not include payload. The payload will appear later in a different message. If that is important for the application, then the function should not assume when ``is_new()`` is true that the member already has a payload, and should not assume that payload size says something about the payload's presence or absence."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1078
msgid "Also: functions should not assume that ``is_new()`` and ``is_drop()`` will always be seen. If a new member appears but then is dropped before its appearance has caused a trigger activation, then there will be no trigger activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1084
msgid "``is_new_generation()`` will be true if the generation part of :ref:`incarnation <swim-incarnation_description>` changes. ``is_new_version()`` will be true if the version part of incarnation changes. ``is_new_incarnation()`` will be true if either the generation part or the version part of incarnation changes. For example a combination of these methods can be used within a user-defined trigger to check whether a process has restarted, or a member has changed ..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1094
msgid "swim = require('swim')\n"
"s = swim.new()\n"
"s:on_member_event(function(m, e)\n"
"...\n"
"    if e:is_new_incarnation() then\n"
"        if e:is_new_generation() then\n"
"            -- Process restart.\n"
"        end\n"
"        if e:is_new_version() then\n"
"            -- Process version update. It means\n"
"            -- the member is somehow changed.\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1113
msgid "Delete an on-member trigger."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1115
msgid "old-trigger"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1117
#: ../doc/reference/reference_lua/swim.rst:1132
msgid "The old-trigger value should be the value returned by ``on_member_event(trigger-function[, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1122
msgid "This is a variation of ``on_member_event(new-trigger, [, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1124
msgid "The additional parameter is ``old-trigger``. Instead of adding the new-trigger at the end of a list of triggers, this function will replace the entry in the list of triggers that matches old-trigger. The position within a list may be important because triggers are activated sequentially starting with the first trigger in the list."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1137
msgid "Return the list of on-member triggers."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1141
msgid "SWIM internals"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1143
msgid "The SWIM internals section is not necessary for programmers who wish to use the SWIM module, it is for programmers who wish to change or replace the SWIM module."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1146
msgid "The SWIM wire protocol is open, will be backward compatible in case of any changes, and can be implemented by users who wish to simulate their own SWIM cluster members because they use another language than Lua, or another environment unrelated to Tarantool. The protocol is encoded as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1153
msgid "SWIM packet structure:\n"
"\n"
"+-----------------Public data, not encrypted------------------+\n"
"|                                                             |\n"
"|      Initial vector, size depends on chosen algorithm.      |\n"
"|                   Next data is encrypted.                   |\n"
"|                                                             |\n"
"+----------Meta section, handled by transport level-----------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_META_TARANTOOL_VERSION: uint, Tarantool        |\n"
"|                                      version ID,            |\n"
"|     1 = SWIM_META_SRC_ADDRESS: uint, ip,                    |\n"
"|     2 = SWIM_META_SRC_PORT: uint, port,                     |\n"
"|     3 = SWIM_META_ROUTING: map {                            |\n"
"|         0 = SWIM_ROUTE_SRC_ADDRESS: uint, ip,               |\n"
"|         1 = SWIM_ROUTE_SRC_PORT: uint, port,                |\n"
"|         2 = SWIM_ROUTE_DST_ADDRESS: uint, ip,               |\n"
"|         3 = SWIM_ROUTE_DST_PORT: uint, port                 |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------Protocol logic section--------------------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_SRC_UUID: 16 byte UUID,                        |\n"
"|                                                             |\n"
"|                 AND                                         |\n"
"|                                                             |\n"
"|     2 = SWIM_FAILURE_DETECTION: map {                       |\n"
"|         0 = SWIM_FD_MSG_TYPE: uint, enum swim_fd_msg_type,  |\n"
"|         1 = SWIM_FD_GENERATION: uint,                       |\n"
"|         2 = SWIM_FD_VERSION: uint                           |\n"
"|     },                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     3 = SWIM_DISSEMINATION: array [                         |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     1 = SWIM_ANTI_ENTROPY: array [                          |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     4 = SWIM_QUIT: map {                                    |\n"
"|         0 = SWIM_QUIT_GENERATION: uint,                     |\n"
"|         1 = SWIM_QUIT_VERSION: uint                         |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------------------------------------------------+"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1228
msgid "The **Initial vector section** appears only when encryption is enabled. This section contains a public key. For example, for AES algorithms it is a 16-byte initial vector stored as is. When no encryption is used, the section size is 0."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1233
msgid "The later sections (Meta and Protocol Logic) are encrypted as one big data chunk if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1236
msgid "The **Meta section** handles routing and protocol versions compatibility. It works at the 'transport' level of the SWIM protocol, and is always present. Keys in the meta section are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1240
msgid "SWIM_META_TARANTOOL_VERSION -- mandatory field. Tarantool sets here its version as a 3 byte integer:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1243
msgid "1 byte for major,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1244
msgid "1 byte for minor,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1245
msgid "1 byte for patch."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1247
msgid "For example, Tarantool version 2.1.3 would be encoded like this: ``(((2 << 8) | 1) << 8) | 3;``. This field will be used to support multiple versions of the protocol."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1251
msgid "SWIM_META_SRC_ADDRESS and SWIM_META_SRC_PORT -- mandatory. source IP address and port. IP is encoded as 4 bytes. \"xxx.xxx.xxx.xxx\" where each 'xxx' is encoding of one byte. Port is encoded as an integer. Example of how to encode \"127.0.0.1:3313\":"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1256
msgid "struct in_addr addr;\n"
"inet_aton(\"127.0.0.1\", &addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_ADDRESS);\n"
"pos = mp_encode_uint(pos, addr->s_addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_PORT);\n"
"pos = mp_encode_uint(pos, 3313);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1265
msgid "SWIM_META_ROUTING subsection -- not mandatory. Responsible for packet forwarding. Used by SWIM suspicion mechanism. Read about suspicion in the SWIM paper."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1269
msgid "If this subsection is present then the following fields are mandatory:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1272
msgid "SWIM_ROUTE_SRC_ADDRESS and SWIM_ROUTE_SRC_PORT (source IP address and port) (should be an address of the message originator (can differ from"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1275
msgid "SWIM_META_SRC_ADDRESS and from SWIM_META_SRC_ADDRESS_PORT);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1276
msgid "SWIM_ROUTE_DST_ADDRESS and SWIM_ROUTE_DST_PORT (destination IP address and port, for the the message's final destination)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1279
msgid "If a message was sent indirectly with the help of SWIM_META_ROUTING, then the reply should be sent back by the same route."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1282
msgid "For an example of how SWIM uses routing for indirect pings ... Assume there are 3 nodes: S1, S2, S3. S1 sends a message to S3 via S2. The following steps are executed in order to deliver the message:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1287
msgid "S1 -> S2\n"
"{ src: S1, routing: {src: S1, dst: S3}, body: ... }"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1292
msgid "S2 receives the message and sees that routing.dst is not equal to S2, so it is a foreign packet. S2 forwards the packet to S3 preserving all the data including body and routing sections."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1296
msgid "S2 -> S3"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1300
msgid "S3 receives the message and sees that routing.dst is equal to S3, so the message is delivered. If S3 wants to answer, it sends a response via the same proxy. It knows that the message was delivered from S2, so it sends an answer via S2."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1305
msgid "The **Protocol logic section** handles SWIM logical protocol steps and actions."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1307
msgid "SWIM_SRC_UUID -- mandatory field. SWIM uses UUID as a unique identifier of a member, not IP/port. This field stores UUID of sender. Its type is MP_BIN. Size is always 16 bytes. UUID is encoded in host byte order, no bswaps are needed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1312
msgid "Following SWIM_SRC_UUID there are four possible subsections: SWIM_FAILURE_DETECTION, SWIM_DISSEMINATION, SWIM_ANTI_ENTROPY, SWIM_QUIT. Any or all of these subsections may be present. A connector should be ready to handle any combination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1317
msgid "SWIM_FAILURE_DETECTION subsection -- describes a ping or ACK. In the SWIM_FAILURE_DETECTION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1320
msgid "SWIM_FD_MSG_TYPE (0 is ping, 1 is ack);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1321
msgid "SWIM_FD_GENERATION + SWIM_FD_VERSION (the :ref:`incarnation <swim-incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1323
msgid "SWIM_DISSEMINATION subsection -- a list of changed cluster members. It may include only a subset of changed cluster members if there are too many changes to fit into one UDP packet."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1327
msgid "In the SWIM_DISSEMINATION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1329
msgid "SWIM_MEMBER_STATUS (mandatory) (0 = alive, 1 = suspected, 2 = dead, 3 = left);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1330
msgid "SWIM_MEMBER_ADDRESS and SWIM_MEMBER_PORT (mandatory) member IP and port;"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1331
msgid "SWIM_MEMBER_UUID (mandatory) (member UUID);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1332
msgid "SWIM_MEMBER_GENERATION + SWIM_MEMBER_VERSION (mandatory) (the member :ref:`incarnation <swim-incarnation_description>`);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1333
msgid "SWIM_MEMBER_PAYLOAD (not mandatory) (member payload) (MessagePack type is MP_BIN)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1336
msgid "Note that absence of SWIM_MEMBER_PAYLOAD means nothing - it is not the same as a payload with zero size."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1339
msgid "SWIM_ANTI_ENTROPY subsection -- a helper for the dissemination. It contains all the same fields as the dissemination sub, but all of them are mandatory, including payload even when payload size is 0. Anti-entropy eventually spreads changes which for any reason are not spread by the dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1345
msgid "SWIM_QUIT subsection -- statement that the sender has left the cluster gracefully, for example via :ref:`swim_object:quit() <swim-quit>`, and should not be considered dead. Sender status should be changed to 'left'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1350
msgid "In the SWIM_QUIT subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1352
msgid "SWIM_QUIT_GEMERATOPM + SWIM_QUIT_VERSION (the sender :ref:`incarnation <swim-incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1356
msgid "The **incarnation** is a 128-bit cdata value which is part of each member's configuration and is present in most messages. It has two parts: generation and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1360
msgid "Generation is persistent. By default it has the number of microseconds since the epoch (compare the value returned by :ref:`clock_realtime64() <clock-time>`). Optionally a user can set generation during :ref:`new() <swim-new>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1365
msgid "Version is volatile. It is initially 0. It is incremented automatically every time that a change occurs."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1368
msgid "The incarnation, or sometimes the version alone, is useful for deciding to ignore obsolete messages, for updating a member's attributes on remote nodes, and for refuting messages that say a member is dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1373
msgid "If the member's incarnation is less than the locally stored incarnation, then the message is obsolete. This can happen because UDP allows reordering and duplication."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1377
msgid "If the member's incarnation in a message is greater than the locally stored incarnation, then most of its attributes  (IP, port, status) should be updated with the values received in the message. However, the payload attribute should not be updated unless it is present in the message. Because of its relatively large size, payload is not always included in every message."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1384
msgid "Refutation usually happens when a false-positive failure detection has happened. In such a case the member thought to be dead receives that information from other members, increases its own incarnation, and spreads a message saying the member is alive (a \"refutation\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1390
msgid "Note: in the original version of Tarantool SWIM, and in the original SWIM specification, there is no generation and the incarnation consists of only the version. Generation was added because it is useful for detecting obsolete messages left over from a previous life of an instance that has restarted."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:5
msgid "Module `table`"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:9
msgid "The :code:`table` module has everything in the `standard Lua table library <https://www.lua.org/pil/19.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:13
msgid "You can see this by saying \"table\": you will see this list of functions: ``clear`` (LuaJIT extension = erase all elements), `concat <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ (concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see description below), ``foreach``, ``foreach1``, `getn <https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-table.insert>`_ (insert an element into an array), `maxn <https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ (move elements between tables), ``new`` (LuaJIT extension = return a new table with pre-allocated elements), `remove <https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove an element from an array), `sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the elements of an array)."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:28
msgid "In this section we only discuss the additional function that the Tarantool developers have added: ``deepcopy``."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:35
msgid "Return a \"deep\" copy of the table -- a copy which follows nested structures to any depth and does not depend on pointers, it copies the contents."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:39
msgid "(table) the table to copy"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:41
msgid "the copy of the table"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:46
msgid "tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:67
msgid "Put the input-table contents in sorted order."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:69
msgid "The `basic Lua table.sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ has a default comparison-function: :code:`function (a, b) return a < b end`."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:72
msgid "That is efficient and standard. However, sometimes Tarantool users will want an equivalent to ``table.sort`` which has any of these features:"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:75
msgid "(1) If the table contains nils, except nils at the end, the results must still be correct. That is not the case with the default tarantool_sort, and it cannot be fixed by making a comparison that checks whether a and b are nil. (Before trying certain Internet suggestions, test with {1, nil, 2, -1, 44, 1e308, nil, 2, nil, nil, 0}."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:81
msgid "(2) If strings are to be sorted in a language-aware way, there must be a parameter for collation."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:84
msgid "(3) If the table has a mix of types, then they must be sorted as booleans, then numbers, then strings, then byte arrays."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:87
msgid "Since all those features are available in Tarantool spaces, the solution for Tarantool is simple: make a temporary Tarantool space, put the table contents into it, retrieve the tuples from it in order, and overwrite the table."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:92
msgid "Here then is ``tarantool_sort()`` which does the same thing as ``table.sort`` but has those extra features. It is not fast and it requires a database privilege, so it should only be used if the extra features are necessary."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:97
msgid "  function tarantool_sort(input_table, collation)\n"
"      local c = collation or 'binary'\n"
"      local tmp_name = 'Temporary_for_tarantool_sort'\n"
"      pcall(function() box.space[tmp_name]:drop() end)\n"
"      box.schema.space.create(tmp_name, {temporary = true})\n"
"      box.space[tmp_name]:create_index('I')\n"
"      box.space[tmp_name]:create_index('I2',\n"
"                                       {unique = false,\n"
"                                        type='tree',\n"
"                                        parts={{2, 'scalar',\n"
"                                                collation = c,\n"
"                                                is_nullable = true}}})\n"
"      for i = 1, table.maxn(input_table) do\n"
"          box.space[tmp_name]:insert{i, input_table[i]}\n"
"      end\n"
"      local t = box.space[tmp_name].index.I2:select()\n"
"      for i = 1, table.maxn(input_table) do\n"
"          input_table[i] = t[i][2]\n"
"      end\n"
"      box.space[tmp_name]:drop()\n"
"    end\n"
"\n"
"For example, suppose table t = {1, 'A', -88.3, nil, true, 'b', 'B', nil, 'À'}.\n"
"After tarantool_sort(t, 'unicode_ci') t contains {nil, nil, true, -88.3, 1, 'A', 'À', 'b', 'B'}."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:3
msgid "Module `tap`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:9
msgid "The ``tap`` module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:27
msgid ":ref:`tap.test() <tap-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:27
msgid "Initialize"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:30
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:30
msgid "Create a subtest and print the results"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:33
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:33
msgid "Indicate how many tests to perform"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:36
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:36
msgid "Check the number of tests performed"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:39
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:39
msgid "Display a diagnostic message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:42
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:42
#: ../doc/reference/reference_lua/tap.rst:45
#: ../doc/reference/reference_lua/tap.rst:48
msgid "Evaluate the condition and display the message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:45
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:48
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:51
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:51
msgid "Check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:54
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:54
msgid "Check if the two arguments are different"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:57
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:57
msgid "Recursively check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:60
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:60
msgid "Check if the argument matches a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:63
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:63
msgid "Check if the argument does not match a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:66
msgid ":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() <taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| :ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() <taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| :ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:72
msgid "Check if a value has a particular type"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:81
msgid ":ref:`taptest.strict <taptest-strict>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:81
msgid "Flag, true if comparisons with nil should be strict"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:91
msgid "Initialize."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:93
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:97
#: ../doc/reference/reference_lua/tap.rst:118
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:98
#: ../doc/reference/reference_lua/tap.rst:120
msgid "taptest"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:101
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:112
msgid "Create a subtest (if no ``func`` argument specified), or (if all arguments are specified) create a subtest, run the test function and print the result."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:116
msgid "See the :ref:`example <tap-example>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:119
msgid "the test logic to run."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:121
msgid "userdata or string"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:127
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:136
msgid "Checks the number of tests performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:138
msgid "The result will be a display saying ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" messages are out of the TAP13 standard.)"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:143
msgid "This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script. However, as a Tarantool extension, ``taptest:check()`` may appear at the end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:148
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:149
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:150
msgid "or by calling taptest:test('...', subtest-function-name) where subtest-function-name does not need to end with ``taptest:check()`` because it can be called after the subtest is complete."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:161
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:163
msgid "the message to be displayed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:170
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:174
msgid "an expression which is true or false"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:175
#: ../doc/reference/reference_lua/tap.rst:209
#: ../doc/reference/reference_lua/tap.rst:222
#: ../doc/reference/reference_lua/tap.rst:245
#: ../doc/reference/reference_lua/tap.rst:257
#: ../doc/reference/reference_lua/tap.rst:274
#: ../doc/reference/reference_lua/tap.rst:289
#: ../doc/reference/reference_lua/tap.rst:303
#: ../doc/reference/reference_lua/tap.rst:322
msgid "name of the test"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:182
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:206
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:218
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:228
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:240
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:243
#: ../doc/reference/reference_lua/tap.rst:255
#: ../doc/reference/reference_lua/tap.rst:272
#: ../doc/reference/reference_lua/tap.rst:287
#: ../doc/reference/reference_lua/tap.rst:301
msgid "actual result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:244
#: ../doc/reference/reference_lua/tap.rst:256
#: ../doc/reference/reference_lua/tap.rst:273
msgid "expected result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:253
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:266
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:280
msgid "Verify a string against a `pattern <http://lua-users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:288
#: ../doc/reference/reference_lua/tap.rst:302
msgid "pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:291
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:299
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:318
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:331
msgid "Set ``taptest.strict=true`` if :ref:`taptest:is() <taptest-is>` and :ref:`taptest:isnt() <taptest-isnt>` and :ref:`taptest:is_deeply() <taptest-is_deeply>` must be compared strictly with ``nil``. Set ``taptest.strict=false`` if ``nil`` and ``box.NULL`` both have the same effect. The default is false. For example, if and only if ``taptest.strict=true`` has happened, then ``taptest:is_deeply({a = box.NULL}, {})`` will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:350
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:354
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:368
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:370
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:5
msgid "Module `tarantool`"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:9
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:15
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info() <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:22
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- version: 2.3.0-3-g302bb3241\n"
"  build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/opt/tarantool-install\n"
"-DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fexceptions -funwind-tables -fno-omit-frame-pointer\n"
"-fno-stack-protector\n"
"      -fno-common -fopenmp -msse2 -std=c11 -Wall -Wextra\n"
"-Wno-strict-aliasing -Wno-char-subscripts\n"
"      -Wno-format-truncation -fno-gnu89-inline -Wno-cast-function-type'\n"
"    compiler: /usr/bin/cc /usr/bin/c++\n"
"  pid: 'function: 0x40016cd0'\n"
"  package: Tarantool\n"
"  uptime: 'function: 0x40016cb0'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:3
msgid "Module `uri`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:9
msgid "A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:13
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:17
msgid "A common type, a hierarchical URI, looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:19
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:23
msgid "For example the string ``'https://tarantool.org/x.html#y'`` has three components:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:26
msgid "``https`` is the scheme,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:27
msgid "``tarantool.org/x.html`` is the path,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:28
msgid "``y`` is the fragment."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:30
msgid "Tarantool's URI module provides routines which convert URI strings into their components, or turn components into URI strings."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:37
msgid "Below is a list of all ``uri`` functions."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid "Get a table of URI components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid ":ref:`uri.format() <uri-format>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid "Construct a URI from components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:60
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:61
msgid "URI-components-table. Possible components are fragment, host, login, password, path, query, scheme, service."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:63
msgid "Table"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:67
msgid "tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:84
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:86
msgid "boolean. If this is supplied and is ``true``, then the password component is rendered in clear text, otherwise it is omitted."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:89
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:94
msgid "tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:5
msgid "Module `utf8`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:11
msgid "``utf8`` is Tarantool's module for handling UTF-8 strings. It includes some functions which are compatible with ones in `Lua 5.3 <https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much more. For example, because internally Tarantool contains a complete copy of the \"International Components For Unicode\" library, there are comparison functions which understand the default ordering for Cyrillic (Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = Katakana A)."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:21
msgid "The module is fully built-in so ``require('utf8')`` is not necessary."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:31
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:31
msgid "Comparisons"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:34
msgid ":ref:`lower <utf8-lower>` and |br| :ref:`upper <utf8-upper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:34
msgid "Case conversions"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:37
msgid ":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| :ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:37
msgid "Determine character types"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid ":ref:`sub <utf8-sub>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid "Substrings"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid ":ref:`len <utf8-len>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid "Length in characters"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:46
msgid ":ref:`next <utf8-next>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:46
msgid "Character-at-a-time iterations"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:55
#: ../doc/reference/reference_lua/utf8.rst:116
#: ../doc/reference/reference_lua/utf8.rst:237
#: ../doc/reference/reference_lua/utf8.rst:274
#: ../doc/reference/reference_lua/utf8.rst:291
#: ../doc/reference/reference_lua/utf8.rst:350
msgid "a string encoded with UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:56
#: ../doc/reference/reference_lua/utf8.rst:117
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:59
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code-point values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:66
msgid "The comparison is done with primary weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are ignored. If asked \"is this like a Microsoft case-insensitive accent-insensitive collation\" we tend to answer \"yes\", though the Unicode Collation Algorithm is far more sophisticated than those terms imply."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:76
msgid "tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:88
msgid "a Unicode code point value, repeatable"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:89
msgid "a UTF-8 string"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:92
msgid "The code-point number is the value that corresponds to a character in the `Unicode Character Database <http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not the same as the byte values of the encoded character, because the UTF-8 encoding scheme is more complex than a simple copy of the code-point number."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:99
msgid "Another way to construct a string with Unicode characters is with the \\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and ``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:105
msgid "tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:120
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:127
msgid "The comparison is done with at least three weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are not ignored. and upper case comes after lower case."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:134
msgid "tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:146
#: ../doc/reference/reference_lua/utf8.rst:171
#: ../doc/reference/reference_lua/utf8.rst:193
#: ../doc/reference/reference_lua/utf8.rst:215
msgid "a single UTF8 character, expressed as a one-byte string or a code point value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:151
msgid "Return true if the input character is an \"alphabetic-like\" character, otherwise return false. Generally speaking a character will be considered alphabetic-like provided it is typically used within a word, as opposed to a digit or punctuation. It does not have to be a character in an alphabet."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:158
msgid "tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:176
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:180
msgid "tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:198
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:202
msgid "tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:220
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:224
msgid "tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:238
msgid "byte position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:239
msgid "byte position where to stop"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:240
msgid "the number of characters in the string, or between start and end"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:243
msgid "Byte positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:246
msgid "If the string contains a byte sequence which is not valid in UTF-8, each byte in the invalid byte sequence will be counted as one character."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:249
msgid "UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese character takes three bytes, and the maximum is four bytes."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:256
msgid "tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:275
msgid "the same string, lower case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:280
msgid "tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:292
msgid "byte position where to start within the string, default is 1"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:293
msgid "byte position of the next character and the code point value of the next character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:296
msgid "The ``next`` function is often used in a loop to get one character at a time from a UTF-8 string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:301
msgid "In the string 'åa' the first character is 'å', it starts at position 1, it takes two bytes to store so the character after it will be at position 3, its Unicode code point value is (decimal) 229."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:306
msgid "tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) end\n"
"229\n"
"97\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:324
msgid "a string encoded as UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:325
msgid "the position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:326
msgid "the position of the last character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:327
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:330
msgid "Character positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:333
msgid "The default value for end-character is the length of the input string. Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as the input string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:339
msgid "tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:351
msgid "the same string, upper case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:356
msgid "In rare cases the upper-case result may be longer than the lower-case input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:361
msgid "tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:3
msgid "Module `uuid`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:9
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:19
msgid "Below is list of all ``uuid`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
#: ../doc/reference/reference_lua/uuid.rst:54
msgid "A nil object"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:31
msgid ":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| :ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:32
msgid "Get a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:35
msgid ":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| :ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:38
msgid "Get a converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid "Check if a UUID is an all-zero value"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:60
#: ../doc/reference/reference_lua/uuid.rst:67
#: ../doc/reference/reference_lua/uuid.rst:74
msgid "a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:68
msgid "16-byte string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:75
msgid "36-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:81
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:82
#: ../doc/reference/reference_lua/uuid.rst:90
msgid "converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:89
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:99
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:101
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:102
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:103
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:104
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:106
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:108
#: ../doc/reference/reference_lua/uuid.rst:115
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:109
msgid "16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:116
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:122
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:127
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:128
msgid "bool"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:134
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:5
msgid "Module `xlog`"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:7
msgid "The xlog module contains one function: ``pairs()``. It can be used to read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-log (WAL) <internals-wal>` files. A description of the file format is in section :ref:`Data persistence and the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:19
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:21
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:22
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:24
msgid "Possible errors: File does not contain properly formatted snapshot or write-ahead-log information."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:29
msgid "This will read the first write-ahead-log (WAL) file that was created in the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" exercises <getting_started>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:33
msgid "Each result from ``pairs()`` is formatted with MsgPack so its structure can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:36
msgid "xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:45
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:47
msgid "(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:5
msgid "Module `yaml`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:11
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:18
msgid "Below is a list of all ``yaml`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid "Convert a Lua object to a YAML string"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid "Convert a YAML string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:34
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:44
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:47
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:54
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:56
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:70
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:93
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:96
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:97
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:104
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:140
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:2
msgid "Cartridge Command Line Interface"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:5
#: ../doc/reference/reference_rock/dbms.rst:53
#: ../doc/reference/reference_rock/dbms.rst:406
#: ../doc/reference/reference_rock/vshard/index.rst:57
msgid "Installation"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:10
msgid "tarantoolctl rocks install cartridge-cli"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:11
msgid "Optionally you may add ``.rocks/bin`` to executable path:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:16
msgid "export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:18
msgid "Usage"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:20
msgid "For more details, run"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:25
msgid "cartridge --help"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:27
msgid "Applications lifecycle"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:29
msgid "Create an application from template:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:34
msgid "cartridge create --name myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:35
msgid "Pack an application into distributable:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:40
msgid "cartridge pack rpm myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:42
msgid "Managing instances"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:80
msgid "cartridge start [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"Options\n"
"    --script FILE       Application's entry point.\n"
"                        Default to TARANTOOL_SCRIPT,\n"
"                        or ./init.lua when running from app's directory,\n"
"                        or :apps_path/:app_name/init.lua in multi-app env.\n"
"\n"
"    --apps_path PATH    Path to apps direcrory when running in multi-app env.\n"
"                        Default to /usr/share/tarantool\n"
"\n"
"    --run_dir DIR       Directory with pid and sock files\n"
"                        Default to TARANTOOL_RUN_DIR or /var/run/tarantool\n"
"\n"
"    --cfg FILE          Cartridge instances config file.\n"
"                        Default to TARANTOOL_CFG or ./instances.yml\n"
"\n"
"    --foreground        Do not daemonize"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:65
msgid "It starts tarantool instance in background with enforced env-vars and waits until app’s main script is finished."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:104
msgid "TARANTOOL_INSTANCE_NAME\n"
"TARANTOOL_CFG\n"
"TARANTOOL_PID_FILE - %run_dir%/%instance_name%.pid\n"
"TARANTOOL_CONSOLE_SOCK - %run_dir%/%instance_name%.pid"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:75
msgid "``cartridge.cfg()`` uses ``TARANTOOL_INSTANCE_NAME`` to read instance’s config from file provided in ``TARANTOOL_CFG``."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:78
msgid "Default options for ``cartridge`` command can be overriden in ``./.cartridge.yml`` or ``~/.cartridge.yml``:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:86
msgid "run_dir: tmp/run\n"
"cfg: cartrifge.yml\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:87
msgid "When APP_NAME is not provided it is parsed from ``./*.rockspec`` filename. When ``INSTANCE_NAME`` is not provided cartridge reads ``cfg`` file and starts all defined instances:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:127
msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start app_1 # starts all instances of app_1\n"
"cartridge start app_1.router_1 # start single instance"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:101
msgid "To stop one or more running instances use:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:139
msgid "cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"These options from `start` command are supported\n"
"    --run_dir DIR\n"
"    --cfg FILE"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:112
msgid "Misc"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:115
msgid "Running end-to-end tests"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:121
msgid "vagrant up\n"
"vagrant ssh 1_10 < test/end-to-end.sh\n"
"vagrant halt"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:5
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:7
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:11
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:16
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:19
msgid "The Tarantool rocks allow for connecting to SQL servers and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:30
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:38
msgid "MySQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:40
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:47
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server instance. After that, one can pass any MySQL statement to the server instance and receive results, including multiple result sets."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:55
#: ../doc/reference/reference_rock/dbms.rst:408
msgid "Check the instructions for `downloading and installing a binary package <http://tarantool.org/download.html>`_ that apply for the environment where Tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:61
#: ../doc/reference/reference_rock/dbms.rst:414
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:65
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:69
#: ../doc/reference/reference_rock/dbms.rst:422
msgid "With LuaRocks"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:71
#: ../doc/reference/reference_rock/dbms.rst:424
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:84
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:90
#: ../doc/reference/reference_rock/dbms.rst:443
msgid "With GitHub"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:92
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:94
msgid "$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:101
#: ../doc/reference/reference_rock/dbms.rst:454
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:107
#: ../doc/reference/reference_rock/dbms.rst:460
msgid "Connecting"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:109
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:116
#: ../doc/reference/reference_rock/dbms.rst:469
msgid "Now, say:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:123
#: ../doc/reference/reference_rock/dbms.rst:476
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:125
#: ../doc/reference/reference_rock/dbms.rst:478
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:126
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:127
#: ../doc/reference/reference_rock/dbms.rst:480
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:128
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:129
#: ../doc/reference/reference_rock/dbms.rst:482
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:130
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:132
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:139
#: ../doc/reference/reference_rock/dbms.rst:486
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:141
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:157
#: ../doc/reference/reference_rock/dbms.rst:498
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:159
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:175
#: ../doc/reference/reference_rock/dbms.rst:517
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:179
#: ../doc/reference/reference_rock/dbms.rst:521
msgid "How to ping"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:181
#: ../doc/reference/reference_rock/dbms.rst:523
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:220
#: ../doc/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:190
#: ../doc/reference/reference_rock/dbms.rst:532
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:199
#: ../doc/reference/reference_rock/dbms.rst:541
msgid "Executing a statement"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:201
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:240
#: ../doc/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:208
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:214
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:227
#: ../doc/reference/reference_rock/dbms.rst:568
msgid "Closing connection"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:229
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:268
#: ../doc/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:238
#: ../doc/reference/reference_rock/dbms.rst:579
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:244
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:251
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:255
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.1\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.1.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.1.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:336
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:339
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:347
msgid "Create a Lua function that will connect to the MySQL server instance, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:352
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:376
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:383
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:385
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:390
msgid "$ sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:394
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:400
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server instance. After that, one can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:418
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:437
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:445
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:447
msgid "$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:462
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "pg = require('pg')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:479
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:481
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:484
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:488
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:500
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:543
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:550
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any placeholders ($1 $2 $3 etc.) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:556
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:570
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:585
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:592
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:596
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.0\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.0.4.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.0.4-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:670
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:673
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:681
msgid "Create a Lua function that will connect to a PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:686
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:711
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:5
msgid "Module `expirationd`"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:7
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at the source code of ``expirationd``, which Tarantool supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:13
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:21
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:26
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:37
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:42
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:56
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:66
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:71
msgid "At this point, if the above explanation is worthwhile, it is clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and -- whenever it finds a tuple that has expired -- deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:80
msgid "For those who like to see things run, here are the exact steps to get ``expirationd`` through the test."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:83
msgid "Get ``expirationd.lua``. There are standard ways -- it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ -- but for this purpose just copy the contents of ``expirationd.lua`` to a directory on the Lua path (type ``print(package.path)`` to see the Lua path)."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:88
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:89
msgid "Execute these requests:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:91
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:114
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:119
msgid "The function which will be supplied to ``expirationd`` is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:124
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The require_ function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel, but is on the Lua path (``package.path``) or the C path (``package.cpath``). After the Lua variable expd has been assigned the value of the ``expirationd`` module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:133
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:138
msgid "After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the ``is_tuple_expired()`` function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:145
msgid "Of course, ``expirationd`` can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code. Particularly important are ``{options}`` which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:150
msgid "``force`` (boolean) -- run task even on replica. Default: ``force=false`` so ordinarily ``expirationd`` ignores replicas."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:152
msgid "``tuples_per_iteration`` (integer) -- number of tuples that will be checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:155
msgid "``full_scan_time`` (number) -- number of seconds required for full index scan Default: ``full_scan_time=3600``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:157
msgid "``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:160
msgid "``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. (The size of a vinyl space cannot be easily calculated, so on the first iteration it will be the \"assumed\" size, on the second iteration it will be \"assumed\" times \"factor\", on the third iteration it will be \"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:3
msgid "Rocks reference"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:5
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:5
msgid "Module `membership`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:7
msgid "This module is a ``membership`` library for Tarantool based on a gossip protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:9
msgid "This library builds a mesh from multiple Tarantool instances. The mesh monitors itself, helps members discover everyone else in the group and get notified about their status changes with low latency. It is built upon the ideas from Consul or, more precisely, the SWIM algorithm."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:14
msgid "The ``membership`` module works over UDP protocol and can operate even before the ``box.cfg`` initialization."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:21
msgid "Member data structure"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:23
msgid "A member is represented by the table with the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:25
msgid "``uri`` (string) is a Uniform Resource Identifier."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:26
msgid "``status`` (string) is a string that takes one of the values below."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:28
msgid "``alive``: a member that replies to ping-messages is ``alive`` and well."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:29
msgid "``suspect``: if any member in the group cannot get a reply from any other member, the first member asks three other ``alive`` members to send a ping-message to the member in question. If there is no response, the latter becomes a ``suspect``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:33
msgid "``dead``: a ``suspect`` becomes ``dead`` after a timeout."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:34
msgid "``left``: a member gets the ``left`` status after executing the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:37
msgid "The gossip protocol guarantees that every member in the group becomes aware of any status change in two communication cycles."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:40
msgid "``incarnation`` (number) is a value incremented every time the instance is becomes a ``suspect``, ``dead``, or updates its payload."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:42
msgid "``payload`` (table) is auxiliary data that can be used by various modules."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:43
msgid "``timestamp`` (number) is a value of ``fiber.time64()`` which:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:45
msgid "corresponds to the last update of ``status`` or ``incarnation``;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:46
msgid "is always local;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:47
msgid "does not depend on other members' clock setting."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:49
msgid "Below is an example of the table:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:51
msgid "tarantool> membership.myself()\n"
"---\n"
"uri: localhost:33001\n"
"status: alive\n"
"incarnation: 1\n"
"payload:\n"
"    uuid: 2d00c500-2570-4019-bfcc-ab25e5096b73\n"
"timestamp: 1522427330993752\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:67
#: ../doc/reference/reference_rock/vshard/index.rst:1173
msgid "API reference"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:69
msgid "Below is a list of ``membership``'s common, encryption, subscription functions, and options."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:80
msgid "Common functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid ":ref:`init(advertise_host, port) <membership-init>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid "Initialize the ``membership`` module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid ":ref:`myself() <membership-myself>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid "Get the member data structure of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid ":ref:`get_member(uri) <membership-get-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid "Get the member data structure for a given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid ":ref:`members() <membership-members>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid "Obtain a table with all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid ":ref:`pairs() <membership-pairs>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid "Shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid ":ref:`add_member(uri) <membership-add-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid "Add a member to the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid ":ref:`probe_uri(uri) <membership-probe-uri>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid "Check if the member is in the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid ":ref:`broadcast() <membership-broadcast>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid "Discover members in LAN by sending a UDP broadcast message."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid ":ref:`set_payload(key, value) <membership-set-payload>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid "Update ``myself().payload`` and disseminate it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid ":ref:`leave() <membership-leave>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid "Gracefully leave the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid ":ref:`is_encrypted() <membership-is-encrypted>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid "Check if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:115
msgid "Encryption functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid ":ref:`set_encryption_key(key) <membership-set-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid "Set the key for low-level message encryption."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid ":ref:`get_encryption_key() <membership-get-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid "Retrieve the encryption key in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:123
msgid "Subscription functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid ":ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid "Subscribe for the members table updates."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid ":ref:`unsubscribe() <membership-unsubscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid "Remove the subscription."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:131
msgid "Options"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid ":ref:`PROTOCOL_PERIOD_SECONDS <membership-protocol_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid "Direct ping period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid ":ref:`ACK_TIMEOUT_SECONDS <membership-ack_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid "ACK message wait time."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid ":ref:`ANTI_ENTROPY_PERIOD_SECONDS <member-anti_entropy_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid "Anti-entropy synchronization period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid ":ref:`SUSPECT_TIMEOUT_SECONDS <membership-suspect_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid "Timeout to mark a ``suspect`` ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid ":ref:`NUM_FAILURE_DETECTION_SUBGROUPS <membership-num_fail_detect_subgr>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid "Number of members to ping a ``suspect`` indirectly."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:152
msgid "Common functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:158
msgid "Initialize the ``membership`` module. This binds a UDP socket to ``0.0.0.0:<port>``, sets the ``advertise_uri`` parameter to ``<advertise_host>:<port>``, and ``incarnation`` to ``1``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:162
msgid "The ``init()`` function can be called several times, the old socket will be closed and a new one opened."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:165
msgid "If the ``advertise_uri`` changes during the next ``init()``, the old URI is considered ``DEAD``. In order to leave the group gracefully, use the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:169
msgid "a hostname or IP address to advertise to other members"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:170
msgid "a UDP port to bind"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:171
#: ../doc/reference/reference_rock/membership.rst:267
#: ../doc/reference/reference_rock/membership.rst:277
msgid "``true``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "raises"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:173
msgid "socket bind error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:179
msgid "the :ref:`member data structure <membership-datastruct>` of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:187
msgid "the given member's ``advertise_uri``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:188
msgid "the :ref:`member data structure <membership-datastruct>` of the instance with the given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:196
msgid "Obtain all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:198
msgid "Editing this table has no effect."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:200
msgid "a table with URIs as keys and corresponding :ref:`member data structures <membership-datastruct>` as values."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:209
msgid "A shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:211
msgid "Lua iterator"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:213
msgid "It can be used in the following way:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:215
msgid "for uri, member in memberhip.pairs()\n"
"  -- do something\n"
"end"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:225
msgid "Add a member with the given URI to the group and propagate this event to other members. Adding a member to a single instance is enough as everybody else in the group will receive the update with time. It does not matter who adds whom."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:230
msgid "the ``advertise_uri`` of the member to add"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:231
msgid "``true`` or ``nil`` in case of an error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:233
msgid "parse error if the URI cannot be parsed"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:239
msgid "Send a message to a member to make sure it is in the group. If the member is ``alive`` but not in the group, it is added. If it already is in the group, nothing happens."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:242
msgid "the ``advertise_uri`` of the member to ping"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:243
msgid "``true`` if the member responds within 0.2 seconds, otherwise ``no response``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:245
msgid "``ping was not sent`` if the hostname could not be resolved"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:251
msgid "Discover members in local network by sending a UDP broadcast message to all networks discovered by a ``getifaddrs()`` C call."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:254
msgid "``true`` if broadcast was sent, ``false`` if ``getaddrinfo()`` fails."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:261
msgid "Update ``myself().payload`` and disseminate it along with the member status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:263
msgid "Increments ``incarnation``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:265
msgid "a key to set in payload table"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:266
msgid "auxiliary data"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:274
msgid "Gracefully leave the ``membership`` group. The node will be marked with the ``left`` status and no other members will ever try to reconnect it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:284
msgid "``true`` if encryption is enabled, ``false`` otherwise."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:287
msgid "Encryption functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:293
msgid "Set the key used for low-level message encryption. The key is either trimmed or padded automatically to be exactly 32 bytes. If the ``key`` value is ``nil``, the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:297
msgid "The encryption is handled by the ``crypto.cipher.aes256.cbc`` Tarantool module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:300
msgid "For proper communication, all members must be configured to use the same encryption key. Otherwise, members report either ``dead`` or ``non-decryptable`` in their status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:304
msgid "encryption key"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:305
#: ../doc/reference/reference_rock/membership.rst:336
msgid "``nil``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:311
msgid "Retrieve the encryption key that is currently in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:313
msgid "encryption key or ``nil`` if the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:316
msgid "Subscription functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:322
msgid "Subscribe for updates in the members table."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:324
msgid "a ``fiber.cond`` object broadcasted whenever the members table changes."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:325
msgid "object"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:331
msgid "Remove subscription on ``cond`` obtained by the :ref:`subscribe() function <membership-subscribe>`."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:333
msgid "The ``cond``'s validity is not checked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:335
msgid "the ``fiber.cond`` object obtained from :ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:338
msgid "Below is a list of ``membership`` options. They can be set as follows:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:340
msgid "options = require('membership.options')\n"
"options.<option> = <value>"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:349
msgid "Period of sending direct pings. Denoted as ``T'`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:355
msgid "Time to wait for ACK message after a ping. If a member is late to reply, the indirect ping algorithm is invoked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:362
msgid "Period to perform the anti-entropy synchronization algorithm of the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:369
msgid "Timeout to mark ``suspect`` members as ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:375
msgid "Number of members to try pinging a ``suspect`` indirectly. Denoted as ``k`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:5
msgid "Module `shard`"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:9
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server instance on each node. With this arrangement, each instance is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:14
msgid "The Tarantool `shard` module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:18
msgid "First some terminology:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:21
msgid "**Consistent hash**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:23
msgid "The `shard` module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the `shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:30
msgid "**Instance**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:32
msgid "A currently-running in-memory copy of the Tarantool server, sometimes called a \"server instance\". Usually each shard is associated with one instance, or, if both sharding and replicating are going on, each shard is associated with one replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:36
msgid "**Queue**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:38
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on every node. The `shard` module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:44
msgid "**Redundancy**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:46
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:47
#: ../doc/reference/reference_rock/vshard/index.rst:2088
msgid "**Replica**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:49
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:50
#: ../doc/reference/reference_rock/vshard/index.rst:2077
msgid "**Replica set**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:52
msgid "Often a single shard is associated with a single instance; however, often the shard is replicated. When a shard is replicated, the multiple instances (\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:56
msgid "**Replicated data**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:58
msgid "A complete copy of the data. The `shard` module handles both sharding and replication. One shard can contain one or more replicated data copies. When a write occurs, the write is attempted on every replicated data copy in turn. The `shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:62
msgid "**Shard**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:64
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:68
msgid "**Zone**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:70
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single Tarantool-server instance. A shard's replicated data copies should be in different zones."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:75
msgid "The `shard` package is distributed separately from the main `tarantool` package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:78
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:80
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:84
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:86
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:90
msgid "or download from GitHub `tarantool/shard` and use the Lua files as described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:93
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:95
msgid "The most important function is:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:102
msgid "This must be called for every shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:104
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:106
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:107
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:108
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:109
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:110
msgid "`binary` (a port number that this host is listening on, on the current host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:113
msgid "Possible errors:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:115
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:116
msgid "the servers must be alive;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:117
msgid "two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:121
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:123
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:124
msgid "The number of instances is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:125
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:127
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:148
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:150
msgid "This describes three shards. Each shard has two replicated data copies. Since the number of servers is 7, and the number of replicated data copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:155
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:178
msgid "Every data-access function in the `box` module has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:218
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:191
msgid "For example, to insert in table T in a sharded database you simply say ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:194
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:196
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:235
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:208
msgid "The user must add an `operation_id`. For details of queued data-access functions, and of maintenance-related functions, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:214
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:216
msgid "There is only one shard, and that shard contains only one replicated data copy. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:222
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:249
msgid "If you cut and paste the above, then the result, showing only the requests and responses for `shard.init` and `shard.tester`, should look approximately like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:253
msgid "<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:278
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:280
msgid "There are two shards, and each shard contains one replicated data copy. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:285
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:287
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:316
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:318
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:347
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:351
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:353
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:360
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the `shard` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:363
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:3
msgid "Module `tdb`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:5
msgid "The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:11
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:14
msgid "$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:21
msgid "To initiate ``tdb`` within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:24
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:29
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:34
msgid "Debugger Commands"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:38
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:37
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid ":codebold:`c`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:48
msgid ":codebold:`e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:44
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:55
msgid ":codebold:`f`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:54
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid ":codebold:`n`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid ":codebold:`h`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:68
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:67
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid ":codebold:`q`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid "Quit immediately."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:75
msgid "Example Session"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:77
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:79
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:87
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:89
msgid "$ tarantool example.lua"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:93
#: ../doc/reference/reference_rock/tdb.rst:118
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:132
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:105
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:109
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:157
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:140
msgid "Another debugger example can be found `here <https://github.com/sulverus/tdb>`_."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:5
msgid "Module `vshard`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:11
msgid "Summary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:13
msgid "The ``vshard`` module introduces the sharding feature, which enables horizontal scaling in Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:16
msgid "While a project is growing, scaling the databases may become the most challenging issue. Once a single server cannot withstand the load, scaling methods should be applied."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:20
msgid "There are two different approaches for scaling data, `vertical and horizontal scaling <https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:23
msgid "*Vertical scaling* implies that the hardware capacities of a single server would be increased."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:26
msgid "*Horizontal scaling* implies that a dataset is partitioned and distributed over multiple servers. In case new servers are added, the dataset is re-distributed evenly across all servers, both the original and new ones."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:30
msgid "Sharding is a database architecture that allows for horizontal scaling."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:32
msgid "With ``vshard``, the tuples of a dataset are distributed across multiple nodes, with a Tarantool database server instance on each node. Each instance handles only a subset of the total data, so larger loads can be handled by simply adding more servers. The initial dataset is partitioned into multiple parts, so each part is stored on a separate server. The dataset is partitioned using sharding keys."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:38
msgid "The ``vshard`` module is based on the concept of virtual buckets, where a tuple set is partitioned into a large number of abstract virtual nodes (virtual buckets, or buckets) rather than into a smaller number of physical nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:42
msgid "Hashing a sharding key into a large number of virtual buckets allows seamlessly changing the number of servers in the cluster. The rebalancing mechanism distributes buckets evenly among all shards in case some servers were added or removed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:46
msgid "The buckets have states, so it is easy to monitor the server states. For example, a server instance is active and available for all types of requests, or a failover occurred and the instance accepts only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:50
msgid "The ``vshard`` module provides analogs for the data-manipulation functions of the Tarantool ``box`` library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:59
msgid "The ``vshard`` module is distributed separately from the main Tarantool package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:62
msgid "$ tarantoolctl rocks install vshard"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:68
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:74
msgid "Quick start"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:76
msgid "The ``vshard/example/`` directory includes a pre-configured development cluster of 1 ``router`` and 2 replica sets of 2 nodes (2 ``storages``) each, making 5 Tarantool instances in total:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:80
msgid "``router_1`` – a ``router`` instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:81
msgid "``storage_1_a`` – a ``storage`` instance, the master of the first replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:82
msgid "``storage_1_b`` – a ``storage`` instance, the replica of the first replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:83
msgid "``storage_2_a`` – a ``storage`` instance, the master of the second replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:84
msgid "``storage_2_b`` – a ``storage`` instance, the replica of the second replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:86
msgid "All instances are managed using the ``tarantoolctl`` utility which comes with Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:88
msgid "Change the directory to ``example/`` and use make to run the development cluster:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:90
msgid "$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:128
msgid "Some ``tarantoolctl`` commands:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:130
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:131
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:133
msgid "The full list of ``tarantoolctl`` commands for managing Tarantool instances is available in the :ref:`tarantoolctl reference <tarantoolctl>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:136
msgid "Essential make commands you need to know:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:138
msgid "``make start`` – start all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:139
msgid "``make stop`` – stop all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:140
msgid "``make logcat`` – show logs from all instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:141
msgid "``make enter`` – enter the admin console on router_1"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:142
msgid "``make clean`` – clean up all persistent data"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:143
msgid "``make test`` – run the test suite (you can also run test-run.py in the test directory)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:144
msgid "``make`` – execute ``make stop``, ``make clean``, ``make start`` and ``make enter``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:146
msgid "For example, to start all instances, use ``make start``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:148
msgid "$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:158
msgid "To perform commands in the admin console, use the ``router`` API:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:160
msgid "unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:194
msgid "Architecture"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:196
msgid "A sharded cluster in Tarantool consists of storages, routers, and a rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:198
msgid "A **storage** is a node storing a subset of a dataset. Multiple replicated storages are deployed as replica sets to provide redundancy (a replica set can also be called a shard)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:202
msgid "A **router** is a standalone software component that routes read and write requests from the client application to shards."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:205
msgid "A **rebalancer** is an internal component that distributes the dataset among all shards evenly in case some servers are added or removed. It also balances the load considering the capacities of existing replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:216
msgid "Storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:218
msgid "**Storage** is a node storing a subset of a dataset. Multiple replicated storages comprise a replica set. Each storage in a replica set has a role, **master** or **replica**. A master processes read and write requests. A replica processes read requests but cannot process write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:230
msgid "Virtual buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:232
msgid "The sharded dataset is partitioned into a large number of abstract nodes called **virtual buckets** (further referred to as **buckets**)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:235
msgid "The dataset is partitioned using the sharding key (or **bucket id**, in Tarantool terminology). Bucket id is a number from 1 to N, where N is the total number of buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:242
msgid "Each replica set stores a unique subset of buckets. One bucket cannot belong to multiple replica sets at a time."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:248
msgid "The total number of buckets is determined by the administrator who sets up the initial cluster configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:251
msgid "Every Tarantool space you plan to shard must have a bucket id field indexed by the bucket id ``index``. Spaces without the bucket id indexes don’t participate in sharding but can be used as regular spaces. By default, the name of the index coincides with the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:260
msgid "Migration of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:262
msgid "A **rebalancer** is a background rebalancing process that ensures an even distribution of buckets across the shards. During rebalancing, buckets are being migrated among replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:266
msgid "A replica set from which the bucket is being migrated is called a **source** ; a target replica set to which the bucket is being migrated is called a **destination**."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:269
msgid "A **replica set lock** makes a replica set invisible to the rebalancer. A locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:272
msgid "While a bucket is being migrated, it can have different states:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:274
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:275
msgid "PINNED – the bucket is locked for migrating to another replica set. Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:277
msgid "SENDING – the bucket is currently being copied to the destination replica set; read requests to the source replica set are still processed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:279
msgid "RECEIVING – the bucket is currently being filled; all requests to it are rejected."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:280
msgid "SENT – the bucket was migrated to the destination replica set. The ``router`` uses the SENT state to calculate the new location of the bucket. A bucket in the SENT state goes to the GARBAGE state automatically after BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:284
msgid "GARBAGE – the bucket was already migrated to the destination replica set during rebalancing; or the bucket was initially in the RECEIVING state, but some error occurred during the migration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:288
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:293
msgid "Migration is performed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:295
msgid "At the destination replica set, a new bucket is created and assigned the RECEIVING state, the data copying starts, and the bucket rejects all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:297
msgid "The source bucket in the source replica set is assigned the SENDING state, and the bucket continues to process read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:299
msgid "Once the data is copied, the bucket on the source replica set is assigned the SENT and it starts rejecting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:301
msgid "The bucket on the destination replica set is assigned the ACTIVE state and starts accepting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:308
msgid "The `_bucket` system space"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:310
msgid "The ``_bucket`` system space of each replica set stores the ids of buckets present in the replica set. The space contains the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:313
msgid "``bucket`` – bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:314
msgid "``status`` – state of the bucket"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:315
msgid "``destination`` – UUID of the destination replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:317
msgid "An example of ``_bucket.select{}``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:319
msgid "---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:326
msgid "Once the bucket is migrated, the destination replica set identified by UUID is filled in the table. While the bucket is still located on the source replica set, the value of the destination replica set UUID is equal to ``NULL``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:334
msgid "Router"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:336
msgid "All requests from the application come to the sharded cluster through a ``router``. The ``router`` keeps the topology of a sharded cluster transparent for the application, thus keeping the application unaware of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:340
msgid "the number and location of shards,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:341
msgid "data rebalancing process,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:342
msgid "the fact and the process of a failover that occurred after a replica's failure."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:344
msgid "The ``router`` does not have a persistent state, nor does it store the cluster topology or balance the data. The ``router`` is a standalone software component that can run in the storage layer or application layer depending on the application features."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:352
msgid "The routing table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:354
msgid "А routing table on the ``router`` stores the map of all bucket ids to replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:357
msgid "The ``router`` keeps a persistent pool of connections to all the storages that are created at startup. This helps prevent configuration errors. Once the connection pool is created, the ``router`` caches the current state of the routing table in order to speed up routing. If a bucket migrated to another ``storage`` after rebalancing, or a failover occurred and caused one of the shards switching to another replica, the ``discovery fiber`` on the ``router`` updates the routing table automatically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:364
msgid "As the bucket id is explicitly indicated both in the data and in the mapping table on the ``router``, the data is consistent regardless of the application logic. It also makes rebalancing transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:372
msgid "Processing requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:374
msgid "Requests to the database can be performed by the application or using stored procedures. Either way, the bucket id should be explicitly specified in the request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:377
msgid "All requests are forwarded to the ``router`` first. The only operation supported by the ``router`` is ``call``. The operation is performed via the ``vshard.router.call()`` function:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:381
msgid "result = vshard.router.call(<bucket_id>, <mode>, <function_name>, {<argument_list>}, {<opts>})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:385
msgid "Requests are processed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:387
msgid "The ``router`` uses the bucket id to search for a replica set with the corresponding bucket in the routing table."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:390
msgid "If the map of the bucket id to the replica set is not known to the ``router`` (the discovery fiber hasn’t filled the table yet), the ``router`` makes requests to all ``storages`` to find out where the bucket is located."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:393
msgid "Once the bucket is located, the shard checks:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:395
msgid "whether the bucket is stored in the ``_bucket`` system space of the replica set;"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:396
msgid "whether the bucket is ACTIVE or PINNED (for a read request, it can also be SENDING)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:397
msgid "If all the checks succeed, the request is executed. Otherwise, it is terminated with the error: ``“wrong bucket”``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:404
msgid "Administration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:410
msgid "Configuring a sharded cluster"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:412
msgid "A minimal viable sharded cluster should consist of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:414
msgid "one or more replica sets, each containing two or more ``storage`` instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:415
msgid "one or more ``router`` instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:417
msgid "The number of ``storage`` instances in a replica set defines the redundancy factor of the data. The recommended value is 3 or more. The number of ``router`` instances is not limited, because routers are completely stateless. We recommend increasing the number of routers when an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:422
msgid "``vshard`` supports multiple ``router`` instances on a single Tarantool instance. Each ``router`` can be connected to any ``vshard`` cluster. Multiple ``router`` instances can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:426
msgid "As the ``router`` and ``storage`` applications perform completely different sets of functions, they should be deployed to different Tarantool instances. Although it is technically possible to place the router application on every ``storage`` node, this approach is highly discouraged and should be avoided on production deployments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:431
msgid "All ``storage`` instances can be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:434
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:436
msgid "$ tarantoolctl instance_name"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:440
msgid "All ``router`` instances can also be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:443
msgid "All cluster nodes must share a common topology. An administrator must ensure that the configurations are identical. We suggest using a configuration management tool like Ansible or Puppet to deploy the cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:447
msgid "Sharding is not integrated into any system for centralized configuration management. It is expected that the application itself is responsible for interacting with such a system and passing the sharding parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:455
msgid "Sample configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:457
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:459
msgid "local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:497
msgid "This cluster includes one ``router`` instance and two ``storage`` instances. Each ``storage`` instance includes one master and one replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:500
msgid "The sharding field defines the logical topology of a sharded Tarantool cluster. All the other fields are passed to ``box.cfg()`` as they are, without modifications. See the :ref:`Configuration reference <vshard-config-reference>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:504
msgid "On routers call ``vshard.router.cfg(cfg)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:506
msgid "cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:514
msgid "On storages call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:516
msgid "-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:528
msgid "``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures the listen port and replication parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:531
msgid "See ``router.lua`` and ``storage.lua`` in the ``vshard/example`` directory for a sample configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:538
msgid "Replica weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:540
msgid "The ``router`` sends all requests to the master instance only. Setting replica weights allows sending read requests not only to the master instance, but to any available replica that is the 'nearest' to the ``router``. Weights are used to define distances between replicas within a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:545
msgid "Weights can be used, for example, to define the physical distance between the ``router`` and each replica in each replica set. In such a case read requests are sent to the nearest replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:549
msgid "Setting weights can also help to define the most powerful replicas: the ones that can process the largest number of requests per second."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:552
msgid "The idea is to specify the zone for every ``router`` and every replica, therefore filling a matrix of relative zone weights. This approach allows setting different weights in different zones for the same replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:556
msgid "To set weights, use the zone attribute for each replica during configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:558
msgid "local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:573
msgid "Then, specify relative weights for each zone pair in the weights parameter of ``vshard.router.cfg``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:576
msgid "weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- routers of the 1st zone see the weight of the 2nd zone as 1\n"
"        [3] = 2, -- routers of the 1st zone see the weight of the 3rd zone as 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- routers of the 3rd zone see the weight of the 2nd zone as 200. Mind that it is not equal to the weight of the 2nd zone = 2 visible from the 1st zone\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:605
msgid "Replica set weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:607
msgid "A replica set weight is not the same as the replica weight. The weight of a replica set defines the capacity of the replica set: the larger the weight, the more buckets the replica set can store. The total size of all sharded spaces in the replica set is also its capacity metric."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:612
msgid "You can consider replica set weights as the relative amount of data within a replica set. For example, if ``replicaset_1 = 100``, and ``replicaset_2 = 200``, the second replica set stores twice as many buckets as the first one. By default, all weights of all replica sets are equal."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:617
msgid "You can use weights, for example, to store the prevailing amount of data on a replica set with more memory space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:624
msgid "Rebalancing process"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:626
msgid "There is an **etalon number** of buckets for a replica set. (Etalon in this context means \"ideal\".) If there is no deviation from this number in the whole replica set, then the buckets are distributed evenly."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:631
msgid "The etalon number is calculated automatically considering the number of buckets in the cluster and weights of the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:634
msgid "For example: The user specified the number of buckets is 3000, and weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd replica set – 500, 3rd replica set – 1500."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:639
msgid "This approach allows assigning a zero weight to a replica set, which initiates migration of its buckets to the remaining cluster nodes. It also allows adding a new zero-load replica set, which initiates migration of the buckets from the loaded replica sets to the zero-load replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:646
msgid "A new zero-load replica set should be assigned a weight for rebalancing to start."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:648
msgid "The ``rebalancer`` wakes up periodically and redistributes data from the most loaded nodes to less loaded nodes. Rebalancing starts if the disbalance threshold of a replica set exceeds a disbalance threshold specified in the configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:652
msgid "The disbalance threshold is calculated as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:654
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:658
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:660
msgid "The configuration should be updated on all the ``routers`` first, and then on all the ``storages``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:662
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:663
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:664
msgid "If a migrated bucket is requested, ``router`` receives an error code containing information about the new location of the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:667
msgid "At this time, the new shard is already present in the ``router``'s pool of connections, so redirection is transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:674
msgid "Replica set lock and bucket pin"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:676
msgid "A replica set lock makes a replica set invisible to the ``rebalancer``: a locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:679
msgid "A bucket pin blocks a specific bucket from migrating: a pinned bucket stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:682
msgid "Pinning all replica set buckets is not equivalent to locking a replica set. Even if you pin all buckets, a non-locked replica set can still receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:685
msgid "Replica set lock is helpful, for example, to separate a replica set from production replica sets for testing, or to preserve some application metadata that must not be sharded for a while. A bucket pin is used for similar cases but in a smaller scope."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:690
msgid "By both locking a replica set and pinning all buckets, one can isolate an entire replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:693
msgid "Locked replica sets and pinned buckets affect the rebalancing algorithm as the ``rebalancer`` must ignore locked replica sets and consider pinned buckets when attempting to reach the best possible balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:697
msgid "The issue is not trivial as a user can pin too many buckets to a replica set, so a perfect balance becomes unreachable. For example, consider the following cluster (assume all replica set weights are equal to 1)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:701
msgid "The initial configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:703
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:708
msgid "Adding a new replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:710
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:716
msgid "The perfect balance would be ``100 - 100 - 100``, which is impossible since the ``rs2`` replica set has 120 pinned buckets. The best possible balance here is the following:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:720
msgid "rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:726
msgid "The ``rebalancer`` moved as many buckets as possible from ``rs2`` to decrease the disbalance. At the same time it respected equal weights of ``rs1`` and ``rs3``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:729
msgid "The algorithms for implementing locks and pins are completely different, although they look similar in terms of functionality."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:736
msgid "Replica set lock and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:738
msgid "Locked replica sets simply do not participate in rebalancing. This means that even if the actual total number of buckets is not equal to the etalon number, the disbalance cannot be fixed due to the lock. When the rebalancer detects that one of the replica sets is locked, it recalculates the etalon number of buckets of the non-locked replica sets as if the locked replica set and its buckets did not exist at all."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:749
msgid "Bucket pin and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:751
msgid "Rebalancing replica sets with pinned buckets requires a more complex algorithm. Here pinned_count[o] is the number of pinned buckets, and ``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:755
msgid "The ``rebalancer`` calculates the etalon number of buckets as if all buckets were not pinned. Then the rebalancer checks each replica set and compares the etalon number of buckets with the number of pinned buckets in a replica set. If ``pinned_count < etalon_count``, non-locked replica sets (at this point all locked replica sets already are filtered out) with pinned buckets can receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:761
msgid "If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as the ``rebalancer`` cannot move pinned buckets out of this replica set. In such a case the etalon number is updated and set equal to the number of pinned buckets. The replica sets with ``pinned_count > etalon_count`` are not processed by the ``rebalancer``, and the number of pinned buckets is subtracted from the total number of buckets. The rebalancer tries to move out as many buckets as possible from such replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:768
msgid "This procedure is restarted from step 1 for replica sets with ``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` on all replica sets. The procedure is also restarted when the total number of buckets is changed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:773
msgid "Here is the pseudocode for the algorithm:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:775
msgid "function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:799
msgid "The complexity of the algorithm is ``O(N^2)``, where N is the number of replica sets. On each step, the algorithm either finishes the calculation, or ignores at least one new replica set overloaded with the pinned buckets, and updates the etalon number of buckets on other replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:808
msgid "Bucket ref"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:810
msgid "Bucket ref is an in-memory counter that is similar to the :ref:`bucket pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:813
msgid "Bucket ref is not persistent. Refs are intended for forbidding bucket transfer during request execution, but on restart all requests are dropped."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:816
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:818
msgid "If a bucket has RW refs, it can not be moved. However, when the rebalancer needs it to be sent, it locks the bucket for new write requests, waits until all current requests are finished, and then sends the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:823
msgid "If a bucket has RO refs, it can be sent, but cannot be dropped. Such a bucket can even enter GARBAGE or SENT state, but its data is kept until the last reader is gone."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:827
msgid "A single bucket can have both RO and RW refs."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:829
msgid "Bucket ref is countable."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:831
msgid "The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` methods are called automatically when :ref:`vshard.router.call() <router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you should explicitly call the ``bucket_ref()`` method inside the function. Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, otherwise the bucket cannot be moved from the storage until the instance restart."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:839
msgid "To see how many refs there are for a bucket, use :ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:845
#: ../doc/reference/reference_rock/vshard/index.rst:1857
msgid "vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:861
msgid "Defining spaces"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:863
msgid "Spaces should be defined within a storage application using ``box.once()``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:866
msgid "box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:900
msgid "Bootstrapping and restarting a storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:902
msgid "If a replica set master fails, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:904
msgid "Switch one of the replicas into the master mode. This allows the new master to process all the incoming requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:906
msgid "Update the configuration of all the cluster members. This forwards all the requests to the new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:909
msgid "Monitoring the master and switching the instance modes can be handled by any external utility."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:912
msgid "To perform a scheduled downtime of a replica set master, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:914
msgid "Update the configuration of the master and wait for the replicas to get into sync. All the requests then are forwarded to a new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:916
msgid "Switch another instance into the master mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:917
#: ../doc/reference/reference_rock/vshard/index.rst:923
msgid "Update the configuration of all the nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:918
msgid "Shut down the old master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:920
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:922
msgid "Migrate all the buckets to the other cluster storages."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:924
msgid "Shut down the replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:926
msgid "In case a whole replica set fails, some part of the dataset becomes inaccessible. Meanwhile, the ``router`` tries to reconnect to the master of the failed replica set. This way, once the replica set is up and running again, the cluster is automatically restored."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:937
msgid "Searches for buckets, buckets recovery, and buckets rebalancing are performed automatically and do not require human intervention."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:940
msgid "Technically, there are multiple fibers responsible for different types of operations:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:943
msgid "a **discovery** fiber on the ``router`` searches for buckets in the background"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:944
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:945
msgid "a **garbage collector** fiber on each master ``storage`` removes the contents of buckets that were moved"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:947
msgid "a **bucket recovery** fiber on each master ``storage`` recovers buckets in the SENDING and RECEIVING states in case of reboot"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:949
msgid "a **rebalancer** on a single master ``storage`` among all replica sets executes the rebalancing process."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:952
msgid "See the :ref:`Rebalancing process <vshard-rebalancing>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:958
msgid "Garbage collector"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:960
msgid "A **garbage collector** fiber runs in the background on the master storages of each replica set. It starts deleting the contents of the bucket in the GARBAGE state part by part. Once the bucket is empty, its record is deleted from the ``_bucket`` system space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:969
msgid "Bucket recovery"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:971
msgid "A **bucket recovery** fiber runs on the master storages. It helps to recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:974
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:976
msgid "The system first searches for buckets in the SENDING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:977
msgid "If such a bucket is found, the system sends a request to the destination replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:979
msgid "If the bucket on the destination replica set is ACTIVE, the original bucket is deleted from the source node."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:982
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:988
msgid "Failover"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:990
msgid "A **failover** fiber runs on every ``router``. If a master of a replica set becomes unavailable, the failover fiber redirects read requests to the replicas. Write requests are rejected with an error until the master becomes available."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1006
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1007
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1008
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1009
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1010
msgid ":ref:`collect_bucket_garbage_interval <cfg_basic-collect_bucket_garbage_interval>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1011
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1012
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1013
msgid ":ref:`rebalancer_disbalance_threshold <cfg_basic-rebalancer_disbalance_threshold>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1014
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1020
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1022
#: ../doc/reference/reference_rock/vshard/index.rst:1033
msgid "Type: table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1030
msgid "A field defining the configuration of relative weights for each zone pair in a replica set. See the :ref:`Replica weights <vshard-replica-weights>` section."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1041
msgid "An index over the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1043
msgid "Type: non-empty string or non-negative integer"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1044
msgid "Default: coincides with the bucket id number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1051
msgid "The total number of buckets in a cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1053
msgid "This number should be several orders of magnitude larger than the potential number of cluster nodes, considering potential scaling out in the foreseeable future."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1058
msgid "If the estimated number of nodes is M, then the data set should be divided into 100M or even 1000M buckets, depending on the planned scaling out. This number is certainly greater than the potential number of cluster nodes in the system being designed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1063
msgid "Keep in mind that too many buckets can cause a need to allocate more memory to store routing information. On the other hand, an insufficient number of buckets can lead to decreased granularity when rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1067
#: ../doc/reference/reference_rock/vshard/index.rst:1077
#: ../doc/reference/reference_rock/vshard/index.rst:1099
#: ../doc/reference/reference_rock/vshard/index.rst:1114
#: ../doc/reference/reference_rock/vshard/index.rst:1135
msgid "Type: number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1068
msgid "Default: 3000"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1075
msgid "The interval between garbage collector actions, in seconds."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1085
msgid "If set to true, the Lua collectgarbage() function is called periodically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1088
msgid "Default: no"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1095
msgid "Timeout to wait for synchronization of the old master with replicas before demotion. Used when switching a master or when manually calling the ``sync()`` function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1107
msgid "A maximum bucket disbalance threshold, in percent. The threshold is calculated for each replica set using the following formula:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1110
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1122
msgid "The maximum number of buckets that can be received in parallel by a single replica set. This number must be limited, because when a new replica set is added to a cluster, the rebalancer sends a very large amount of buckets from the existing replica sets to the new replica set. This produces a heavy load on a new replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1129
msgid "Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on each respectively. When a new replica set is added, each replica set’s ``etalon_bucket_count`` becomes equal to 250. Rather than receiving all 250 buckets at once, the new replica set receives 100, 100 and 50 buckets sequentially."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1136
msgid "Default: 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1143
msgid "Replica set functions"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1145
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1146
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1152
msgid "A unique identifier of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1154
#: ../doc/reference/reference_rock/vshard/index.rst:1165
msgid "Type:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1155
msgid "Default:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1156
#: ../doc/reference/reference_rock/vshard/index.rst:1167
msgid "Dynamic:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1162
msgid "A weight of a replica set. See the :ref:`Replica set weights <vshard-replica-set-weights>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1179
msgid "Router public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1181
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1182
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1183
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1184
msgid ":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, {options}) <router_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1185
msgid ":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, {options}) <router_api-callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1186
msgid ":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, {options}) <router_api-callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1187
msgid ":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, {options}) <router_api-callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1188
msgid ":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, {options}) <router_api-callbro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1189
msgid ":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, {options}) <router_api-callbre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1190
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1191
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1192
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1193
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1194
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1195
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1196
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1197
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1198
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1199
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1200
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1201
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1207
msgid "Perform the initial cluster bootstrap and distribute all buckets across the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1214
msgid "Configure the database and start sharding for the specified ``router`` instance. See the :ref:`sample configuration <vshard-config-cluster-example>` above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1218
msgid "a configuration table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1224
msgid "Create a new router instance. ``vshard`` supports multiple routers in a single Tarantool instance. Each router can be connected to any ``vshard`` cluster, and multiple routers can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1228
msgid "A router created via ``vshard.router.new()`` works in the same way as a static router, but the method name is preceded by a colon (``vshard.router:method_name(...)``), while for a static router the method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1233
msgid "A static router can be obtained via the ``vshard.router.static()`` method and then used like a router created via the ``vshard.router.new()`` method."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1239
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1241
msgid "a router instance name. This name is used as a prefix in logs of the router and must be unique within the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1243
msgid "a configuration table. The :ref:`sample configuration <vshard-config-cluster-example>` is described above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1247
msgid "a router instance, if created successfully; otherwise, nil and an error object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1254
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id. See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1258
#: ../doc/reference/reference_rock/vshard/index.rst:1313
#: ../doc/reference/reference_rock/vshard/index.rst:1344
#: ../doc/reference/reference_rock/vshard/index.rst:1377
#: ../doc/reference/reference_rock/vshard/index.rst:1421
#: ../doc/reference/reference_rock/vshard/index.rst:1454
#: ../doc/reference/reference_rock/vshard/index.rst:1661
#: ../doc/reference/reference_rock/vshard/index.rst:1741
#: ../doc/reference/reference_rock/vshard/index.rst:1769
#: ../doc/reference/reference_rock/vshard/index.rst:1780
#: ../doc/reference/reference_rock/vshard/index.rst:1791
#: ../doc/reference/reference_rock/vshard/index.rst:1817
#: ../doc/reference/reference_rock/vshard/index.rst:1936
#: ../doc/reference/reference_rock/vshard/index.rst:1956
#: ../doc/reference/reference_rock/vshard/index.rst:1965
#: ../doc/reference/reference_rock/vshard/index.rst:1990
#: ../doc/reference/reference_rock/vshard/index.rst:2008
msgid "a bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1259
msgid "either a string = 'read'|'write', or a map with mode='read'|'write' and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1260
#: ../doc/reference/reference_rock/vshard/index.rst:1314
#: ../doc/reference/reference_rock/vshard/index.rst:1345
#: ../doc/reference/reference_rock/vshard/index.rst:1378
msgid "a function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1261
#: ../doc/reference/reference_rock/vshard/index.rst:1315
#: ../doc/reference/reference_rock/vshard/index.rst:1346
#: ../doc/reference/reference_rock/vshard/index.rst:1379
msgid "an array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1262
msgid "* ``timeout`` – a request timeout, in seconds. If the router cannot identify a   shard with the specified bucket_id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1264
msgid "``timeout`` – a request timeout, in seconds. If the router cannot identify a shard with the specified bucket_id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1268
msgid "The mode parameter has two possible forms: a string or a map. Examples of the string form are: 'read', 'write'. Examples of the map form are: {mode='read'}, {mode='write'}, {mode='read', prefer_replica=true}, {mode='read', balance=true}, {mode='read', prefer_replica=true, balance=true}. If 'write' is specified then the target is the master. If prefer_replica=true is specified then the preferred target is one of the replicas, but the target is the master if there is no conveniently available replica. It may be good to specify prefer_replica=true for functions which are expensive in terms of resource use, to avoid slowing down the master. If balance=true then there is load balancing -- reads are distributed over all the nodes in the replica set in round-robin fashion, with a preference for replicas if prefer_replica=true is also set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1282
#: ../doc/reference/reference_rock/vshard/index.rst:1324
#: ../doc/reference/reference_rock/vshard/index.rst:1355
#: ../doc/reference/reference_rock/vshard/index.rst:1388
msgid "The original return value of the executed function, or ``nil`` and error object. The error object has a type attribute equal to ``ShardingError`` or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, ``SocketError``, etc.)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1287
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for the error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1295
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1297
msgid "vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1307
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1316
#: ../doc/reference/reference_rock/vshard/index.rst:1347
#: ../doc/reference/reference_rock/vshard/index.rst:1380
#: ../doc/reference/reference_rock/vshard/index.rst:1577
#: ../doc/reference/reference_rock/vshard/index.rst:1598
#: ../doc/reference/reference_rock/vshard/index.rst:1617
#: ../doc/reference/reference_rock/vshard/index.rst:1639
msgid "* ``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a   shard with the bucket id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1318
#: ../doc/reference/reference_rock/vshard/index.rst:1349
#: ../doc/reference/reference_rock/vshard/index.rst:1382
#: ../doc/reference/reference_rock/vshard/index.rst:1579
#: ../doc/reference/reference_rock/vshard/index.rst:1600
#: ../doc/reference/reference_rock/vshard/index.rst:1619
#: ../doc/reference/reference_rock/vshard/index.rst:1641
msgid "``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a shard with the bucket id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1329
#: ../doc/reference/reference_rock/vshard/index.rst:1360
#: ../doc/reference/reference_rock/vshard/index.rst:1393
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for this error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1339
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-write mode (similar to calling vshard.router.call with mode='write'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1370
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'), with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1403
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true}."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1411
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true, prefer_replica=true}."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1419
msgid "Return the replica set object for the bucket with the specified bucket id value."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1423
#: ../doc/reference/reference_rock/vshard/index.rst:1438
msgid "a replica set object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1427
msgid "replicaset = vshard.router.route(123)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1435
msgid "Return all available replica set objects."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1437
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1442
msgid "replicaset = vshard.router.routeall()"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1450
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1452
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1459
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1467
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1469
msgid "the total number of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1476
#: ../doc/reference/reference_rock/vshard/index.rst:1755
msgid "Wait until the dataset is synchronized on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1478
#: ../doc/reference/reference_rock/vshard/index.rst:1757
msgid "a timeout, in seconds"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1480
#: ../doc/reference/reference_rock/vshard/index.rst:1759
msgid "``true`` if the dataset was synchronized successfully; or ``nil`` and ``err`` explaining why the dataset cannot be synchronized."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1487
msgid "Force wakeup of the bucket discovery fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1493
msgid "Return information about each instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1497
msgid "Replica set parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1499
msgid "replica set uuid"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1500
msgid "master instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1501
msgid "replica instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1503
msgid "Instance parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1505
msgid "``uri`` — URI of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1506
msgid "``uuid`` — UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1507
msgid "``status`` – status of the instance (``available``, ``unreachable``, ``missing``)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1508
msgid "``network_timeout`` – a timeout for the request. The value is updated automatically on each 10th successful request and each 2nd failed request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1511
msgid "Bucket parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1513
msgid "``available_ro`` – the number of buckets known to the ``router`` and available for read requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1514
msgid "``available_rw`` – the number of buckets known to the router and available for read and write requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1515
msgid "``unavailable`` – the number of buckets known to the ``router`` but unavailable for any requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1516
msgid "``unreachable`` – the number of buckets whose replica sets are not known to the ``router``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1520
msgid "tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1554
msgid "Return information about each bucket. Since a bucket map can be huge, only the required range of buckets can be specified."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1557
msgid "the offset in a bucket map of the first bucket to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1558
msgid "the maximum number of buckets to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1560
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1566
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1572
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1574
#: ../doc/reference/reference_rock/vshard/index.rst:1595
#: ../doc/reference/reference_rock/vshard/index.rst:1614
#: ../doc/reference/reference_rock/vshard/index.rst:1636
msgid "UUID of a replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1575
#: ../doc/reference/reference_rock/vshard/index.rst:1596
#: ../doc/reference/reference_rock/vshard/index.rst:1615
#: ../doc/reference/reference_rock/vshard/index.rst:1637
#: ../doc/reference/reference_rock/vshard/index.rst:1743
msgid "function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1576
#: ../doc/reference/reference_rock/vshard/index.rst:1597
#: ../doc/reference/reference_rock/vshard/index.rst:1616
#: ../doc/reference/reference_rock/vshard/index.rst:1638
#: ../doc/reference/reference_rock/vshard/index.rst:1744
msgid "array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1587
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1593
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1608
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments. It is recommended to call only read-only functions using ``replicaset.callro()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1627
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments, with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). It is recommended to call only read-only functions using ``replicaset.callre()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1649
msgid "Router internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1651
msgid ":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-bucket_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1657
msgid "Search for the bucket in the whole cluster. If the bucket is not found, it is likely that it does not exist. The bucket might also be moved during rebalancing and currently is in the RECEIVING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1667
msgid "Storage public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1669
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1670
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1671
msgid ":ref:`vshard.storage.call(bucket_id, mode, function_name, {argument_list}) <storage_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1672
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1673
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1674
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1675
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1676
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1677
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1678
msgid ":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-bucket_unref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1679
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1680
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1681
msgid ":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) <storage_api-find_garbage_bucket>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1682
msgid ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1683
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1684
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1685
msgid ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-rebalancing_is_in_progress>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1686
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1687
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1688
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1694
msgid "Configure the database and start sharding for the specified ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1697
msgid "a ``storage`` configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1698
msgid "UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1704
msgid "Return information about the storage instance in the following format:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1706
msgid "tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1739
msgid "Call the specified function on the current ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1742
msgid "a type of the function: 'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1748
msgid "The original return value of the executed function, or ``nil`` and error object."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1766
msgid "Pin a bucket to a replica set. A pinned bucket cannot be moved even if it breaks the cluster balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1771
msgid "``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be pinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1778
msgid "Return a pinned bucket back into the active state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1782
msgid "``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be unpinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1789
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1792
#: ../doc/reference/reference_rock/vshard/index.rst:1818
msgid "'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1794
msgid "``true`` if the bucket ref is created successfully; or ``nil`` and ``err`` explaining why the ref cannot be created"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1801
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1808
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1815
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1820
msgid "``true`` if the bucket ref is removed successfully; or ``nil`` and ``err`` explaining why the ref cannot be removed"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1827
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1834
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1841
msgid "Find a bucket which has data in a space but is not stored in a ``_bucket`` space; or is in a GARBAGE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1844
msgid "index of a space with the part of a bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1845
msgid "a garbage collector controller. If there is an increased buckets generation, then the search should be interrupted."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1848
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1855
msgid "Return information about each bucket located in storage. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1873
msgid "Return the number of buckets located in storage."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1879
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1885
msgid "Return a flag indicating whether rebalancing is in progress. The result is true if the node is currently applying routes received from a rebalancer node in the special fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1893
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1899
msgid "Disable rebalancing. A disabled rebalancer sleeps until it is enabled again with vshard.storage.rebalancer_enable()."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1906
msgid "Enable rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1912
msgid "Show the spaces that are visible to rebalancer and garbage collector fibers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1918
msgid "Storage internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1920
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1921
msgid ":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-bucket_recv>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1922
msgid ":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-bucket_delete_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1923
msgid ":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-bucket_collect>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1924
msgid ":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) <storage_api-bucket_force_create>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1925
msgid ":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-bucket_force_drop>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1926
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1927
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1928
msgid ":ref:`vshard.storage.rebalancer_request_state() <storage_api-rebalancer_request_state>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1934
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1937
msgid "UUID of source replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1938
msgid "data logically stored in a bucket identified by bucket_id, in the same format as the return value from ``bucket_collect() <storage_api-bucket_collect>``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1945
msgid "Return information about the bucket id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1947
msgid "tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1962
msgid "Force garbage collection for the bucket identified by bucket_id in case the bucket was transferred to a different replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1971
msgid "Collect all the data that is logically stored in the bucket identified by bucket_id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1973
msgid "tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1996
msgid "Force creation of the buckets (single or multiple) on the current replica set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1999
msgid "an identifier of the first bucket in a range"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2000
msgid "the number of buckets to insert (default = 1)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2006
msgid "Drop a bucket manually for tests or emergency cases."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2014
msgid "Send a specified bucket from the current replica set to a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2016
msgid "bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2017
msgid "UUID of a remote replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2023
msgid "Check all buckets of the host storage that have the SENT or ACTIVE state, return the number of active buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2026
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2032
msgid "Collect an array of active bucket identifiers for discovery."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2038
msgid "Glossary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2043
msgid "**Vertical scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2045
msgid "Adding more power to a single server: using a more powerful CPU, adding more capacity to RAM, adding more storage space, etc."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2049
msgid "**Horizontal scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2051
msgid "Adding more servers to the pool of resources, then partitioning and distributing a dataset across the servers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2055
msgid "**Sharding**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2057
msgid "A database architecture that allows partitioning a dataset using a sharding key and distributing a dataset across multiple servers. Sharding is a special case of horizontal scaling."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2062
msgid "**Node**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2064
msgid "A virtual or physical server instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2067
msgid "**Cluster**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2069
msgid "A set of nodes that make up a single group."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2072
msgid "**Storage**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2074
msgid "A node storing a subset of a dataset."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2079
msgid "A set of storage nodes storing copies of a dataset. Each storage in a replica set has a role, master or replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2083
msgid "**Master**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2085
msgid "A storage in a replica set processing read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2090
msgid "A storage in a replica set processing only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2093
msgid "**Read requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2095
msgid "Read-only requests, that is, select requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2098
msgid "**Write requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2100
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2103
msgid "**Buckets (virtual buckets)**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2105
msgid "The abstract virtual nodes into which the dataset is partitioned by the sharding key (bucket id)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2109
msgid "**Bucket id**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2111
msgid "A sharding key defining which bucket belongs to which replica set. A bucket id may be calculated from a :ref:`hash key <router_api-bucket_id>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2115
msgid "**Router**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2117
msgid "A proxy server responsible for routing requests from an application to nodes in a cluster."
msgstr ""

#: ../doc/reference/reference_sql/index.rst:5
msgid "SQL reference"
msgstr ""

#: ../doc/reference/reference_sql/index.rst:7
msgid "This reference covers all the SQL statements and clauses supported by Tarantool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5
msgid "SQL beginners' guide"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:7
msgid "**What Tarantool's SQL product delivers**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:9
msgid "Tarantool's SQL is a major new feature that was first introduced with Tarantool version 2.1. |br| The primary advantages are: |br| - a high level of SQL compatibility |br| - an easy way to switch from NoSQL to SQL and back |br| - the Tarantool brand."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:15
msgid "The \"high level of SQL compatibility\" includes support for joins, subqueries, triggers, indexes, groupings, transactions in a multi-user environment, and conformance with the majority of the mandatory requirements of the SQL:2016 standard."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:19
msgid "The \"easy way to switch\" consists of the fact that the same tables can be operated on with SQL and with the  long-established Tarantool-NoSQL product, meaning that when you want standard Relational-DBMS jobs you can do them, and when you want NoSQL capability you can have it (Tarantool-NoSQL outperforms other NoSQL products in public benchmarks)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:24
msgid "The \"Tarantool brand\" comes from the support of a multi-billion-dollar internet / mail / social-network provider, a dozens-of-professionals staff of programmers and support people, a community who believes in open-source BSD licensing, and hundreds of corporations / government bodies using Tarantool products in production already."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:28
msgid "The status of Tarantool's SQL feature is \"release\". So, it is working now and you can verify that by downloading it and trying all the features, which we will explain in the rest of this document. There is also a :ref:`tutorial <sql_tutorial>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:32
msgid "This document has fourparts. The SQL BEGINNERS' GUIDE explains the basics of relational database management and SQL in particular. The USER GUIDE explains \"How to get Started\" and explains the terms and the syntax elements that apply for all SQL statements. The SQL STATEMENTS AND CLAUSES guide explains, for each SQL statement, the format and the rules and the exceptions and the examples and the limitations. The SQL PLUS LUA guide has the details about calling Lua from SQL, calling SQL from Lua, and using the same database objects in both SQL and Lua."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:41
msgid "Users are expected to know what databases are, and experience with other SQL DBMSs would be an advantage."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:43
msgid "**SQL beginners' guide begins**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:45
msgid "The Beginners' Guide describes how users can start up with SQL with Tarantool, and necessary concepts."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:47
msgid "The SQL Beginners' Guide is about databases in general, and about the relationship between Tarantool's NoSQL and SQL products. Most of the matters in the Beginners' Guide will already be familiar to people who have used relational databases before."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:51
msgid "**Sample Simple Table**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:53
msgid "In football training camp it is traditional for the trainer to begin by showing a football and saying \"this is a football\". In that spirit, this is a table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:56
msgid "TABLE\n"
"          [1]              [2]              [3]\n"
"       +-----------------+----------------+----------------+\n"
" Row#1 | Row#1,Column#1  | Row#1,Column#2 | Row#1,Column#3 |\n"
"        +-----------------+----------------+----------------+\n"
" Row#2 | Row#2,Column#1  | Row#2,Column#2 | Row#2,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#3 | Row#3,Column#1  | Row#3,Column#2 | Row#3,Column#3 |\n"
"       +-----------------+----------------+----------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:68
msgid "but the labels are misleading -- we usually don't identify rows and columns by their ordinal positions, we prefer to pick out specific items by their contents. In that spirit, this is a table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:71
#: ../doc/reference/reference_sql/sql.rst:622
msgid "modules\n"
"\n"
"+-----------------+------+---------------------+\n"
"| name            | size | purpose             |\n"
"+-----------------|------|---------------------|\n"
"| box             | 1432 | Database Management |\n"
"| clock           |  188 | Seconds             |\n"
"| crypto          |    4 | Cryptography        |\n"
"+-----------------+------+---------------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:83
msgid "so we do not use longitude/latitude navigation by talking about \"Row#2 Column #2\", we use the contents of the Name column and the name of the Size column by talking about \"the size, where the name is 'clock'\". To be more exact, this is what we say:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:88
#: ../doc/reference/reference_sql/sql.rst:312
#: ../doc/reference/reference_sql/sql.rst:359
msgid "``SELECT size FROM modules WHERE name = 'clock';``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:90
msgid "If you're familiar with Tarantool's architecture -- and we hope that you read about that before coming to this chapter -- then you know that there is a NoSQL way to get the same thing:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:94
msgid "``box.space.MODULES:select()[2][2]``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:96
msgid "Well, you can do that. One of the advantages of Tarantool is that if you can get data via an SQL statement, then you can get the same data via a NoSQL request. But the reverse is not true, because not all NoSQL tuple sets are definable as SQL tables. These restrictions apply for SQL that do not apply for NoSQL: |br| 1. Every column must have a name. |br| 2. Every column must have a scalar type (Tarantool is relaxed about which particular scalar type you can have, but there is no way to index and search arrays, tables within tables, or what MessagePack calls \"maps\".)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:105
msgid "Tarantool/NoSQL's \"format\" clause causes the same restrictions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:107
msgid "So an SQL \"table\" is a NoSQL \"tuple set with format restrictions\", an SQL \"row\" is a NoSQL \"tuple\", an SQL \"column\" is a NoSQL \"list of fields within a tuple set\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:110
msgid "**Creating a table**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:112
msgid "This is how to create the modules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:114
msgid "``CREATE TABLE modules (name STRING, size INTEGER, purpose STRING, PRIMARY KEY (name));``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:116
msgid "The words that are IN CAPITAL LETTERS are \"keywords\" (although it is only a convention in this manual that keywords are in capital letters, in practice many programmers prefer to avoid shouting). A keyword has meaning for the SQL parser so many keywords are reserved, they cannot be used as names unless they are enclosed inside quotation marks."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:121
msgid "The word \"modules\" is a \"table name\", and the words \"name\" and \"size\" and \"purpose\" are \"column names\". All tables and all columns must have names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:124
msgid "The words \"STRING\" and \"INTEGER\" are \"data types\". STRING means \"the contents should be characters, the length is indefinite, the equivalent NoSQL type is 'string''\". INTEGER means \"the contents should be numbers without decimal points, the equivalent NoSQL type is 'integer'\". Tarantool supports other data types but our example table has data types from the two main groups, namely, data types for numbers and data types for strings."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:130
msgid "The final clause, PRIMARY KEY (name), means that the name column is the main column used to identify the row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:132
msgid "**Nulls**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:134
msgid "Frequently it is necessary, at least temporarily, that a column value should be NULL. Typical situations are: the value is unknown, or the value is not applicable. For example, you might make a module as a placeholder but you don't want to say its size or purpose. If such things are possible, the column is \"nullable\". Our name column cannot contain nulls, and it could be defined explicitly as \"name STRING NOT NULL\", but in this case that's unnecessary -- a column defined as PRIMARY KEY is automatically NOT NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:141
msgid "Is a NULL in SQL the same thing as a nil in Lua? No, but it is close enough that there will be confusion. When nil means \"unknown\" or \"inapplicable\", yes. But when nil means \"nonexistent\" or \"type is nil\", no. NULL is a value, it has a data type because it is inside a column which is defined with that data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:147
msgid "**Creating an index**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:149
msgid "This is how to create indexes for the modules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:151
msgid "``CREATE INDEX size ON modules (size);`` |br| ``CREATE UNIQUE INDEX purpose ON modules (purpose);``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:154
msgid "There is no need to create an index on the name column, because Tarantool creates an index automatically when it sees a PRIMARY KEY clause in the CREATE TABLE statement. In fact there is no need to create indexes on the size or purpose columns either -- if indexes don't exist, then it is still possible to use the columns for searches. Typically people create non-primary indexes, also called secondary indexes, when it becomes clear that the table will grow large and searches will be frequent, because searching with an index is generally much faster than searching without an index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:162
msgid "Another use for indexes is to enforce uniqueness. When an index is created with CREATE UNIQUE INDEX for the purpose column, it is not possible to have duplicate values in that column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:166
msgid "**Data change**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:168
msgid "Putting data into a table is called \"inserting\". Changing data is called \"updating\". Removing data is called \"deleting\". Together, the three SQL statements INSERT plus UPDATE plus DELETE are the three main \"data-change\" statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:173
msgid "This is how to insert, update, and delete a row in the modules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:175
msgid "``INSERT INTO modules VALUES ('json', 14, 'format functions for JSON');`` |br| ``UPDATE modules SET size = 15 WHERE name = 'json';`` |br| ``DELETE FROM modules WHERE name = 'json';``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:179
msgid "The corresponding non-SQL Tarantool requests would be:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:181
msgid "``box.space.MODULES:insert{'json', 14, 'format functions for JSON'}`` |br| ``box.space.MODULES:update('json', {{'=', 2, 15}})`` |br| ``box.space.MODULES:delete{'json'}`` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:185
msgid "This is how we would populate the table with the values that we showed earlier:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:187
msgid "``INSERT INTO modules VALUES ('box', 1432, 'Database Management');`` |br| ``INSERT INTO modules VALUES ('clock', 188, 'Seconds');`` |br| ``INSERT INTO modules VALUES ('crypto', 4, 'Cryptography');`` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:191
msgid "**Constraints**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:193
msgid "Some data-change statements are illegal due to something in the table's definition. This is called \"constraining what can be done\". We have already seen some types of constraints ..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:196
msgid "NOT NULL -- if a column is defined with a NOT NULL clause, it is illegal to put NULL into it. A primary-key column is automatically NOT NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:199
msgid "UNIQUE -- if a column has a UNIQUE index, it is illegal to put a duplicate into it. A primary-key column automatically has a UNIQUE index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:202
msgid "data domain -- if a column is defined as having data type INTEGER, it is illegal to put a non-number into it. More generally, if a value doesn't correspond to the data type of the definition, it is illegal. However, some database management systems (DBMSs) are very forgiving and will try to make allowances for bad values rather than reject them; Tarantool is one of those DBMSs."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:207
msgid "Now, here are other types of constraints ..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:209
msgid "CHECK -- a table description can have a clause \"CHECK (conditional expression)\". For example, if the CREATE TABLE modules statement looked like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:212
msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                      purpose STRING,\n"
"                      PRIMARY KEY (name),\n"
"                      CHECK (size > 0));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:220
msgid "then this INSERT statement would be illegal: |br| ``INSERT INTO modules VALUES ('box'', 0, 'The Database Kernel');`` |br| because there is a CHECK constraint saying that the second column, the size column, cannot contain a value which is less than or equal to zero. Try this instead: |br| ``INSERT INTO modules VALUES ('box', 1, 'The Database Kernel');``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:226
msgid "FOREIGN KEY -- a table description can have a clause \"FOREIGN KEY (column-list) REFERENCES table (column-list)\". For example, if there is a new table \"submodules\" which in a way depends on the modules table, it can be defined like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:231
msgid "CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                          purpose STRING,\n"
"                          PRIMARY KEY (name),\n"
"                          FOREIGN KEY (module_name) REFERENCES\n"
"                          modules (name));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:241
msgid "Now try to insert a new row into this submodules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:243
msgid "``INSERT INTO submodules VALUES`` |br| |nbsp| |nbsp| ``('space', 'Box', 10000, 'insert etc.');``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "The insert will fail because the second column (module_name) refers to the name column in the modules table, and the name column in the modules table does not contain 'Box'. However, it does contain 'box'. By default searches in Tarantool's SQL use a binary collation. This will work:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:252
msgid "``INSERT INTO submodules`` |br| |nbsp| |nbsp| ``VALUES ('space', 'box', 10000, 'insert etc.');``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:255
msgid "Now try to delete the new row from the modules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:257
msgid "``DELETE FROM modules WHERE name = 'box';``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:259
msgid "The delete will fail because the second column (module_name) in the submodules table refers to the name column in the modules table, and the name column in the modules table would not contain 'box' if the delete succeeded. So the FOREIGN KEY constraint affects both the table which contains the FOREIGN KEY clause and the table that the FOREIGN KEY clause refers to."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:265
msgid "The constraints in a table's definition -- NOT NULL, UNIQUE, data domain, CHECK, and FOREIGN KEY -- are guarantors of the database's integrity. It is important that they are fixed and well-defined parts of the definition, and hard to bypass with SQL. This is often seen as a difference between SQL and NoSQL -- SQL emphasizes law and order, NoSQL emphasizes freedom and making your own rules."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:272
msgid "**Table Relationships**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:274
msgid "Think about the two tables that we have discussed so far:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:276
msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                       purpose STRING,\n"
"                       PRIMARY KEY (name),\n"
"                       CHECK (size > 0));\n"
"\n"
"CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:298
msgid "Because of the FOREIGN KEYS clause in the submodules table, there is clearly a many-to-one relationship: |br| submodules -->> modules |br| that is, every submodules row must refer to one (and only one) modules row, while every modules row can be referred to in zero or more submodules rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:303
msgid "Table relationships are important, but beware: do not trust anyone who tells you that databases made with SQL are relational \"because there are relationships between tables\". That is wrong. We will see why when we talk about what makes a database relational, later."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:308
msgid "**Selecting with WHERE**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:310
msgid "We gave a simple example of a SELECT statement earlier:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:314
msgid "The clause \"WHERE name = 'clock'\" is legal in other statements -- we have seen it in UPDATE and DELETE -- but here we will only give examples with SELECT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:317
msgid "The first variation is that the WHERE clause does not have to be specified at all, it is optional. So this statement would return all rows:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:320
msgid "``SELECT size FROM modules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:322
msgid "The second variation is that the comparison operator does not have to be '=', it can be anything that makes sense: '>' or '>=' or '<' or '<=', or 'LIKE' which is an operator that works with strings that may contain wildcard characters '_' meaning 'match any one character' or '%' meaning 'match any zero or one or many characters'. These are legal statements which return all rows:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:329
msgid "``SELECT size FROM modules WHERE name >= '';`` |br| ``SELECT size FROM modules WHERE name LIKE '%';``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:332
msgid "The third variation is that IS [NOT] NULL is a special condition. Remembering that the NULL value can mean \"it is unknown what the value should be\", and supposing that in some row the size is NULL, then the condition \"size > 10\" is not certainly true and it is not certainly false, so it is evaluated as \"unknown\". Ordinarily the application of a WHERE clause filters out both false and unknown results. So when searching for NULL, say IS NULL; when searching anything that is not NULL, say IS NOT NULL. This statement will return all rows because (due to the definition) there are no NULLs in the name column:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:342
msgid "``SELECT size FROM modules WHERE name IS NOT NULL;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:344
msgid "The fourth variation is that conditions can be combined with AND / OR, and negated with NOT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:346
msgid "So this statement would return all rows (the first condition is false but the second condition is true, and OR means \"return true if either condition is true\"):"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:349
msgid "SELECT size\n"
"FROM modules\n"
"WHERE name = 'wombat' OR size IS NOT NULL;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:355
msgid "**Selecting with a select list**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:357
msgid "Yet again, here is a simple example of a SELECT statement:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:361
msgid "The words between SELECT and FROM are the select list. In this case, the select list is just one word: size. Formally it means that the desire is to return the size values, and technically the name for picking a particular column is called \"projection\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:366
msgid "The first variation is that one can specify any column in any order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:368
msgid "``SELECT name, purpose, size FROM modules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:370
msgid "The second variation is that one can specify an expression, it does not have to be a column name, it does not even have to include a column name. The common expression operators for numbers are the arithmetic operators ``+ - / *``; the common expression operator for strings is the concatenation operator ||. For example this statement will return 8, 'XY':"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:376
msgid "``SELECT size * 2, 'X' || 'Y' FROM modules WHERE size = 4;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:378
msgid "The third variation is that one can add a clause [AS name] after every expression, so that in the return the column titles will make sense. This is especially important when a title might otherwise be ambiguous or meaningless. For example this statement will return 8, 'XY' as before"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:383
msgid "``SELECT size * 2 AS double_size, 'X' || 'Y' AS concatenated_literals  FROM modules`` |br| |nbsp| |nbsp| ``WHERE size = 4;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:386
msgid "but displayed as a table the result will look like"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:388
msgid "+----------------+------------------------+\n"
"| double_size    | concatenated_literals  |\n"
"+----------------+------------------------+\n"
"|               8| XY                     |\n"
"+----------------+------------------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:396
msgid "**Selecting with a select list with asterisk**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:398
msgid "Instead of listing columns in a select list, one can just say ``'*'``. For example"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:400
msgid "``SELECT * FROM modules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:402
msgid "This is the same thing as"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:404
msgid "``SELECT name, size, purpose FROM modules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:406
msgid "Selecting with ``\"*\"``  saves time for the writer, but it is unclear to a reader who has not memorized what the column names are. Also it is unstable, because there is a way to change a table's definition (the ALTER statement, which is an advanced topic). Nevertheless, although it might be bad to use it for production, it is handy to use it for introduction, so we will use ``'*'`` in several examples."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:413
msgid "**Select with subqueries**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:415
msgid "Remember that we have a modules table and we have a submodules table. Suppose that we want to list the submodules that refer to modules for which the purpose is X. That is, this involves a search of one table using a value in another table. This can be done by enclosing \"(SELECT ...)\" within the WHERE clause. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:420
msgid "SELECT name FROM submodules\n"
"WHERE module_name =\n"
"    (SELECT name FROM modules WHERE purpose LIKE '%Database%');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:426
msgid "Subqueries are also useful in the select list, when one wishes to combine information from more than one table. For example this statement will display submodules rows but will include values that come from the modules table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:430
msgid "SELECT name AS submodules_name,\n"
"    (SELECT purpose FROM modules\n"
"     WHERE modules.name = submodules.module_name)\n"
"     AS modules_purpose,\n"
"    purpose AS submodules_purpose\n"
"FROM submodules;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:439
msgid "Whoa. What are \"modules.name\" and \"submodules.name\"? Whenever you see \"x . y\" you are looking at a \"qualified column name\", and the first part is a table identifier, the second part is a column identifier. It is always legal to use qualified column names, but until now it has not been necessary. Now it is necessary, or at least it is a good idea, because both tables have a column named \"name\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:445
#: ../doc/reference/reference_sql/sql.rst:642
#: ../doc/reference/reference_sql/sql.rst:663
msgid "The result will look like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:447
msgid "+-------------------+------------------------+--------------------+\n"
"| SUBMODULES_NAME   | MODULES_PURPOSE        | SUBMODULES_PURPOSE |\n"
"+-------------------+------------------------+--------------------+\n"
"| space             | Database Management    | insert etc.        |\n"
"+-------------------+------------------------+--------------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:455
msgid "Perhaps you have read somewhere that SQL stands for \"Structured Query Language\". That is not true any more. But it is true that the query syntax allows for a structural component, namely the subquery, and that was the original idea. However, there is a different way to combine tables -- with joins instead of subqueries."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:461
msgid "**Select with Cartesian join**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:463
msgid "Until now we have only used \"FROM modules\" or \"FROM submodules\" in our SELECT statements. What if we used more than one table in the FROM clause? For example"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:466
msgid "``SELECT * FROM modules, submodules;`` |br| or ``SELECT * FROM modules JOIN submodules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:470
msgid "That is legal. Usually it is not what you want, but it is a learning aid. The result will be:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:472
msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| name   | size | purpose             | name  | module_name | size  | purpose     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  | 188  | Seconds             | space | box         | 10000 | insert etc. |\n"
"| crypto |   4  | Cryptography        | space | box         | 10000 | insert etc. |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:483
msgid "It is not an error. The meaning of this type of join is \"combine every row in table-1 with every row in table-2\". It did not specify what the relationship should be, so the result has everything, even when the submodule has nothing to do with the module."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:487
msgid "It is handy to look at the above result, called a \"Cartesian join\" result, to see what we really want. Probably for this case the row that actually makes sense is the one where the modules.name = submodules.module_name, and we should make that clear in both the select list and the WHERE clause, thus:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:491
msgid "SELECT modules.name AS modules_name,\n"
"       modules.size AS modules_size,\n"
"       modules.purpose AS modules_purpose,\n"
"       submodules.name,\n"
"       module_name,\n"
"       submodules.size,\n"
"       submodules.purpose\n"
"FROM modules, submodules\n"
"WHERE modules.name = submodules.module_name;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:503
msgid "The result will be:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:505
msgid "+----------+-----------+------------+--------+---------+-------+-------------+\n"
"| modules_ |  modules_ | modules_   | name   | module_ | size  | purpose     |\n"
"| name     |  size     | purpose    |        | name    |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------|\n"
"| box      | 1432      | Database   | space  | box     | 10000 | insert etc. |\n"
"|          |           | Management |        |         |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:515
msgid "In other words, you can specify a Cartesian join in the FROM clause, then you can filter out the irrelevant rows in the WHERE clause, and then you can rename columns in the select list. This is fine, and every SQL DBMS supports this. But it is worrisome that the number of rows in a Cartesian join is always (number of rows in first table multiplied by number of rows in second table), which means that conceptually you are often filtering in a large set of rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:523
msgid "It is good to start by looking at Cartesian joins because they show the concept. Many people, though, prefer to use different syntaxes for joins because they look better or clearer. We will look at those alternatives now."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:527
msgid "**Select with join with ON clause**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:529
msgid "The ON clause would have the same comparisons as the WHERE clause that we illustrated for the previous section, but by using different syntax we would be making it clear \"this is for the sake of the join\". Readers can see at a glance that it is, in concept at least, an initial step before the result rows are filtered. For example this"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:535
msgid "``SELECT * FROM modules JOIN submodules`` |br| |nbsp| |nbsp| ``ON (modules.name = submodules.module_name);``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:538
msgid "is the same as"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:540
msgid "``SELECT * FROM modules, submodules`` |br| |nbsp| |nbsp| ``WHERE modules.name = submodules.module_name;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:543
msgid "**Select with join with USING clause**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:545
msgid "The USING clause would take advantage of names that are held in common between the two tables, with the assumption that the intent is to match those columns with '=' comparisons. For example,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:548
msgid "``SELECT * FROM modules JOIN submodules USING (name);``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:550
msgid "has the same effect as"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:552
msgid "``SELECT * FROM modules JOIN submodules WHERE modules.name = submodules.name;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:554
msgid "If we had created our table with a plan in advance to use USING clauses, that would save time. But we did not. So, although the above example \"works\", the results will not be sensible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:558
msgid "**Select with natural join**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:560
msgid "A natural join would take advantage of names that are held in common between the two tables, and would do the filtering automatically based on that knowledge, and throw away duplicate columns."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:563
msgid "If we had created our table with a plan in advance to use natural joins, that would be very handy. But we did not. So, although the following example \"works\", the results won't be sensible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:566
msgid "``SELECT * FROM modules NATURAL JOIN submodules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:568
msgid "Result: nothing, because modules.name does not match submodules.name, and so on And even if there had been a result, it would only have included four columns: name, module_name, size, purpose."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:572
msgid "**Select with left join**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:574
msgid "Now what if we want to join modules to submodules, but we want to be sure that we get all the modules? In other words, we want to get modules even if the condition submodules.module_name = modules.name is not true, because the module has no submodules."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:579
msgid "When that is what we want, the type of join is an \"outer join\" (as opposed to the type we have used so far which is an \"inner join\"). Specifically we will use LEFT [OUTER] JOIN because our main table, modules, is on the left. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:583
msgid "SELECT *\n"
"FROM modules LEFT JOIN submodules\n"
"ON modules.name = submodules.module_name;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:589
msgid "which returns:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:591
msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| name   | size | purpose             | name  | module_name | size  | purpose     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  | 188  | Seconds             | NULL  | NULL        | NULL  | NULL        |\n"
"| crypto |   4  | Cryptography        | NULL  | NULL        | NULL  | NULL        |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:602
msgid "Thus, for the submodules of the clock module and the submodules of the crypto module -- which do not exist -- there are NULLs in every column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:605
msgid "**Select with functions**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:607
msgid "A function can take any expression, including an expression that contains another function, and return a scalar value. There are many such functions. We will just describe one, SUBSTR, which returns a substring of a string."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:611
msgid "Format: :samp:`SUBSTR({input-string}, {start-with} [, {length}])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:613
msgid "Description: SUBSTR takes input-string, eliminates any characters before start-with, eliminates any characters after (start-with plus length), and returns the result."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:616
msgid "Example: ``SUBSTR('abcdef', 2, 3)`` returns 'bcd'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:618
msgid "Select with aggregation, GROUP BY, and HAVING"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:620
msgid "Remember that our modules table looks like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:635
msgid "Suppose that we do not want to know all the individual size values, we just want to know about their aggregation, that is, take the attributes of the collection. SQL allows five aggregation functions: AVG (average), SUM, MIN (minimum), MAX (maximum), and COUNT. For example"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:640
msgid "``SELECT AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size) FROM modules;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:644
msgid "+--------------+-----------+-----------+-----------+-------------+\n"
"| AVG(size)    | SUM(size) | MIN(size) | MAX(size) | CoUNT(size) |\n"
"+--------------+-----------+-----------+-----------+-------------|\n"
"| 5.413333E+02 | 1624      |         4 |      1432 |           3 |\n"
"+--------------+-----------+-----------+-----------+-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:652
msgid "Suppose that we want aggregations, but aggregations of rows that have some common characteristic. Supposing further, we want to divide the rows into two groups, the ones whose names begin with 'b' and the ones whose names begin with 'c'. This can be done by adding a clause [GROUP BY expression]. For example,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:657
msgid "SELECT SUBSTR(name, 1, 1), AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size)\n"
"FROM modules\n"
"GROUP BY SUBSTR(name, 1, 1);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:665
msgid "+--------------------+--------------+-----------+-----------+-----------+-------------+\n"
"| SUBSTR(name, 1, 1) | AVG(size)    | SUM(size) | MIN(size) | MAX(size) | CoUNT(size) |\n"
"+--------------------+--------------+-----------+-----------+-----------|-------------|\n"
"| b                  |         1432 |      1432 |      1432 |      1432 |           1 |\n"
"| c                  |           96 |       192 |         4 |       188 |           2 |\n"
"+--------------------+--------------+-----------+-----------+-----------|-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:675
msgid "**Select with common table expression**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:677
msgid "It is possible to define a temporary (viewed) table within a statement, usually within a SELECT statement, using a WITH clause. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:680
msgid "``WITH tmp_table AS (SELECT x1 FROM t1) SELECT * FROM tmp_table;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:682
msgid "Select with order, limit, and offset clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:684
msgid "Every time we have searched in the modules table, the rows have come out in alphabetical order by name: 'box', then 'clock', then 'crypto'. However, if we want to be sure about the order, or if we want a different order, we will have to be explicit and add a clause: ``ORDER BY column-name [ASC|DESC]``. (ASC stands for ASCending, DESC stands for DESCending.) For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:692
msgid "``SELECT * FROM modules ORDER BY name DESC;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:694
msgid "The result will be the usual rows, in descending alphabetical order: 'crypto' then 'clock' then 'box'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:696
msgid "After the ORDER BY clause we can add a clause LIMIT n, where n is the maximum number of rows that we want. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:698
msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:700
msgid "The result will be the first two rows, 'crypto' and 'clock'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:702
msgid "After the ORDER BY clause and the LIMIT clause we can add a clause OFFSET n, where n is the row to start with. The first offset is 0. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:705
msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2 OFFSET 2;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:707
msgid "The result will be the third row, 'box'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:709
msgid "**Views**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:711
msgid "A view is a canned SELECT. If you have a complex SELECT that you want to run frequently, create a view and then do a simple SELECT on the view. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:713
msgid "CREATE VIEW v AS SELECT size, (size *5) AS size_times_5\n"
"FROM modules\n"
"GROUP BY size, name\n"
"ORDER BY size_times_5;\n"
"SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:721
msgid "**Transactions**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:723
msgid "Tarantool has a \"Write Ahead Log\" (WAL). Effects of data-change statements are logged before they are permanently stored on disk. This is a reason that, although entire databases can be stored in temporary memory, they are not vulnerable in case of power failure."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:728
msgid "Tarantool supports commits and rollbacks. In effect, asking for a commit means asking for all the recent data-change statements, since a transaction began, to become permanent. In effect, asking for a rollback means asking for all the recent data-change statements, since a transaction began, to be cancelled."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:734
msgid "For example, consider these statements:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:736
msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('A');\n"
"COMMIT;\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('B');\n"
"ROLLBACK;\n"
"SELECT * FROM things;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:747
msgid "The result will be: one row, containing 'A'. The ROLLBACK cancelled the second INSERT statement, but did not cancel the first one, because it had already been committed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:750
msgid "Ordinarily every statement is automatically committed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:752
msgid "After START TRANSACTION, statements are not automatically committed -- Tarantool considers that a transaction is now \"active\", until the transaction ends with a COMMIT statement or a ROLLBACK statement. While a transaction is active, all statements are legal except another START TRANSACTION."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:756
msgid "**Implementing Tarantool's SQL On Top of NoSQL**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:758
msgid "Tarantool's SQL data is the same as Tarantool's NoSQL data. When you create a table or an index with SQL, you are creating a space or an index in NoSQL. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:761
msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"INSERT INTO things VALUES ('X');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:766
msgid "is somewhat similar to"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:768
msgid "box.schema.space.create('THINGS',\n"
"{\n"
"    format = {\n"
"              [1] = {[\"name\"] = \"REMARK\", [\"type\"] = \"string\"}\n"
"              }\n"
"})\n"
"box.space.THINGS:create_index('pk_unnamed_THINGS_1',{unique=true,parts={1,'string'}})\n"
"box.space.THINGS:insert{'X'}"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:779
msgid "Therefore you can take advantage of Tarantool's NoSQL features even though your primary language is SQL. Here are some possibilities."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:782
msgid "(1) NoSQL applications written in one of the connector languages may be slightly faster than SQL applications because SQL statements may require more parsing and may be translated to NoSQL requests."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:785
msgid "(2) You can write stored procedures in Lua, combining Lua loop-control and Lua library-access statements with SQL statements. These routines are executed on the server, which is the principal advantage of pure-SQL stored procedures."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:788
msgid "(3) There are some options that are implemented in NoSQL that are not (yet) implemented in SQL. For example you can use NoSQL to change an index type to 'hash', and to deny access to users named 'guest'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:791
msgid "(4) System spaces such as _space and _index can be accessed with SQL SELECT statements. This is not quite the same as an information_schema, but it does mean that you can use SQL to access the database's metadata catalog."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:795
msgid "Fields in NoSQL spaces can be accessed with SQL if and only if they are scalar and are defined in format clauses. Indexes of NoSQL spaces will be used with SQL if and only if they are TREE or HASH indexes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:798
msgid "**Relational Databases**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:800
msgid "Edgar F. Codd, the person most responsible for researching and explaining relational database concepts, listed the main criteria as (`Codd's 12 rules <https://en.wikipedia.org/wiki/Codd's_12_rules>`_)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:804
msgid "Although we do not advertise Tarantool as \"relational\", we claim that Tarantool complies with these rules, with the following caveats and exceptions ..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:807
msgid "The rules state that all data must be viewable as relations. A Tarantool SQL table is a relation. However, it is possible to have duplicate values in SQL tables and it is possible to have an implicit ordering. Those characteristics are not allowed for true relations."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:812
msgid "The rules state that there must be a dynamic online catalog. Tarantool has one but some metadata is missing from it."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:814
msgid "The rules state that the data language must support authorization. Tarantool's SQL does not. Authorization occurs via NoSQL requests."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:817
msgid "The rules require that data must be physically independent (from underlying storage changes) and logically independent (from application program changes). So far we do not have enough experience to make this guarantee."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:821
msgid "The rules require certain types of updatable views. Tarantool's views are not updatable."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:823
msgid "The rules state that it should be impossible to use a low-level language to bypass integrity as defined in the relational-level language. In our case, this is not true, for example one can execute a request with Tarantool's NoSQL to violate a foreign-key constraint that was defined with Tarantool's SQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:832
msgid "SQL user guide"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:834
msgid "The User Guide describes how users can start up with SQL with Tarantool, and necessary concepts."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:836
msgid "Getting Started"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:838
msgid "The explanations for installing and starting the Tarantool server are in earlier chapters of the Tarantool manual.."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:840
msgid "To get started specifically with the SQL features, using Tarantool as a client, execute these requests:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:842
msgid "box.cfg{}\n"
"box.execute([[VALUES ('hello');]])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:847
msgid "The bottom of the screen should now look like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:849
msgid "tarantool> box.execute([[VALUES ('hello');]])\n"
"---\n"
"- metadata:\n"
"  - name: column1\n"
"    type: string\n"
"  rows:\n"
"  - ['hello']\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:860
msgid "That's an SQL statement done with Tarantool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:862
msgid "Now you are ready to execute any SQL statements via the connection. For example"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:864
msgid "box.execute([[CREATE TABLE things (id INTEGER PRIMARY key,\n"
"                                   remark STRING);]])\n"
"box.execute([[INSERT INTO things VALUES (55, 'Hello SQL world!');]])\n"
"box.execute([[SELECT * FROM things WHERE id > 0;]])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:871
msgid "And you will see the results of the SQL query."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:873
msgid "For the rest of this chapter, the :ref:`box.execute([[...]]) <box-sql>` enclosure will not be shown. Examples will simply say what a piece of syntax looks like, such as ``SELECT 'hello';`` |br| and users should know that must be entered as |br| ``box.execute([[SELECT 'hello';]])`` |br| It is also legal to enclose SQL statements inside single or double quote marks instead of [[ ... ]]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:881
msgid "Supported syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:883
msgid "Keywords, for example CREATE or INSERT or VALUES, may be entered in either upper case or lower case."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:885
msgid "Literal values, for example ``55`` or ``'Hello SQL world!'``, should be entered without single quote marks if they are numeric, and should be entered with single quote marks if they are strings."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:888
msgid "Object names, for example table1 or column1, should usually be entered without double quote marks and are subject to some restrictions. They may be enclosed in double quote marks and in that case they are subject to fewer restrictions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:892
msgid "Almost all keywords are :ref:`reserved <sql_reserved_words>`, which means that they cannot be used as object names unless they are enclosed in double quote marks."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:896
msgid "Comments may be between ``/*`` and ``*/`` (bracketed) or between ``--`` and the end of a line (simple)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:899
msgid "INSERT /* This is a bracketed comment */ INTO t VALUES (5);\n"
"INSERT INTO t VALUES (5); -- this is a simple comment"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:904
msgid "Expressions, for example ``a + b`` OR ``a > b AND NOT a <= b``, may have arithmetic operators ``+ - / *``, may have comparison operators ``= > < <= >= LIKE``, and may be combined with ``AND OR NOT``, with optional parentheses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:908
msgid "SQL statements should end with ; (semicolon); this is not mandatory but it is recommended."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:910
msgid "In alphabetical order, the following statements are legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:912
msgid "|nbsp| :ref:`ALTER TABLE table-name [RENAME or ADD CONSTRAINT clauses]; <sql_alter_table>` |br| |nbsp| ANALYZE [table-name]; -- temporarily disabled in current version |br| |nbsp| :ref:`COMMIT; <sql_commit>` |br| |nbsp| :ref:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] index-name <sql_create_index>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`ON table-name (column-name [, column-name ...]); <sql_create_index>` |br| |nbsp| :ref:`CREATE TABLE [IF NOT EXISTS] table-name <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`(column-or-constraint-definition <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[, column-or-constraint-definition ...]) <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WITH ENGINE = engine-name]; <sql_create_table>` |br| |nbsp| :ref:`CREATE TRIGGER [IF NOT EXISTS] trigger-name <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`BEFORE|AFTER INSERT|UPDATE|DELETE ON table-name <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`FOR EACH ROW <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`BEGIN dml-statement [, dml-statement ...] END; <sql_create_trigger>` |br| |nbsp| :ref:`CREATE VIEW [IF NOT EXISTS] view-name <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[(column-name [, column-name ...])] <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`AS select-statement; <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`FROM table-name <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WHERE expression]; <sql_create_view>`  |br| |nbsp| :ref:`DROP INDEX [IF EXISTS] index-name ON table-name; <sql_drop_index>`  |br| |nbsp| :ref:`DROP TABLE [IF EXISTS] table-name; <sql_drop_table>`  |br| |nbsp| :ref:`DROP TRIGGER [IF EXISTS] trigger-name; <sql_drop_trigger>` |br| |nbsp| :ref:`DROP VIEW [IF EXISTS] view-name; <sql_drop_view>` |br| |nbsp| EXPLAIN statement; |br| |nbsp| :ref:`INSERT INTO table-name <sql_insert>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[(column-name [, column-name ...])] <sql_insert>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`VALUES (expression [, expression ...]); <sql_insert>` |br| |nbsp| :ref:`PRAGMA [pragma-name(value) | pragma-name=value]; <sql_pragma>` |br| |nbsp| :ref:`RELEASE SAVEPOINT savepoint-name; <sql_release_savepoint>` |br| |nbsp| :ref:`REPLACE INTO table-name VALUES (expression [, expression ...]); <sql_replace>` |br| |nbsp| :ref:`ROLLBACK [TO [SAVEPOINT] savepoint-name]; <sql_rollback>` |br| |nbsp| :ref:`SAVEPOINT savepoint-name; <sql_savepoint>` |br| |nbsp| :ref:`SELECT [DISTINCT|ALL] expression [, expression ...] <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`FROM table-name | joined-table-names [AS alias]  <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WHERE expression] <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[GROUP BY expression [, expression ...]] <sql_group_by>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[HAVING expression] <sql_having>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[ORDER BY expression] <sql_order_by>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`LIMIT expression [OFFSET expression]]; <sql_limit>` |br| |nbsp| :ref:`START TRANSACTION; <sql_start_transaction>` |br| |nbsp| :ref:`TRUNCATE TABLE table-name; <sql_truncate>` |br| |nbsp| :ref:`UPDATE table-name <sql_update>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`SET column-name=expression [,column-name=expression...] <sql_update>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WHERE expression]; <sql_update>` |br| |nbsp| :ref:`VALUES (expression [, expression ...]; <sql_values>` |br| |nbsp| :ref:`WITH [RECURSIVE] common-table-expression; <sql_with>`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:958
msgid "Differences from other products"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:960
msgid "Differences from other SQL products: We believe that Tarantool's SQL conforms to the majority of the listed mandatory requirements of the core SQL:2016 standard, and we enumerate the specific conformance statements in the feature list in a section about :ref:`\"compliance with the official SQL standard\" <sql>`. We believe that the deviations which most people will find notable are: type checking is less strict, and some data definition options must be done with NoSQL syntax."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:969
msgid "Differences from other NoSQL products: We have examined attempts by others to paste relatively smaller subsets of SQL onto NoSQL products, and concluded that Tarantool's SQL has demonstrably more features and capabilities. The reason is that we started with a complete code base of a working SQL DBMS and made it work with Tarantool-NoSQL underneath, rather than starting with a NoSQL DBMS and adding syntax to it."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:977
msgid "Concepts"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:979
msgid "In an earlier section of this documentation, we discussed: |br| What are: relational databases, tables, views, rows, and columns? |br| What are: transactions, write-ahead logs, commits and rollbacks? |br| What are: security considerations? |br| How do we: add, delete, or update rows in tables? |br| How do we: work inside transactions with commits and/or rollbacks? |br| How do we: select, join, filter, group, and sort rows?"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:987
msgid "Tarantool has a \"schema\". A schema is a container for all database objects. A schema may be called a \"database\" in other DBMS implementations"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:990
msgid "Tarantool allows four types of \"database objects\" to be created within the schema: tables, triggers, indexes, and constraints. Within tables, there are \"columns\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:994
msgid "Almost all Tarantool SQL statements begin with a reserved-word \"verb\" such as INSERT, and end optionally with a semicolon. For example: ``INSERT INTO t VALUES (1);``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:998
msgid "A Tarantool SQL database and a Tarantool NoSQL database are the same thing. However, some operations are only possible with SQL, and others are only possible with NoSQL. Mixing SQL statements with NoSQL requests is allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1002
msgid "Tokens"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1004
msgid "The token is the minimum SQL-syntax unit that Tarantool understands. These are the types of tokens:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1007
msgid "Keywords -- official words in the language, for example ``SELECT`` |br| Literals -- constants for numbers or strings, for example ``15.7`` or ``'Taranto'`` |br| Identifiers -- for example column55 or table_of_accounts |br| Operators (strictly speaking \"non-alphabetic operators\") -- for example ``* / + - ( ) , ; < = >=``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1012
msgid "Tokens can be separated from each other by one or more separators: |br| * White space characters: tab (U+0009), line feed (U+000A), vertical tab (U+000B), form feed (U+000C), carriage return (U+000D), space (U+0020), next line (U+0085), and all the rare characters in Unicode classes Zl and Zp and Zs. For a full list see https://github.com/tarantool/tarantool/issues/2371. * Bracketed comments (beginning with /* and ending with */) * Simple comments (beginning with -- and ending with line feed) Separators are not necessary before or after operators. |br| Separators are necessary after keywords or numbers or ordinary identifiers, unless the following token is an operator. |br| Thus Tarantool can understand this series of six tokens: |br| ``SELECT'a'FROM/**/t;`` |br| but for readability one would usually use spaces to separate tokens: |br| ``SELECT 'a' FROM /**/ t;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1025
msgid "Literals"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1027
msgid "There are five kinds of literals: BOOLEAN INTEGER NUMBER STRING VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1029
msgid "BOOLEAN literals:  |br| TRUE | FALSE | UNKNOWN |br| A literal has :ref:`data type = BOOLEAN <sql_data_type_boolean>` if it is the keyword TRUE or FALSE. UNKNOWN is a synonym for NULL. A literal may have type = BOOLEAN if it is the keyword NULL and there is no context to indicate a different data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1035
msgid "INTEGER literals: |br| [plus-sign | minus-sign] digit [digit ...] |br| or, for a hexadecimal integer literal, |br| [plus-sign | minus-sign] 0X | 0x hexadecimal-digit [hexadecimal-digit ...] |br| Examples: 5, -5, +5, 55555, 0X55, 0x55 |br| Hexadecimal 0X55 is equal to decimal 85. A literal has :ref:`data type = INTEGER <sql_data_type_integer>` if it contains only digits and is in the range  -9223372036854775808 to +18446744073709551615, integers outside that range are illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1044
msgid "NUMBER literals: |br| [plus-sign | minus-sign] [digit [digit ...]] period [digit [digit ...]] |br| [E|e [plus-sign | minus-sign] digit ...] |br| Examples: .0, 1.0, 1E5, 1.1E5. |br| A literal has :ref:`data type = NUMBER <sql_data_type_number>` if it contains a period, or contains \"E\". NUMBER literals are also known as real literals or floating-point literals or approximate-numeric literals. To represent \"Inf\" (infinity), write a real number outside the double-precision number range, for example 1E309. To represent \"nan\" (not a number), write an expression that does not result in a real number, for example 0/0, using Tarantool/NoSQL. This will appear as NULL in Tarantool/SQL. In a future version literals containing periods will not be considered to be NUMBER literals. In a future version \"nan\" may not appear as NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1056
msgid "STRING literals: |br| [quote] [character ...] [quote] |br| Examples: ``'ABC'``, ``'AB''C'`` |br| A literal has :ref:`data type type = STRING <sql_data_type_string>` if it is a sequence of zero or more characters enclosed in single quotes. The sequence ``''``  (two single quotes in a row) is treated as ``'`` (a single quote) when enclosed in quotes, that is, ``'A''B'`` is interpreted as ``A'B``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1064
msgid "VARBINARY literals: |br| X|x [quote] [hexadecimal-digit-pair ...] [quote] |br| Example: ``X'414243'``, which will be displayed as ``'ABC'``. |br| A literal has :ref:`data type = VARBINARY <sql_data_type_varbinary>` (\"variable-length binary\") if it is the letter X followed by quotes containing pairs of hexadecimal digits, representing byte values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1070
msgid "Here are four ways to put non-ASCII characters,such as the Greek letter α alpha,  in string literals: |br| First make sure that your shell program is set to accept characters as UTF-8. A simple way to check is |br| ``SELECT hex('α');`` If the result is CEB1 -- which is the hexadecimal value for the UTF-8 representation of α -- it is good. |br| (1) Simply enclose the character inside ``'...'``, |br| ``'α'`` |br| or |br| (2) Find out what is the hexadecimal code for the UTF-8 representation of α, and enclose that inside ``X'...'``, then cast to STRING because ``X'...'`` literals are data type VARBINARY not STRING, |br| ``CAST(X'CEB1' AS STRING)`` |br| or |br| (3) Find out what is the Unicode code point for α, and pass that to the :ref:`CHAR function <sql_function_char>`. |br| ``CHAR(945)  /* remember that this is α as data type STRING not VARBINARY */`` |br| (4) Enclose statements inside double quotes and include Lua escapes, for example ``box.execute(\"SELECT '\\206\\177';\")`` |br| One can use the concatenation operator ``||`` to combine characters made with any of these methods."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1087
msgid "Limitations: (`Issue#2344 <https://github.com/tarantool/tarantool/issues/2344>`_) |br| ~ Numeric literals may be quoted, one cannot depend on the presence or absence of quote marks to determine whether a literal is numeric. |br| ~ ``LENGTH('A''B') = 3`` which is correct, but the display from ``SELECT A''B;`` is ``A''B``, which is misleading. |br| ~ It is unfortunate that ``X'41'`` is a byte sequence which looks the same as ``'A'``, but it is not the same. ``box.execute(\"select 'A' < X'41';\")`` returns true. This happens because ``TYPEOF(X'41')`` yields ``'varbinary'``. Also it is illegal to say ``UPDATE ... SET string_column = X'41'``, one must say ``UPDATE ... SET string_column = CAST(X'41' AS STRING);``. |br| ~ It is non-standard to say that any number which contains a period has data type = NUMBER."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1101
msgid "Identifiers"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1103
msgid "All database objects -- tables, triggers, indexes, columns, constraints, functions, collations -- have identifiers. An identifier should begin with a letter or underscore (``'_'``) and should contain only letters, digits, dollar signs (``'$'``), or underscores. The maximum number of bytes in an identifier is between 64982 and 65000. For compatibility reasons, Tarantool recommends that an identifier should not have more than 30 characters."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1109
msgid "Letters in identifiers do not have to come from the Latin alphabet, for example the Japanese syllabic ひ and the Cyrillic letter д are legal. But be aware that a Latin letter needs only one byte but a Cyrillic letter needs two bytes, so Cyrillic identifiers consume a tiny amount more space."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1116
msgid "Certain words are reserved and should not be used for identifiers. The simple rule is: if a word means something in Tarantool SQL syntax, do not try to use it for an identifier. The current list of reserved words is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1120
msgid "ALL ALTER ANALYZE AND ANY AS ASC ASENSITIVE AUTOINCREMENT BEGIN BETWEEN BINARY BLOB BOOL BOOLEAN BOTH BY CALL CASE CAST CHAR CHARACTER CHECK COLLATE COLUMN COMMIT CONDITION CONNECT CONSTRAINT CREATE CROSS CURRENT CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR DATE DATETIME dec DECIMAL DECLARE DEFAULT DEFERRABLE DELETE DENSE_RANK DESC DESCRIBE DETERMINISTIC DISTINCT DOUBLE DROP EACH ELSE ELSEIF END ESCAPE EXCEPT EXISTS EXPLAIN FALSE FETCH FLOAT FOR FOREIGN FROM FULL FUNCTION GET GRANT GROUP HAVING IF IMMEDIATE IN INDEX INNER INOUT INSENSITIVE INSERT INT INTEGER INTERSECT INTO IS ITERATE JOIN LEADING LEAVE LEFT LIKE LIMIT LOCALTIME LOCALTIMESTAMP LOOP MATCH NATURAL NOT NULL NUM NUMBER NUMERIC OF ON OR ORDER OUT OUTER OVER PARTIAL PARTITION PRAGMA PRECISION PRIMARY PROCEDURE RANGE RANK READS REAL RECURSIVE REFERENCES REGEXP RELEASE RENAME REPEAT REPLACE RESIGNAL RETURN REVOKE RIGHT ROLLBACK ROW ROWS ROW_NUMBER SAVEPOINT SCALAR SELECT SENSITIVE SET SIGNAL SIMPLE SMALLINT SPECIFIC SQL START STRING SYSTEM TABLE TEXT THEN TO TRAILING TRANSACTION TRIGGER TRIM TRUE TRUNCATE UNION UNIQUE UNKNOWN UNSIGNED UPDATE USER USING VALUES VARBINARY VARCHAR VIEW WHEN WHENEVER WHERE WHILE WITH"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1180
msgid "Identifiers may be enclosed in double quotes. These are called quoted identifiers or \"delimited identifiers\" (unquoted identifiers may be called \"regular identifiers\"). The double quotes are not part of the identifier. A delimited identifier may be a reserved word and may contain any printable character. Tarantool converts letters in regular identifiers to upper case before it accesses the database, so for statements like ``CREATE TABLE a (a INTEGER PRIMARY KEY);`` or ``SELECT a FROM a;`` the table name is A and the column name is A. However, Tarantool does not convert delimited identifiers to upper case, so for statements like ``CREATE TABLE \"a\" (\"a\" INTEGER PRIMARY KEY);`` or ``SELECT \"a\" FROM \"a\";`` the table name is a and the column name is a. The sequence ``\"\"`` is treated as ``\"`` when enclosed in double quotes, that is, ``\"A\"\"B\"`` is interpreted as ``\"A\"B\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1201
msgid "Examples: things, t45, journal_entries_for_2017, ддд, ``\"into\"``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1203
msgid "Inside certain statements, identifiers may have \"qualifiers\" to prevent ambiguity. A qualifier is an identifier of a higher-level object, followed by a period. For example column1 within table1 may be referred to as table1.column1. The \"name\" of an object is the same as its identifier, or its qualified identifier. For example, inside ``SELECT t1.column1, t2.column1 FROM t1, t2;`` the qualifiers make it clear that the first column is column1 from table1 and the second column is column2 from table2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1211
msgid "The rules are sometimes relaxed for compatibility reasons. Some non-letter characters such as $ and « are legal. Delimited column identifiers may begin with characters other than letters or underscores. However, it is better to assume that rules are never relaxed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1216
msgid "The following are examples of legal and illegal identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1218
msgid "_A1   -- legal, begins with underscore and contains underscore | letter | digit\n"
"1_A   -- illegal, begins with digit\n"
"A$« -- legal, but not recommended, try to stick with digits and letters and underscores\n"
"+ -- illegal, operator token\n"
"grant -- illegal, GRANT is a reserved word\n"
"\"grant\" -- legal, delimited identifiers may be reserved words\n"
"\"_space\" -- legal, but Tarantool already uses this name for a system space\n"
"\"A\".\"X\" -- legal, for columns only, inside statements where qualifiers may be necessary\n"
"'a' -- illegal, single quotes are for literals not identifiers\n"
"A123456789012345678901234567890 -- legal, identifiers can be long\n"
"ддд -- legal, and will be converted to upper case in identifiers"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1232
msgid "The following example shows that conversion to upper case affects regular identifiers but not delimited identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1234
msgid "CREATE TABLE \"q\" (\"q\" INTEGER PRIMARY KEY);\n"
"SELECT * FROM q;\n"
"-- Result = \"error: 'no such table: Q'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1242
msgid "Operands"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1244
msgid "An operand is something that can be operated on. Literals and column identifiers are operands. So are NULL and DEFAULT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1246
msgid "NULL and DEFAULT are keywords which represent values whose data types are not known until they are assigned or compared, so they are known by the technical term \"contextually typed value specifications\". (Exception: for the non-standard statement \"SELECT NULL FROM table-name;\"  NULL has data type BOOLEAN.)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1250
msgid "Every operand has a data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1252
msgid "For literals, :ref:`as we saw earlier <sql_literals>`, the data type is usually determined by the format."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1254
msgid "For identifiers, the data type is usually determined by the definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1256
msgid "The usual determination may change because of context or because of :ref:`explicit casting <sql_function_cast>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1259
msgid "For some SQL data type names there are *aliases*. An alias may be used for data definition. For example VARCHAR(5) and TEXT are aliases of STRING and may appear in :samp:`CREATE TABLE {table_name} ({column_name} VARCHAR(5) PRIMARY KEY);` but Tarantool, if asked, will report that the data type of :samp:`{column_name}` is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1265
msgid "For every SQL data type there is a corresponding NoSQL type, for example an SQL STRING is stored in a NoSQL space as :ref:`type = 'string' <index-box_string>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1268
msgid "To avoid confusion in this manual, all references to SQL data type names are in upper case and all similar words which refer to NoSQL types or to other kinds of object are in lower case, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1272
msgid "STRING is a data type name, but string is a general term;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1273
msgid "NUMBER is a data type name, but number is a general term."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1275
msgid "Although it is common to say that a VARBINARY value is a \"binary string\", this manual will not use that term and will instead say \"byte sequence\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1278
msgid "Here are all the SQL data types, their corresponding NoSQL types, their aliases, and minimum / maximum literal examples."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1283
#: ../doc/reference/reference_sql/sql.rst:2118
msgid "**Data types**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1291
msgid "SQL type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1291
msgid "NoSQL type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1291
msgid "Aliases"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1291
msgid "Minimum"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1291
msgid "Maximum"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
msgid "BOOLEAN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
msgid "BOOL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
#: ../doc/reference/reference_sql/sql.rst:1306
msgid "FALSE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
msgid "TRUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1295
msgid "INTEGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1295
msgid "INT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1295
msgid "-9223372036854775808"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1295
#: ../doc/reference/reference_sql/sql.rst:1297
msgid "18446744073709551615"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1297
msgid "UNSIGNED"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1297
msgid "unsigned"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1297
#: ../doc/reference/reference_sql/sql.rst:1299
#: ../doc/reference/reference_sql/sql.rst:1304
#: ../doc/reference/reference_sql/sql.rst:1306
msgid "(none)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1297
msgid "0"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1299
msgid "NUMBER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1299
msgid "-1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1299
msgid "1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1301
msgid "STRING"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1301
msgid "TEXT, VARCHAR(n)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1301
msgid "``''``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1301
msgid "``'many-characters'``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
msgid "VARBINARY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
msgid "varbinary"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
msgid "``X''``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
#: ../doc/reference/reference_sql/sql.rst:1306
msgid "``X'many-hex-digits'``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1306
msgid "SCALAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1311
msgid "BOOLEAN values are FALSE, TRUE, and UNKNOWN (which is the same as NULL). FALSE is less than TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1316
msgid "INTEGER values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between -2^63 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1322
msgid "UNSIGNED values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between 0 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1328
msgid "NUMBER values are numbers that do contain decimal points (for example 0.5) or are expressed with exponential notation (for example 5E-1). The range of possible values is the same as for the IEEE 754 floating-point standard, or NULL. Numbers outside the range of NUMBER literals may be displayed as -inf or inf."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1336
msgid "STRING values are any sequence of zero or more characters encoded with UTF-8, or NULL. The possible character values are the same as for the Unicode standard. Byte sequences which are not valid UTF-8 characters are allowed but not recommended. STRING literal values are enclosed within single quotes, for example ``'literal'``. If the VARCHAR alias is used for column definition, it must include a maximum length, for example column_1 VARCHAR(40). However, the maximum length is ignored. The data-type may be followed by :ref:`[COLLATE collation-name] <sql_collate_clause>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1346
msgid "VARBINARY values are any sequence of zero or more octets (bytes), or NULL. VARBINARY literal values are expressed as X followed by pairs of hexadecimal digits enclosed within single quotes, for example ``X'0044'``. VARBINARY's NoSQL equivalent is ``'varbinary'`` but not character string -- the MessagePack storage is MP_BIN (MsgPack binary)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1354
msgid "SCALAR can be used for :ref:`column definitions <sql_column_def_data_type>` but the individual column values have one of the preceding types -- BOOLEAN, INTEGER, UNSIGNED, NUMBER, STRING, or VARBINARY. See more about SCALAR in the section :ref:`Column definition -- the rules for the SCALAR data type <sql_column_def_scalar>`. The data-type may be followed by :ref:`[COLLATE collation-name] <sql_collate_clause>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1361
msgid "Any value of any data type may be NULL. Ordinarily NULL will be cast to the data type of any operand it is being compared to or to the data type of the column it is in. If the data type of NULL cannot be determined from context, it is BOOLEAN."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1366
msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types <details_about_index_field_types>` with the same name. There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. If Tarantool/SQL reads a Tarantool/NoSQL value which has a type which has no SQL equivalent, Tarantool/SQL may treat it as NULL or INTEGER or VARBINARY. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is ``'map'``. Such columns can only be manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1375
msgid "Operators"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1377
msgid "An operator signifies what operation can be performed on operands."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1379
msgid "Almost all operators are easy to recognize because they consist of one-character or two-character non-alphabetic tokens, except for six keyword operators (AND IN IS LIKE NOT OR)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1382
msgid "Almost all operators are \"dyadic\", that is, they are performed on a pair of operands -- the only operators that are performed on a single operand are NOT and ~ and (sometimes) -."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1385
msgid "The result of an operation is a new operand. If the operator is a comparison operator then the result has data type BOOLEAN (TRUE or FALSE or UNKNOWN). Otherwise the result has the same data type as the original operands, except that: promotion to a broader type may occur to avoid overflow. Arithmetic with NULL operands will result in a NULL operand."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1391
msgid "In the following list of operators, the tag \"(arithmetic)\" indicates that all operands are expected to be numbers and should result in a number; the tag \"(comparison)\" indicates that operands are expected to have similar data types and should result in a BOOLEAN; the tag \"(logic)\" indicates that operands are expected to be BOOLEAN and should result in a BOOLEAN. Exceptions may occur where operations are not possible, but see the \"special situations\" which are described after this list. Although all examples show literals, they could just as easily show column identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1402
msgid "``+`` addition (arithmetic) Add two numbers according to standard arithmetic rules. Example: ``1 + 5``, result = 6."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1408
msgid "``-`` subtraction (arithmetic) Subtract second number from first number according to standard arithmetic rules. Example: ``1 - 5``, result = -4."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1412
msgid "``*`` multiplication (arithmetic) Multiply two numbers according to standard arithmetic rules. Example: ``2 * 5``, result = 10."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1416
msgid "``/`` division (arithmetic) Divide second number into first number according to standard arithmetic rules. Division by zero is not legal. Division of integers always results in rounding down, use :ref:`CAST <sql_function_cast>` to NUMBER to get non-integer results. Example: ``5 / 2``, result = 2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1423
msgid "``%`` modulus (arithmetic) Divide second number into first number according to standard arithmetic rules. The result is the remainder. Example: ``17 % 5``, result = 2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1428
msgid "``<<`` shift left (arithmetic) Shift the first number to the left N times, where N = the second number. For positive numbers, each 1-bit shift to the left is equivalent to multiplying times 2. Example: ``5 << 1``, result = 10."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1433
msgid "``>>`` shift right (arithmetic) Shift the first number to the right N times, where N = the second number. For positive numbers, each 1-bit shift to the right is equivalent to dividing by 2. Example: ``5 >> 1``, result = 2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1438
msgid "``&`` and (arithmetic) Combine the two numbers, with 1 bits in the result if and only if both original numbers have 1 bits. Example: ``5 & 4``, result = 4."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1442
msgid "``|`` or (arithmetic) Combine the two numbers, with 1 bits in the result if either original number has a 1 bit. Example: ``5 | 2`` result = 7."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1446
msgid "``~`` negate (arithmetic), sometimes called bit inversion Change 0 bits to 1 bits, change 1 bits to 0 bits. Example: ``~5`` result = -6."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1450
msgid "``<`` less than (comparison) Return TRUE if the first operand is less than the second by arithmetic or collation rules. Example for numbers: ``5 < 2``, result = FALSE. Example for strings: ``'C' < ' '``, result = FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1454
msgid "``<=`` less than or equal (comparison) Return TRUE if the first operand is less than or equal to the second by arithmetic or collation rules. Example for numbers: ``5 <= 5``, result = TRUE. Example for strings: ``'C' <= 'B'``, result = FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1458
msgid "``>`` greater than (comparison) Return TRUE if the first operand is greater than the second by arithmetic or collation rules. Example for numbers: ``5 > -5``, result = TRUE. Example for strings: ``'C' > '!'``, result = TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1462
msgid "``>=`` greater than or equal (comparison) Return TRUE if the first operand is greater than or equal to the second by arithmetic or collation rules. Example for numbers: ``0 >= 0``, result = TRUE. Example for strings: ``'Z' >= 'Γ'``, result = FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1468
msgid "``=`` equal (assignment) or comparison) After the word SET, \"=\" means the first operand gets the value from the second operand. In other contexts, \"=\" returns TRUE if operands are equal. Example for assignment: ``... SET column1 = 'a';`` Examples for numbers: ``0 = 0``, result = TRUE. Example for strings:  ``'1' = '2 '``, result = FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1474
msgid "``==`` equal (assignment), or equal (comparison) This is a non-standard equivalent of :ref:`\"= (assignment or comparison)\" <sql_equal>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1480
msgid "``<>`` not equal (comparison) Return TRUE if the first operand is not equal to the second by arithmetic or collation rules."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1483
msgid "``!=`` not equal (comparison) This is a non-standard equivalent of \"<> (comparison)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1487
msgid "``IS NULL`` and ``IS NOT NULL`` (comparison) For IS NULL: Return TRUE if the first operand is NULL, otherwise return FALSE. Example: column1 IS NULL, result = TRUE if column1 contains NULL. For IS NOT NULL: Return FALSE if the first operand is NULL, otherwise return TRUE. Example: ``column1 IS NOT NULL``, result = FALSE if column1 contains NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1495
msgid "``LIKE`` (comparison) Perform a comparison of two string operands. If the second operand contains ``'_'``, the ``'_'`` matches any single character in the first operand. If the second operand contains ``'%'``, the ``'%'`` matches 0 or more characters in the first operand. If it is necessary to search for either ``'_'`` or ``'%'`` within a string without treating it specially, an optional clause can be added, ESCAPE single-character-operand, for example ``'abc_' LIKE 'abcX_' ESCAPE 'X'`` is TRUE because ``X'`` means \"following character is not special\". Matching is also affected by the string's collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1504
msgid "``NOT`` negation (logic) Return TRUE if operand is FALSE return FALSE if operand is TRUE, else return UNKNOWN. Example: ``NOT (1 > 1)``, result = TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1508
msgid "``IN`` is equal to one of a list of operands (comparison) Return TRUE if first operand equals any of the operands in a parenthesized list. Example: ``1 IN (2,3,4,1,7)``, result = TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1512
msgid "``AND`` and (logic) Return TRUE if both operands are TRUE. Return UNKNOWN if both operands are UNKNOWN. Return UNKNOWN if one operand is TRUE and the other operand is UNKNOWN. Return FALSE if one operand is FALSE and the other operand is (UNKNOWN or TRUE or FALSE)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1518
msgid "``OR`` or (logic) Return TRUE if either operand is TRUE. Return FALSE if both operands are false. Return UNKNOWN if one operand is UNKNOWN and the other operand is (UNKNOWN or FALSE)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1523
msgid "``||`` concatenate (string manipulation) Return the value of the first operand concatenated with the value of the second operand. Example: ``'A' || 'B'``, result = ``'AB'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1527
msgid "The precedence of dyadic operators is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1529
msgid "||\n"
"* / %\n"
"+ -\n"
"<< >> & |\n"
"<  <= > >=\n"
"=  == != <> IS IS NOT IN LIKE\n"
"AND\n"
"OR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1540
msgid "To ensure a desired precedence, use () parentheses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1542
msgid "Special Situations"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1544
msgid "If one of the operands has data type NUMBER, Tarantool uses floating-point arithmetic. This means that exact results are not guaranteed and rounding may occur without warning. For example, 4.7777777777777778 = 4.7777777777777777 is TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1548
msgid "The floating-point values inf and -inf are possible. For example, ``SELECT 1e318, -1e318;`` will return \"inf, -inf\". Arithmetic on infinite values may cause NULL results, for example ``SELECT 1e318 - 1e318;`` is NULL. and ``SELECT 1e318 * 0;`` is NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1553
msgid "SQL operations never return the floating-point value -nan, although it may exist in data created by Tarantool's NoSQL. In SQL, -nan is treated as NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1556
msgid "A string will be converted to a number if it is used with an arithmetic operator and conversion is possible, for example ``'7' + '7'`` = 14. And for comparison or assignment, ``'7'`` = 7. This is called implicit casting. It is applicable for STRINGs and all numeric data types."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1561
msgid "Limitations: (`Issue#2346 <https://github.com/tarantool/tarantool/issues/2346>`_) * Some words, for example MATCH and REGEXP, are reserved but are not necessary for current or planned Tarantool versions * 999999999999999 << 210 yields 0. (1 << 63) >> 63 yields -1."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1565
msgid "Expressions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1567
msgid "An expression is a chunk of syntax that causes return of a value. Expressions may contain literals, column-names, operators, and parentheses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1570
msgid "Therefore these are examples of expressions: ``1``, ``1 + 1 << 1``, ``(1 = 2) OR 4 > 3``, ``'x' || 'y' || 'z'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1573
msgid "Also there are two expressions that involve keywords:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1576
msgid "value IS [NOT] NULL |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1576
msgid "... for determining whether value is (not) NULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1579
msgid "CASE ... WHEN ... THEN ... ELSE ... END |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1579
msgid "... for setting a series of conditions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1581
msgid "See also: :ref:`subquery <sql_subquery>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1583
msgid "Limitations: IS TRUE and IS FALSE return an error."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1585
msgid "Comparing and Ordering"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1587
msgid "There are rules for determining whether value-1 is \"less than\", \"equal to\", or \"greater than\" value-2. These rules are applied for searches, for sorting results in order by column values, and for determining whether a column is unique. The result of a comparison of two values can be TRUE, FALSE, or UNKNOWN (the three BOOLEAN values). Sometimes for retrieval TRUE is converted to 1, FALSE is converted to 0, UNKNOWN is converted to NULL. For any comparisons where neither operand is NULL, the operands are \"distinct\" if the comparison result is FALSE. For any set of operands where all operands are distinct from each other, the set is considered to be \"unique\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1596
msgid "When comparing a number to a number: * infinity = infinity is true * regular numbers are compared according to usual arithmetic rules"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1600
msgid "When comparing any value to NULL: (for examples in this paragraph assume that column1 in table T contains {NULL, NULL, 1, 2}) * value comparison-operator NULL is UNKNOWN (not TRUE and not FALSE), which affects \"WHERE condition\" because the condition must be TRUE, and does not affect  \"CHECK (condition)\" because the condition must be either TRUE or UNKNOWN. Therefore SELECT * FROM T WHERE column1 > 0 OR column1 < 0 OR column1 = 0; returns only  {1,2}, and the table can have been created with CREATE TABLE T (... column1 INTEGER, CHECK (column1 >= 0)); * for any operations that contain the keyword DISTINCT, NULLs are not distinct. Therefore SELECT DISTINCT column2 FROM T; will return {1,2,NULL}. * for grouping, NULL values sort together. Therefore SELECT column2, COUNT(*) FROM T GROUP BY column2; will include a row {NULL, 2}. * for ordering, NULL values sort together and are less than non-NULL values. Therefore SELECT column2 FROM T ORDER BY column2; returns {NULL, NULL, 1,2}. * for evaluating a UNIQUE constraint or UNIQUE index, any number of NULLs is okay. Therefore CREATE UNIQUE INDEX i ON T (column2); will succeed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1608
msgid "When comparing a number to a STRING: * Numbers come first if implicit casting is not possible. For example, ``1 < ''`` is TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1611
msgid "When comparing a BOOLEAN to a BOOLEAN: TRUE is greater than FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1614
msgid "When comparing a VARBINARY to a VARBINARY: * The numeric value of each pair of bytes is compared until the end of the byte sequences or until inequality. If two byte sequences are otherwise equal but one is longer, then the longer one is greater."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1617
msgid "When comparing for the sake of eliminating duplicates: * This is usually signalled by the word DISTINCT, so it applies to SELECT DISTINCT, to set operators such as UNION (where DISTINCT is implied), and to aggregate functions such as  AVG(DISTINCT). * Two operators are \"not distinct\" if they are equal to each other, or are both NULL * If two values are equal but not identical, for example 1.0 and 1.00, they are non-distinct and there is no way to specify which one will be eliminated * Values in primary-key or unique columns are distinct due to definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1623
msgid "When comparing a STRING to a STRING: * Ordinarily collation is \"binary\", that is, comparison is done according to the numeric values of the bytes. This can be cancelled by adding a :ref:`COLLATE clause <sql_collate_clause>` at the end of either expression. So ``'A' < 'a'`` and ``'a' < 'Ä'``, but ``'A' COLLATE \"unicode_ci\" = 'a'`` and ``'a' COLLATE \"unicode_ci\" = 'Ä'``. * When comparing a column with a string literal, the column's defined collation is used. * Ordinarily trailing spaces matter. So ``'a' = 'a  '`` is not TRUE. This can be cancelled by using the :ref:`TRIM(TRAILING ...) <sql_function_trim>` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1628
msgid "Limitations: * LIKE comparisons return integer results according to meta-information. * LIKE is not expected to work with VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1632
msgid "Data Type Conversion"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1634
msgid "Data type conversion, also called casting, is necessary for any operation involving two operands X and Y, when X and Y have different data types. Or, casting is necessary for assignment operations (when INSERT or UPDATE is putting a value of type X into a column defined as type Y). Casting can be \"explicit\" when a user uses the :ref:`CAST <sql_function_cast>` function, or \"implicit\" when Tarantool does a conversion automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1640
msgid "The general rules are fairly simple: Assignments and operations involving NULL cause NULL or UNKNOWN results. For arithmetic, convert to the data type which can contain both operands and the result. For explicit casts, if a meaningful result is possible, the operation is allowed. For implicit casts, if a meaningful result is possible and the data types on both sides are either STRINGs or numbers (that is, are STRING or INTEGER or UNSIGNED or NUMBER), the operation is allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1648
msgid "The specific situations in this chart follow the general rules:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1650
msgid "~                To BOOLEAN | To INTEGER | To NUMBER | To STRING | To VARBINARY\n"
"---------------  ----------   ----------   ---------   ---------   ------------\n"
"From BOOLEAN   | AAA        | A--        | ---       | A--       | ---\n"
"From INTEGER   | A--        | AAA        | AAA       | AAA       | ---\n"
"From NUMBER    | A--        | SSA        | AAA       | AAA       | ---\n"
"From STRING    | S--        | SSS        | SSS       | AAA       | A--\n"
"From VARBINARY | ---        | ---        | ---       | A--       | AAA"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1660
msgid "Where each entry in the chart has 3 characters: Where A = Always allowed, S = Sometimes allowed, - = Never allowed. The first character of an entry is for explicit casts, the second character is for implicit casts for assignment, the third character is for implicit cast for comparison. So AAA = Always for explicit, Always for Implicit (assignment), Always for Implicit (comparison)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1667
msgid "The S \"Sometimes allowed\" character applies for these special situations: From STRING To BOOLEAN is allowed if UPPER(string-value) = ``'TRUE'`` or ``'FALSE'``. From NUMBER to INTEGER is allowed for cast and assignment only if the result is not out of range. From STRING to INTEGER or NUMBER is allowed only if the string has a representation of a number."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1672
msgid "The chart does not show To|From SCALAR because the conversions depend on the type of the value, not the type of the column definition. Explicit cast to SCALAR is allowed but has no effect, the result data type is always the same as the original data type. But comparisons of values of different types are allowed if the definition is SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1677
msgid "Examples of casts, illustrating the situations in the chart:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1679
msgid "``CAST(TRUE AS INTEGER)`` is legal because the intersection of the  \"From BOOLEAN\" row with the \"To INTEGER\" column is ``A--`` and the first letter of ``A--`` is for explicit cast and A means Always Allowed. The result is 1."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1683
msgid "``UPDATE ... SET varbinary_column = 'A'`` is illegal because the intersection of the \"From STRING\" row with the \"To VARBINARY\" column is ``A--`` and the second letter of ``A--`` is for implicit cast (assignment) and - means not allowed. The result is an error message."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1687
msgid "``1.7E-1 > 0`` is legal because the intersection of the \"From NUMBER\" row with the \"To INTEGER\" column is AAA, and the third letter of AAA is for implicit cast (comparison) and A means Always Allowed. The result is TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1691
msgid "``11 > '2'`` is legal because the intersection of the \"From INTEGER\" row with the \"To STRING\" column is AAA and the third letter of AAA is for implicit cast (comparison) and A means Always Allowed. The result is TRUE.  For detailed explanation see the following section."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1695
msgid "Implicit string/numeric cast"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1697
msgid "Special considerations may apply for casting STRINGs to/from INTEGERs/NUMBERs (numbers) for comparison or assignment."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1700
msgid "``1 = '1' /* compare a STRING with a number */`` |br| ``UPDATE ... SET string_column = 1 /* assign a number to a STRING */``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1703
msgid "For comparisons, the cast is always from STRING to number. Therefore ``1e2 = '100'`` is TRUE, and ``11 > '2'`` is TRUE. If the cast fails, then the number is less than the STRING. Therefore ``1e400 < ''`` is TRUE. Exception: for BETWEEN the cast is to the data type of the first and last operands. Therefore ``'66' BETWEEN 5 AND '7'`` is TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1710
msgid "For assignments, the cast is always from source to target. Therefore ``INSERT INTO t (integer_column) VALUES ('5');`` inserts 5. If the cast fails, then the result is an error."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1714
msgid "Implicit cast also happens if STRINGS are used in arithmetic. Therefore ``'5' / '5' = 1``. If the cast fails, then the result is an error. Therefore ``'5' / ''`` is an error."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1718
msgid "Implicit cast does NOT happen if numbers are used in concatenation, or in LIKE. Therefore ``5 || 5`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1721
msgid "In the following examples, implicit cast does not happen for SCALAR column values: |br| ``DROP TABLE scalars;`` |br| ``CREATE TABLE scalars (scalar_column SCALAR PRIMARY KEY);`` |br| ``INSERT INTO scalars VALUES (11), ('2');`` |br| ``SELECT * FROM scalars WHERE scalar_column > 11;   /* 0 rows. So 11 > '2'. */`` |br| ``SELECT * FROM scalars WHERE scalar_column < '2';  /* 1 row. So 11 < '2'. */`` |br| ``SELECT max(scalar_column) FROM scalars; /* 1 row: '2'. So 11 < '2'. */`` |br| ``SELECT sum(scalar_column) FROM scalars; /* 1 row: 13. So cast happened. */`` |br| These results are not affected by indexing, or by reversing the operands."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1731
msgid "Implicit cast does NOT happen for :ref:`GREATEST() <sql_function_greatest>` or :ref:`LEAST() <sql_function_least>`. Therefore ``LEAST('5',6)`` is 6."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1735
msgid "For function arguments: If the function description says that a parameter has a specific data type, and implicit assignment casts are allowed, then arguments which are not passed with that data type will be converted before the function is applied. For example, the :ref:`LENGTH() <sql_function_length>` function expects a STRING or VARBINARY, and INTEGER  can be converted to STRING, therefore LENGTH(15) will return the length of ``'15'``, that is, 2. But implicit cast sometimes does NOT happen for parameters. Therefore ``ABS('5')`` will cause an error message after `Issue#4159 <https://github.com/tarantool/tarantool/issues/4159>`_ is fixed. However, :ref:`TRIM(5) <sql_function_trim>` will still be legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1748
msgid "Although it is not a requirement of the SQL standard, implicit cast is supposed to help compatibility with other DBMSs. However, other DBMSs have different rules about what can be converted (for example they may allow assignment of ``'inf'`` but disallow comparison with ``'1e5'``). And, of course, it is not possible to be compatible with other DBMSs and at the same time support SCALAR, which other DBMSs do not have."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1754
msgid "Limitations (`Issue#3809 <https://github.com/tarantool/tarantool/issues/3809>`_): Result of concatenation, or out-of-bound result, may have wrong type. Parameter conversion behavior will change (`Issue#4159 <https://github.com/tarantool/tarantool/issues/4159>`_). After issue#4159 is done, LENGTH(15) will be illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1758
msgid "Statements"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1760
msgid "A statement consists of SQL-language keywords and expressions that direct Tarantool to do something with a database. Statements begin with one of the words ALTER ANALYZE COMMIT CREATE DELETE DROP EXPLAIN INSERT PRAGMA RELEASE REPLACE ROLLBACK SAVEPOINT SELECT START TRUNCATE UPDATE VALUES WITH. Statements should end with \";\" semicolon although this is not mandatory."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1766
msgid "A client sends a statement to the Tarantool server. The Tarantool server parses the statement and executes it. If there is an error, Tarantool returns an error message."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1774
msgid "SQL statements and clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1780
msgid "ALTER TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1782
#: ../doc/reference/reference_sql/sql.rst:1875
#: ../doc/reference/reference_sql/sql.rst:1965
#: ../doc/reference/reference_sql/sql.rst:2211
#: ../doc/reference/reference_sql/sql.rst:2472
#: ../doc/reference/reference_sql/sql.rst:2521
#: ../doc/reference/reference_sql/sql.rst:2578
#: ../doc/reference/reference_sql/sql.rst:2620
#: ../doc/reference/reference_sql/sql.rst:2696
#: ../doc/reference/reference_sql/sql.rst:2735
#: ../doc/reference/reference_sql/sql.rst:2808
#: ../doc/reference/reference_sql/sql.rst:2887
#: ../doc/reference/reference_sql/sql.rst:2937
#: ../doc/reference/reference_sql/sql.rst:2981
#: ../doc/reference/reference_sql/sql.rst:3321
#: ../doc/reference/reference_sql/sql.rst:3360
#: ../doc/reference/reference_sql/sql.rst:3409
#: ../doc/reference/reference_sql/sql.rst:3435
#: ../doc/reference/reference_sql/sql.rst:3498
#: ../doc/reference/reference_sql/sql.rst:3553
#: ../doc/reference/reference_sql/sql.rst:3593
#: ../doc/reference/reference_sql/sql.rst:3678
#: ../doc/reference/reference_sql/sql.rst:3745
#: ../doc/reference/reference_sql/sql.rst:3798
#: ../doc/reference/reference_sql/sql.rst:3897
#: ../doc/reference/reference_sql/sql.rst:3948
#: ../doc/reference/reference_sql/sql.rst:3983
#: ../doc/reference/reference_sql/sql.rst:4044
#: ../doc/reference/reference_sql/sql.rst:4189
#: ../doc/reference/reference_sql/sql.rst:4274
#: ../doc/reference/reference_sql/sql.rst:4344
#: ../doc/reference/reference_sql/sql.rst:4413
#: ../doc/reference/reference_sql/sql.rst:4442
#: ../doc/reference/reference_sql/sql.rst:4472
#: ../doc/reference/reference_sql/sql.rst:4501
#: ../doc/reference/reference_sql/sql.rst:4555
#: ../doc/reference/reference_sql/sql.rst:4685
#: ../doc/reference/reference_sql/sql.rst:4762
#: ../doc/reference/reference_sql/sql.rst:4778
#: ../doc/reference/reference_sql/sql.rst:4792
#: ../doc/reference/reference_sql/sql.rst:4807
#: ../doc/reference/reference_sql/sql.rst:4840
#: ../doc/reference/reference_sql/sql.rst:4856
#: ../doc/reference/reference_sql/sql.rst:4874
#: ../doc/reference/reference_sql/sql.rst:4898
#: ../doc/reference/reference_sql/sql.rst:4916
#: ../doc/reference/reference_sql/sql.rst:4934
#: ../doc/reference/reference_sql/sql.rst:4960
#: ../doc/reference/reference_sql/sql.rst:4974
#: ../doc/reference/reference_sql/sql.rst:4988
#: ../doc/reference/reference_sql/sql.rst:5003
#: ../doc/reference/reference_sql/sql.rst:5021
#: ../doc/reference/reference_sql/sql.rst:5055
#: ../doc/reference/reference_sql/sql.rst:5077
#: ../doc/reference/reference_sql/sql.rst:5096
#: ../doc/reference/reference_sql/sql.rst:5120
#: ../doc/reference/reference_sql/sql.rst:5137
#: ../doc/reference/reference_sql/sql.rst:5154
#: ../doc/reference/reference_sql/sql.rst:5225
#: ../doc/reference/reference_sql/sql.rst:5245
#: ../doc/reference/reference_sql/sql.rst:5268
#: ../doc/reference/reference_sql/sql.rst:5290
#: ../doc/reference/reference_sql/sql.rst:5309
#: ../doc/reference/reference_sql/sql.rst:5325
#: ../doc/reference/reference_sql/sql.rst:5340
#: ../doc/reference/reference_sql/sql.rst:5355
#: ../doc/reference/reference_sql/sql.rst:5369
msgid "Syntax:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1784
msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1785
msgid ":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} {constraint-definition};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1786
msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1787
msgid ":samp:`ALTER TABLE {table-name} ENABLE|DISABLE CHECK CONSTRAINT {constraint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1790
#: ../doc/reference/reference_sql/sql.rst:1795
#: ../doc/reference/reference_sql/sql.rst:1880
#: ../doc/reference/reference_sql/sql.rst:1885
#: ../doc/reference/reference_sql/sql.rst:1985
#: ../doc/reference/reference_sql/sql.rst:2215
#: ../doc/reference/reference_sql/sql.rst:2220
#: ../doc/reference/reference_sql/sql.rst:2476
#: ../doc/reference/reference_sql/sql.rst:2481
#: ../doc/reference/reference_sql/sql.rst:2525
#: ../doc/reference/reference_sql/sql.rst:2530
#: ../doc/reference/reference_sql/sql.rst:2582
#: ../doc/reference/reference_sql/sql.rst:2587
#: ../doc/reference/reference_sql/sql.rst:2624
#: ../doc/reference/reference_sql/sql.rst:2629
#: ../doc/reference/reference_sql/sql.rst:2700
#: ../doc/reference/reference_sql/sql.rst:2705
#: ../doc/reference/reference_sql/sql.rst:2741
#: ../doc/reference/reference_sql/sql.rst:2746
#: ../doc/reference/reference_sql/sql.rst:2814
#: ../doc/reference/reference_sql/sql.rst:2819
#: ../doc/reference/reference_sql/sql.rst:2891
#: ../doc/reference/reference_sql/sql.rst:2896
#: ../doc/reference/reference_sql/sql.rst:2943
#: ../doc/reference/reference_sql/sql.rst:2948
#: ../doc/reference/reference_sql/sql.rst:2993
#: ../doc/reference/reference_sql/sql.rst:2998
#: ../doc/reference/reference_sql/sql.rst:3325
#: ../doc/reference/reference_sql/sql.rst:3330
#: ../doc/reference/reference_sql/sql.rst:3364
#: ../doc/reference/reference_sql/sql.rst:3369
#: ../doc/reference/reference_sql/sql.rst:3418
#: ../doc/reference/reference_sql/sql.rst:3423
#: ../doc/reference/reference_sql/sql.rst:3440
#: ../doc/reference/reference_sql/sql.rst:3445
#: ../doc/reference/reference_sql/sql.rst:3502
#: ../doc/reference/reference_sql/sql.rst:3507
#: ../doc/reference/reference_sql/sql.rst:3557
#: ../doc/reference/reference_sql/sql.rst:3562
#: ../doc/reference/reference_sql/sql.rst:3597
#: ../doc/reference/reference_sql/sql.rst:3602
#: ../doc/reference/reference_sql/sql.rst:3749
#: ../doc/reference/reference_sql/sql.rst:3754
#: ../doc/reference/reference_sql/sql.rst:3802
#: ../doc/reference/reference_sql/sql.rst:3807
#: ../doc/reference/reference_sql/sql.rst:3907
#: ../doc/reference/reference_sql/sql.rst:3912
#: ../doc/reference/reference_sql/sql.rst:3952
#: ../doc/reference/reference_sql/sql.rst:3957
#: ../doc/reference/reference_sql/sql.rst:4050
#: ../doc/reference/reference_sql/sql.rst:4055
#: ../doc/reference/reference_sql/sql.rst:4120
#: ../doc/reference/reference_sql/sql.rst:4125
#: ../doc/reference/reference_sql/sql.rst:4195
#: ../doc/reference/reference_sql/sql.rst:4200
#: ../doc/reference/reference_sql/sql.rst:4205
#: ../doc/reference/reference_sql/sql.rst:4210
#: ../doc/reference/reference_sql/sql.rst:4278
#: ../doc/reference/reference_sql/sql.rst:4283
#: ../doc/reference/reference_sql/sql.rst:4348
#: ../doc/reference/reference_sql/sql.rst:4353
#: ../doc/reference/reference_sql/sql.rst:4417
#: ../doc/reference/reference_sql/sql.rst:4422
#: ../doc/reference/reference_sql/sql.rst:4446
#: ../doc/reference/reference_sql/sql.rst:4451
#: ../doc/reference/reference_sql/sql.rst:4476
#: ../doc/reference/reference_sql/sql.rst:4481
#: ../doc/reference/reference_sql/sql.rst:4505
#: ../doc/reference/reference_sql/sql.rst:4510
msgid "|br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1797
msgid "ALTER is used to change a table's name or a table's constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1799
#: ../doc/reference/reference_sql/sql.rst:1931
#: ../doc/reference/reference_sql/sql.rst:2237
#: ../doc/reference/reference_sql/sql.rst:2274
#: ../doc/reference/reference_sql/sql.rst:2307
#: ../doc/reference/reference_sql/sql.rst:2349
#: ../doc/reference/reference_sql/sql.rst:2504
#: ../doc/reference/reference_sql/sql.rst:2557
#: ../doc/reference/reference_sql/sql.rst:2603
#: ../doc/reference/reference_sql/sql.rst:2676
#: ../doc/reference/reference_sql/sql.rst:2786
#: ../doc/reference/reference_sql/sql.rst:2851
#: ../doc/reference/reference_sql/sql.rst:2922
#: ../doc/reference/reference_sql/sql.rst:2958
#: ../doc/reference/reference_sql/sql.rst:3032
#: ../doc/reference/reference_sql/sql.rst:3345
#: ../doc/reference/reference_sql/sql.rst:3477
#: ../doc/reference/reference_sql/sql.rst:3534
#: ../doc/reference/reference_sql/sql.rst:3578
#: ../doc/reference/reference_sql/sql.rst:3655
#: ../doc/reference/reference_sql/sql.rst:3775
#: ../doc/reference/reference_sql/sql.rst:3860
#: ../doc/reference/reference_sql/sql.rst:3924
#: ../doc/reference/reference_sql/sql.rst:3966
#: ../doc/reference/reference_sql/sql.rst:4086
#: ../doc/reference/reference_sql/sql.rst:4524
#: ../doc/reference/reference_sql/sql.rst:4887
#: ../doc/reference/reference_sql/sql.rst:4947
#: ../doc/reference/reference_sql/sql.rst:5010
#: ../doc/reference/reference_sql/sql.rst:5391
msgid "Examples:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1803
msgid "For renaming a table with ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* must not exist. Example: |br| ``-- renaming a table:`` ``ALTER TABLE t1 RENAME TO t2;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1808
msgid "For adding a :ref:`table constraint <sql_table_constraints>` with ``ADD CONSTRAINT``, the table must exist, the table must be empty, the constraint name must not already exist for the table. Example with a :ref:`foreign-key constraint definition <sql_foreign_key>`: |br| ``ALTER TABLE t1 ADD CONSTRAINT fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES t1;`` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1814
msgid "It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b ...`` if table ``b`` does not exist yet. This is a situation where ``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... REFERENCES table_b ...``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1819
msgid "-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT pk_s1_t1_1 PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT uk_s1_t1_1 UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT ck_s1_t1_1 CHECK (s1 > 0);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1837
msgid "For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named constraint, and Tarantool only looks for names of foreign-key constraints. (Tarantool generates the constraint names automatically if the user does not provide them.)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1841
msgid "To remove a unique constraint, use :ref:`DROP INDEX <sql_drop_index>`, which will drop the constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1844
msgid "-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT ck_s1_t1_1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1849
msgid "For ``ALTER ... ENABLE|DISABLE CHECK CONSTRAINT``, it is only legal to enable or disable a named constraint, and Tarantool only looks for names of check constraints. By default a constraint is enabled. If a constraint is disabled, then the check will not be performed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1854
msgid "-- disabling and re-enabling a constraint:\n"
"ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
"ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1860
#: ../doc/reference/reference_sql/sql.rst:1951
#: ../doc/reference/reference_sql/sql.rst:2566
#: ../doc/reference/reference_sql/sql.rst:3301
#: ../doc/reference/reference_sql/sql.rst:3664
#: ../doc/reference/reference_sql/sql.rst:3788
#: ../doc/reference/reference_sql/sql.rst:3885
#: ../doc/reference/reference_sql/sql.rst:3935
#: ../doc/reference/reference_sql/sql.rst:4249
msgid "Limitations:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1862
msgid "It is not possible to add or drop a column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1863
msgid "It is not possible to modify NOT NULL constraints or column properties DEFAULT and :ref:`data type <sql_column_def_data_type>`. However, it is possible to modify them with Tarantool/NOSQL, for example by calling :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1873
msgid "CREATE TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1877
msgid ":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} ((column-definition or table-constraint list)` :samp:`[WITH ENGINE = {string}];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1887
msgid "Create a new base table, usually called a \"table\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1891
msgid "A table is a *base table* if it is created with CREATE TABLE and contains data in persistent storage."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1894
msgid "A table is a *viewed table*, or just \"view\", if it is created with :ref:`CREATE VIEW <sql_create_view>` and gets its data from other views or from base tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1897
msgid "The *table-name* must be an identifier which is valid according to the rules for identifiers, and must not be the name of an already existing base table or view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1900
msgid "The *column-definition* or *table-constraint* list is a comma-separated list of :ref:`column definitions <sql_column_def>` or table constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1903
msgid "A *table-element-list* must be a comma-separated list of table elements; each table element may be either a column definition or a :ref:`table constraint definition <sql_table_constraints>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1907
#: ../doc/reference/reference_sql/sql.rst:2488
#: ../doc/reference/reference_sql/sql.rst:2543
#: ../doc/reference/reference_sql/sql.rst:2640
#: ../doc/reference/reference_sql/sql.rst:2758
#: ../doc/reference/reference_sql/sql.rst:2831
#: ../doc/reference/reference_sql/sql.rst:2906
#: ../doc/reference/reference_sql/sql.rst:3008
#: ../doc/reference/reference_sql/sql.rst:3377
msgid "Rules:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1909
msgid "A primary key is necessary; it can be specified with a table constraint PRIMARY KEY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1911
msgid "There must be at least one column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1912
msgid "When IF NOT EXISTS is specified, and there is already a table with the same name, the statement is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1914
msgid "When :samp:`WITH ENGINE = {string}` is specified, where :samp:`string}` must be either 'memtx' or 'vinyl', the table is created with that :ref:`storage engine <engines-chapter>`. When this clause is not specified, the table is created with the default engine, which is ordinarily 'memtx' but may be changed by updating a table that has a list of session settings."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1922
#: ../doc/reference/reference_sql/sql.rst:2496
#: ../doc/reference/reference_sql/sql.rst:2550
#: ../doc/reference/reference_sql/sql.rst:2596
#: ../doc/reference/reference_sql/sql.rst:2648
#: ../doc/reference/reference_sql/sql.rst:2715
#: ../doc/reference/reference_sql/sql.rst:2774
#: ../doc/reference/reference_sql/sql.rst:2841
#: ../doc/reference/reference_sql/sql.rst:2912
#: ../doc/reference/reference_sql/sql.rst:3026
#: ../doc/reference/reference_sql/sql.rst:3339
#: ../doc/reference/reference_sql/sql.rst:3384
msgid "Actions:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1924
msgid "Tarantool evaluates each column definition and *table-constraint*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1926
msgid "Tarantool makes a new definition in the schema."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1927
msgid "Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A unique index name is created automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1929
#: ../doc/reference/reference_sql/sql.rst:2502
#: ../doc/reference/reference_sql/sql.rst:2555
#: ../doc/reference/reference_sql/sql.rst:2601
#: ../doc/reference/reference_sql/sql.rst:2654
#: ../doc/reference/reference_sql/sql.rst:2720
#: ../doc/reference/reference_sql/sql.rst:3030
#: ../doc/reference/reference_sql/sql.rst:3343
msgid "Tarantool effectively executes a :ref:`COMMIT <sql_commit>` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1933
msgid "-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and an inline comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY (s1, s2));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1953
msgid "The maximum number of columns is 2000."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1954
msgid "The maximum length of a row depends on the :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  <cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1963
msgid "Column definition"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1967
msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1969
msgid "Define a column, which is a table-element used in a :ref:`CREATE TABLE <sql_create_table>` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1971
msgid "The ``column-name`` must be an identifier which is valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1974
msgid "Each ``column-name`` must be unique within a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1980
msgid "Column definition -- data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1987
msgid "Every column has a data type: BOOLEAN or INTEGER or UNSIGNED or NUMBER or STRING or VARBINARY or SCALAR. The detailed description of data types is in the section :ref:`Operands <sql_operands>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1996
msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1998
msgid "SCALAR is a \"complex\" data type, unlike all the other data types which are \"primitive\". Two column values in a SCALAR column can have two different primitive data types."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2001
msgid "Any item defined as SCALAR has an underlying primitive type. For example, here:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2003
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55), ('41');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2008
msgid "the underlying primitive type of the item in the first row is INTEGER because literal 55 has data type INTEGER, and the underlying primitive type in the second row is STRING (the data type of a literal is always clear from its format)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2013
msgid "An item's primitive type is far more important than its defined type. Incidentally Tarantool might find the primitive type by looking at the way MsgPack stores it, but that is an implementation detail."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2017
msgid "A SCALAR definition may not include a maximum length, as there is no suggested restriction."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2019
msgid "A SCALAR definition may include a :ref:`COLLATE clause <sql_collate_clause>`, which affects any items whose primitive data type is STRING. The default collation is \"binary\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2021
msgid "Some assignments are illegal when data types differ, but legal when the target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is defined as SCALAR -- values which happen to be INTEGER will be changed so their data type is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2026
msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2027
msgid "TYPEOF(x) is never SCALAR, it is always the underlying data type. This is true even if ``x`` is NULL (in that case the data type is BOOLEAN). In fact there is no function that is guaranteed to return the defined data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2031
msgid "For any operation that requires implicit casting from an item defined as SCALAR, the syntax is legal but the operation may fail at runtime. At runtime, Tarantool detects the underlying primitive data type and applies the rules for that. For example, if a definition is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2036
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2040
msgid "and within any row ``s1 = 'a'``, that is, its underlying primitive type is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` is illegal. Tarantool usually does not know that in advance."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2043
msgid "For any dyadic operation that requires implicit casting for comparison, the syntax is legal and the operation will not fail at runtime. Take this situation: comparison with a primitive type VARBINARY and a primitive type STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2048
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2054
msgid "The comparison is valid, because Tarantool knows the ordering of X'41' and 'a' in Tarantool/NoSQL 'scalar'. This would be true even if ``s1`` was not defined as SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2057
msgid "The result data type of :ref:`min/max <sql_aggregate>` operation on a column defined as SCALAR is the data type of the minimum/maximum operand, unless the result value is NULL. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2061
msgid "CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT min(s2), hex(max(s2)) FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2067
msgid "The result is: ``- - [11, '44',]``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2069
msgid "That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT SUM(s2)`` would not be legal because addition would in this case require implicit casting from VARBINARY to integer, which is not sensible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2072
msgid "The result data type of a primitive combination is never SCALAR because we in effect use TYPEOF(item) not the defined data type. (Here we use the word \"combination\" in the way that the standard document uses it for section \"Result of data type combinations\".) Therefore for ``max(1E308, 'a', 0, X'00')`` the result is X'00'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2080
msgid "Column definition -- relation to NoSQL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2082
msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the same name <box_space-index_field_types>`. For example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2086
msgid "Therefore specifying an SQL data type X determines that the storage will be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2089
msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2091
msgid "If two items have SQL data types that have the same underlying type, then they are compatible for all assignment or comparison purposes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2094
msgid "If two items have SQL data types that have different underlying types, then the rules for explicit casts, or implicit (assignment) casts, or implicit (comparison) casts, apply."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2098
msgid "There is one floating-point value which is not handled by SQL: -nan is seen as NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2100
msgid "There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is 'map'. Such columns can only be manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2109
msgid "Column definition -- column-constraint or default clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2114
msgid "The column-constraint or default clause may be as follows:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2124
msgid "Comment"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2126
msgid "NOT NULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2126
msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2129
msgid "PRIMARY KEY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2129
#: ../doc/reference/reference_sql/sql.rst:2132
#: ../doc/reference/reference_sql/sql.rst:2135
msgid "explained in the later section \"Table Constraint definition\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2132
msgid "UNIQUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2135
msgid "CHECK (expression)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2138
msgid "DEFAULT expression"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2138
msgid "means \"if INSERT does not assign to this column then assign expression result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL is assumed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2145
msgid "If column-constraint is PRIMARY KEY, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraints>`: \"PRIMARY KEY (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2148
msgid "If column-constraint is UNIQUE, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraints>`: \"UNIQUE (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2151
msgid "If column-constraint is CHECK, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraints>`: \"CHECK (expression)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2154
msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2156
msgid "To enforce some restrictions that Tarantool does not enforce automatically, add CHECK clauses, like these:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2159
msgid "CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY, CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" STRING PRIMARY KEY, CHECK (length(\"shorttext\") <= 10));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2164
msgid "but this may cause inserts or updates to be slow."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2168
msgid "Column definition -- examples"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2170
msgid "These are shown within :ref:`CREATE TABLE <sql_create_table>` statements. Data types may also appear in :ref:`CAST <sql_function_cast>` functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2173
msgid "-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause and two column-constraints\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2182
msgid "-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column4 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2195
msgid "-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INTEGER PRIMARY KEY,\n"
" column2 INTEGER UNIQUE,\n"
" column3 INTEGER CHECK (column3 > column2),\n"
" column4 INTEGER REFERENCES t,\n"
" column6 INTEGER DEFAULT NULL);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2209
msgid "Table Constraints"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2213
msgid ":samp:`CONSTRAINT {constraint-name}] primary-key-constraint | unique-constraint | check-constraint | foreign-key-constraint`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2222
msgid "Define a constraint, which is a table-element used in a CREATE TABLE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2224
msgid "The constraint-name must be an identifier which is valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2226
msgid "PRIMARY KEY constraints look like this: |br| :samp:`PRIMARY KEY ({column-name} [, {column-name}...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2229
msgid "There is a shorthand: specifying PRIMARY KEY in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2231
msgid "Every table must have one and only one primary key. |br| Primary-key columns are automatically NOT NULL. |br| Primary-key columns are automatically indexed. |br| Primary-key columns are unique, that is, it is illegal to have two rows which have the same values for the columns specified in the constraint."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2239
msgid "-- this is a table with a one-column primary-key constraint\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"-- this is a table with a two-column primary-key constraint\n"
"CREATE TABLE t2 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1, s2));\n"
"-- this is an example of an attempted primary-key violation\n"
"-- (the third INSERT will fail because 55, 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER, s2 STRING, PRIMARY KEY (s1, s2));\n"
"INSERT INTO t3 VALUES (55, 'a');\n"
"INSERT INTO t3 VALUES (55, 'b');\n"
"INSERT INTO t3 VALUES (55, 'a');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2254
msgid "PRIMARY KEY plus AUTOINCREMENT modifier may be specified in one of two ways: |br| - In a column definition after the words PRIMARY KEY, as in ``CREATE TABLE t (c INTEGER PRIMARY KEY AUTOINCREMENT);`` |br| - In a PRIMARY KEY (column-list) after a column name, as in ``CREATE TABLE t (c INTEGER, PRIMARY KEY (c AUTOINCREMENT));`` |br| When AUTOINCREMENT is specified, the column must be a primary-key column and it must be INTEGER or UNSIGNED. Only one column in the table may be autoincrement. As the name suggests, values in an autoincrement column are automatically incremented. That is: if a user inserts NULL in the column, then the stored value will be the smallest non-negative integer that has not already been used. This occurs because autoincrement columns are associated with :ref:`sequences <box_schema-sequence_create_index>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2264
msgid "UNIQUE constraints look like this: |br| :samp:`UNIQUE ({column-name} [, {column-name}...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2267
msgid "There is a shorthand: specifying UNIQUE in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2269
msgid "Unique constraints are similar to primary-key constraints, except that: a table may have any number of unique keys, and unique keys are not automatically NOT NULL. |br| Unique columns are automatically indexed. |br| Unique columns are unique, that is, it is illegal to have two rows with the same values in the unique-key columns."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2276
msgid "-- this is a table with a one-column primary-key constraint\n"
"-- and a one-column unique constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1), UNIQUE (s2));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER UNIQUE);\n"
"-- this is a table with a two-column unique constraint\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2, s1));\n"
"-- this is an example of an attempted unique-key violation\n"
"-- (the third INSERT will not fail because NULL is not a duplicate)\n"
"-- (the fourth INSERT will fail because 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER PRIMARY KEY, s2 STRING, UNIQUE (s2));\n"
"INSERT INTO t3 VALUES (1, 'a');\n"
"INSERT INTO t3 VALUES (2, NULL);\n"
"INSERT INTO t3 VALUES (3, NULL);\n"
"INSERT INTO t3 VALUES (4, 'a');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2294
msgid "CHECK constraints look like this: |br| :samp:`CHECK ({expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2297
msgid "There is a shorthand: specifying CHECK in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2299
msgid "The expression may be anything that returns a BOOLEAN result = TRUE or FALSE or UNKNOWN. |br| The expression may not contain a :ref:`subquery <sql_subquery>`. |br| If the expression contains a column name, the column must exist in the table. |br| If a CHECK constraint is specified, the table must not contain rows where the expression is FALSE. (The table may contain rows where the expression is either TRUE or UNKNOWN.) |br| Constraint checking may be stopped with :ref:`ALTER TABLE ... DISABLE CHECK CONSTRAINT <sql_alter_table>` and restarted with ALTER TABLE ... ENABLE CHECK CONSTRAINT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2309
msgid "-- this is a table with a one-column primary-key constraint\n"
"-- and a check constraint\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, CHECK (s2 <> s1));\n"
"-- this is an attempt to violate the constraint, it will fail\n"
"INSERT INTO t1 VALUES (1, 1);\n"
"-- this is okay because comparison with NULL will not return FALSE\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- a constraint that makes it difficult to insert lower case\n"
"CHECK (s1 = UPPER(s1))"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2321
msgid "Limitations: (`Issue#3503 <https://github.com/tarantool/tarantool/issues/3503>`_): * ``CREATE TABLE t99 (s1 INTEGER, UNIQUE(s1, s1),PRIMARY KEY(s1));`` causes no error message, although (s1, s1) is probably a user error."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2329
msgid "Table Constraint Definition for foreign keys"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2331
msgid "FOREIGN KEY constraints look like this: |br| :samp:`FOREIGN KEY ({referencing-column-name} [, {referencing-column-name}...]) REFERENCES {referenced-table-name} [({referenced-column-name} [, {referenced-column-name}...]]) [MATCH FULL] [update-or-delete-rules]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2334
msgid "There is a shorthand: specifying REFERENCES in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2336
msgid "The referencing column names must be defined in the table that is being created. The referenced table name must refer to a table that already exists, or to the table that is being created. The referenced column names must be defined in the referenced table, and have similar data types. There must be a PRIMARY KEY or UNIQUE constraint or UNIQUE index on the referenced column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2343
msgid "The words MATCH FULL are optional and have no effect."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2345
msgid "If a foreign-key constraint exists, then the values in the referencing columns must equal values in the referenced columns of the referenced table, or at least one of the referencing columns must contain NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2351
msgid "-- A foreign key referencing a primary key in the same table\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, FOREIGN KEY (s2) REFERENCES t1 (s1));\n"
"-- The same thing with column shorthand\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER REFERENCES t1(s1));\n"
"-- An attempt to violate the constraint -- this will fail\n"
"INSERT INTO t1 VALUES (1, 2);\n"
"-- A NULL in the referencing column -- this will succeed\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- A reference to a primary key that now exists -- this will succeed\n"
"INSERT INTO t1 VALUES (2, 1);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2364
msgid "The optional update-or-delete rules look like this: |br| ``ON {UPDATE|DELETE} { CASCADE | SET DEFAULT | SET NULL | RESTRICT | NO ACTION}`` |br| and the idea is: if something changes the referenced key, then one of three possible \"referential actions\" takes place: |br| ``CASCADE``: the change that is applied for the referenced key is applied for the referencing key. |br| ``SET DEFAULT``: the referencing key is set to its default value. |br| ``SET NULL``: the referencing key is set to NULL. |br| ``RESTRICT``: the UPDATE or DELETE fails if a referencing key exists; checked immediately. |br| ``NO ACTION``: the UPDATE or DELETE fails if a referencing key exists; checked at statement end. |br| The default is ``NO ACTION``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2376
msgid "CREATE TABLE f1 (ordinal INTEGER PRIMARY KEY,\n"
"             referenced_planet STRING UNIQUE NOT NULL);\n"
"CREATE TABLE f2 (\n"
"    ordinal INTEGER PRIMARY KEY,\n"
"    referring_planet STRING DEFAULT 'Earth',\n"
"    FOREIGN KEY (referring_planet) REFERENCES f1 (referenced_planet)\n"
"        ON UPDATE SET DEFAULT\n"
"        ON DELETE CASCADE);\n"
"INSERT INTO f1 VALUES (1, 'Mercury'), (2,' Venus'), (3, 'Earth');\n"
"INSERT INTO f2 VALUES (1, 'Mercury'), (2, 'Mercury');\n"
"UPDATE f1 SET referenced_planet = 'Mars'\n"
"    WHERE referenced_planet = 'Mercury';\n"
"SELECT * FROM f2;\n"
"DELETE FROM f1 WHERE referenced_planet = 'Earth';\n"
"SELECT * FROM f2;\n"
"... In this example, the UPDATE statement changes the referenced key,\n"
"    and the clause is ON UPDATE SET DEFAULT, therefore both of the\n"
"    rows in f2 have referring_planet set to their default value,\n"
"    which is 'Earth'. The DELETE statement deletes the row that\n"
"    has 'Earth', and the clause is ON DELETE CASCADE,\n"
"    therefore both of the rows in f2 are deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2400
msgid "Limitations: * Foreign keys can have a MATCH clause (`Issue#3455 <https://github.com/tarantool/tarantool/issues/3455>`_)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2470
msgid "DROP TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2474
msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2483
msgid "Drop a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2485
msgid "The *table-name* must identify a table that was created earlier with the :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2490
msgid "If there is a view that references the table, the drop will fail. Please drop the referencing view with :ref:`DROP VIEW <sql_drop_view>` first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2492
msgid "If there is a foreign key that references the table, the drop will fail. Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP <sql_alter_table_drop_constraint>` first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2498
msgid "Tarantool returns an error if the table does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2499
msgid "The table and all its data are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2500
msgid "All indexes for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2501
msgid "All triggers for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2506
msgid "-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2513
msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2519
msgid "CREATE VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2523
msgid ":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2532
msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2534
msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2536
msgid "The optional *column-list* must be a comma-separated list of names of columns in the view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2539
msgid "The syntax of the subquery must be the same as the syntax of a :ref:`SELECT statement <sql_select>`, or of a VALUES clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2545
msgid "There must not already be a base table or view with the same name as *view-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2547
msgid "If *column-list* is specified, the number of columns in *column-list* must be the same as the number of columns in the *select-list* of the subquery."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2552
#: ../doc/reference/reference_sql/sql.rst:2650
#: ../doc/reference/reference_sql/sql.rst:3028
msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2553
msgid "Tarantool will create a new persistent object with *column-names* equal to the names in the *column-list* or the names in the subquery's *select-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2559
msgid "-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2568
msgid "It is not possible to insert or update or delete from a view, although sometimes a possible substitution is to :ref:`create an INSTEAD OF trigger <sql_create_trigger>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2576
msgid "DROP VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2580
msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2589
msgid "Drop a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2591
msgid "The *view-name* must identify a view that was created earlier with the :ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2594
#: ../doc/reference/reference_sql/sql.rst:2713
#: ../doc/reference/reference_sql/sql.rst:3337
msgid "Rules: none"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2598
msgid "Tarantool returns an error if the view does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2599
msgid "The view is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2600
msgid "All triggers for the view are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2605
msgid "-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2612
msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2618
msgid "CREATE INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2622
msgid ":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} (column-list);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2631
msgid "Create an index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2633
msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2635
msgid "The *table-name* must refer to an existing table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2637
msgid "The *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2642
msgid "There must not already be, for the same table, an index with the same name as *index-name*. But there may already be, for a different table, an index with the same name as *index-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2646
msgid "The maximum number of indexes per table is 128."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2651
msgid "If the new index is UNIQUE, Tarantool will throw an error if any row exists with columns that have duplicate values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2653
msgid "Tarantool will create a new index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2656
msgid "Automatic indexes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2658
msgid "Indexes may be created automatically for columns mentioned in the PRIMARY KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created automatically, then the *index-name* has four parts:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2662
msgid "``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a UNIQUE clause;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2664
msgid "``_unnamed_``;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2665
msgid "the name of the table;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2666
msgid "``_`` and an ordinal number; the first index is 1, the second index is 2, and so on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2669
msgid "For example, after ``CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and ``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM \"_index\";`` which will list all indexes on all tables. There is no need to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2678
msgid "-- the simple case\n"
"CREATE INDEX idx_column1_t_1 ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2687
msgid "Dropping an automatic index created for a unique constraint will drop the unique constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2694
msgid "DROP INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2698
msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2707
msgid "The *index-name* must be the name of an existing index, which was created with :ref:`CREATE INDEX <sql_create_index>`. Or, the *index-name* must be the name of an index that was created automatically due to a PRIMARY KEY or UNIQUE clause in the :ref:`CREATE TABLE <sql_create_table>` statement. To see what a table's indexes are, use :ref:`PRAGMA index_list(table-name); <sql_pragma>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2717
msgid "Tarantool throws an error if the index does not exist, or is an automatically created index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2719
msgid "Tarantool will drop the index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2724
msgid "-- the simplest form:\n"
"DROP INDEX idx_unnamed_t_1 ON t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2733
msgid "INSERT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2737
msgid ":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2738
msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2739
msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2748
msgid "Insert one or more new rows into a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2750
msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2752
msgid "The optional *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2755
msgid "The *expression-list* must be a comma-separated list of expressions; each expression may contain literals and operators and subqueries and function invocations."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2760
msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2761
msgid "The order of the values in the *expression-list* must correspond to the order of the columns in the table, or (if a *column-list* is specified) to the order of the columns in the *column-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2764
#: ../doc/reference/reference_sql/sql.rst:2834
msgid "The data type of the value should correspond to the :ref:`data type of the column <sql_column_def_data_type>`, that is, the data type that was specified with CREATE TABLE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2767
msgid "If a *column-list* is not specified, then the number of expressions must be the same as the number of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2769
msgid "If a *column-list* is specified, then some columns may be omitted; omitted columns will get default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2771
msgid "The parenthesized *expression-list* may be repeated -- ``(expression-list),(expression-list),...`` -- for multiple rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2776
msgid "Tarantool evaluates each expression in *expression-list*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2778
msgid "Tarantool creates zero or more new rows containing values based on the values in the VALUES list or based on the results of the *select-expression* or based on the default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2781
msgid "Tarantool executes constraint checks and trigger actions and the actual insertion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2782
msgid "Tarantool inserts values into the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2788
msgid "-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2800
msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2806
msgid "UPDATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2810
msgid ":samp:`UPDATE {table-name} SET column-name = expression [, column-name = expression ...] [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2821
msgid "Update zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2823
#: ../doc/reference/reference_sql/sql.rst:2900
msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>` or :ref:`CREATE VIEW <sql_create_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2826
msgid "The *column-name* must be an updatable column in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2828
msgid "The *expression* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2833
msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2837
msgid "If a *search-condition* is not specified, then all rows in the table will be updated; otherwise only those rows which match the *search-condition* will be updated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2843
msgid "Tarantool evaluates each expression in the SET clause, and returns an error if any of the rules is violated. For each row that is found by the WHERE clause, a temporary new row is formed based on the original contents and the modifications caused by the SET clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2847
msgid "Tarantool executes constraint checks and trigger actions and the actual update."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2853
msgid "-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2862
msgid "Special cases:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2864
msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2866
msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2870
msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2872
msgid "INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2877
msgid "The result is an error: \"duplicate column name\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2879
msgid "It is not legal to assign to a primary-key column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2885
msgid "DELETE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2889
msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2898
msgid "Delete zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2903
msgid "The *search-condition* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2908
msgid "If a search-condition is not specified, then all rows in the table will be deleted; otherwise only those rows which match the *search-condition* will be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2914
msgid "Tarantool evaluates each expression in the *search-condition*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2916
msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2917
msgid "Tarantool executes constraint checks and trigger actions and the actual deletion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2918
msgid "Tarantool deletes the set of matching rows from the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2924
msgid "-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2935
#: ../doc/reference/reference_sql/sql.rst:5135
msgid "REPLACE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2939
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2940
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2941
msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2950
msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2952
msgid "If a row already exists (as determined by the primary key or any unique key), then the action is delete + insert, and the rules are the same as for a :ref:`DELETE statement <sql_delete>` followed by an :ref:`INSERT statement <sql_insert>`. Otherwise the action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2960
msgid "-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2971
msgid "See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2979
msgid "CREATE TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2983
msgid ":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`INSERT|UPDATE|DELETE ON {table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN (search-condition)]` |br| :samp:`BEGIN` |br| :samp:`update-statement | insert-statement | delete-statement | select-statement;` |br| :samp:`[update-statement | insert-statement | delete-statement | select-statement; ...]` |br| :samp:`END;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3000
msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3002
msgid "If the trigger action time is BEFORE or AFTER, then the *table-name* must refer to an existing base table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3005
msgid "If the trigger action time is INSTEAD OF, then the *table-name* must refer to an existing view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3010
msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3011
msgid "Triggers on different tables or views share the same namespace."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3012
msgid "The statements between BEGIN and END should not refer to the *table-name* mentioned in the ON clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3014
msgid "The statements between BEGIN and END should not contain an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3017
msgid "SQL triggers are not activated by Tarantool/NoSQL requests. This will change in version a future version."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3020
msgid "On a :ref:`replica <Replication>`, effects of trigger execution are applied, and the SQL triggers themselves are not fired upon replication events."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3023
msgid "NoSQL triggers are fired both on replica and master, thus if you have a :ref:`NoSQL trigger <triggers>` on a replica, it is activated when applying effects of an SQL trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3029
msgid "Tarantool will create a new trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3034
msgid "-- the simple case:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3053
msgid "Trigger extra clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3055
msgid ":samp:`UPDATE OF column-list`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3057
msgid "After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any of the columns in *column-list* is affected at the time the row is processed, then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3061
msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3070
msgid ":samp:`WHEN`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3072
msgid "After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]. If the expression is true at the time the row is processed, only then will the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3076
msgid "CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3082
msgid "This trigger will not be activated unless there is more than one row in ``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3085
msgid ":samp:`OLD and NEW`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3087
msgid "The keywords OLD and NEW have special meaning in the context of trigger action:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3089
msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3090
msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3094
msgid "CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 STRING, column2 STRING, column3 INTEGER PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3105
msgid "At the beginning of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3108
msgid "At the end of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'new value' -- so that is what is seen as ``new.column1``. (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3112
msgid "Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3114
msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3116
msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3118
msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3120
msgid "Deprecated or illegal statements:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3122
msgid "It is legal for the trigger action to include a :ref:`SELECT statement <sql_select>` or a :ref:`REPLACE statement <sql_replace>`, but not recommended."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3126
msgid "It is illegal for the trigger action to include a qualified column reference other than ``OLD.column-name`` or ``NEW.column-name``. For example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1 = 5; END;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3131
msgid "It is illegal for the trigger action to include statements that include a :ref:`WITH clause <sql_with>`, a DEFAULT VALUES clause, or an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3135
msgid "It is usually not a good idea to have a trigger on ``table1`` which causes a change on ``table2``, and at the same time have a trigger on ``table2`` which causes a change on ``table1``. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3139
msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER table2_before_update\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3150
msgid "Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because Tarantool recognizes when it has already updated so it will stop. However, not every DBMS acts this way."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3158
msgid "Trigger activation"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3160
msgid "These are remarks concerning trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3162
msgid "Standard terminology:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3164
msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3165
msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3166
msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3167
msgid "\"triggered when clause\" = WHEN (search condition)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3168
msgid "\"activate\" = execute a triggered statement"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3169
msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3171
msgid "If there is more than one trigger for the same trigger event, Tarantool may execute the triggers in any order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3174
msgid "It is possible for a triggered statement to cause activation of another triggered statement. For example, this is legal:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3177
msgid "CREATE TRIGGER t1_before_delete BEFORE DELETE ON t1 BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER t2_before_delete BEFORE DELETE ON t2 BEGIN DELETE FROM t3; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3182
msgid "Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no rows are candidates for insert or update or delete, then no triggers are activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3185
msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3187
msgid "If an UPDATE trigger event does not make a change, the trigger is activated anyway. For example, if row 1 ``column1`` contains 'a', and the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3191
msgid "The triggered statement may refer to a function: ``RAISE(FAIL, error-message)``. If a triggered statement invokes a ``RAISE(FAIL, error-message)`` function, or if a triggered statement causes an error, then statement execution stops immediately."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3197
msgid "The triggered statement may refer to column values within the rows being changed. in this case:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3200
msgid "The row \"as of before\" the change is called the \"old\" row (which makes sense only for UPDATE and DELETE statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3202
msgid "The row \"as of after\" the change is called the \"new\" row (which makes sense only for UPDATE and INSERT statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3205
msgid "This example shows how an INSERT can be done to a view by referring to the \"new\" row:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3208
msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1, 2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3217
msgid "Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so this is a workaround."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3220
msgid "It is possible to generalize this so that all data-change statements on views will change the base tables, provided that the view contains all the columns of the base table, and provided that the triggers refer to those columns when necessary, as in this example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3225
msgid "CREATE TABLE base_table (primary_key_column INTEGER PRIMARY KEY, value_column INTEGER);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_table_instead_of_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column);\n"
"  END;\n"
"CREATE TRIGGER viewed_table_instead_of_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column;\n"
"  END;\n"
"CREATE TRIGGER viewed_table_instead_of_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column;\n"
"  END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3244
msgid "When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually operates in this order (a basic scheme):"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3247
msgid "For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3262
msgid "However, Tarantool does not guarantee execution order when there are multiple constraints, or multiple triggers for the same event (including NoSQL :ref:`on_replace triggers <box_space-on_replace>` or SQL :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` that affect a view of table ``X``)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3269
msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3275
msgid "INSTEAD OF triggers"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3277
msgid "A trigger which is created with the clause |br| :samp:`INSTEAD OF {INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For each affected row, the trigger action is performed \"instead of\" the INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3283
msgid "For example, ordinarily it is illegal to INSERT rows in a view, but it is legal to create a trigger which intercepts attempts to INSERT, and puts rows in the underlying base table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3287
msgid "CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER v1_instead_of INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3296
msgid "INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers are only legal for base tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3299
msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3303
msgid "It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* clauses, but they are not standard SQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3308
msgid "CREATE TRIGGER ev1_instead_of_update\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3319
msgid "DROP TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3323
msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3332
msgid "Drop a trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3334
msgid "The *trigger-name* must identify a trigger that was created earlier with the :ref:`CREATE TRIGGER <sql_create_trigger>` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3341
msgid "Tarantool returns an error if the trigger does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3342
msgid "The trigger is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3347
msgid "-- the simple case:\n"
"DROP TRIGGER table1_before_insert;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS table1_before_insert;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3358
msgid "TRUNCATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3362
msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3371
msgid "Remove all rows in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3373
msgid "TRUNCATE is considered to be a schema-change rather than a data-change statement, so it does not work within transactions (it cannot be :ref:`rolled back <sql_rollback>`)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3379
msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3380
msgid "It is illegal to truncate a table which is also a system space, such as ``_space``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3382
msgid "The table must be a base table rather than a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3386
msgid "All rows in the table are removed. Usually this is faster than :samp:`DELETE FROM {table-name};`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3388
msgid "If the table has an autoincrement primary key, its :ref:`sequence <box_schema-sequence_create_index>` is reset to zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3390
msgid "There is no effect for any triggers associated with the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3391
msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3392
msgid "Only one action is written to the :ref:`write-ahead log <internals-wal>` (with :samp:`DELETE FROM {table-name};` there would be one action for each deleted row)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3399
msgid "TRUNCATE TABLE t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3407
msgid "SELECT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3411
msgid ":samp:`SELECT [ALL|DISTINCT] select-list [from clause] [where clause] [group-by clause] [having clause] [order-by clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3425
msgid "Select zero or more rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3427
msgid "The clauses of the SELECT statement are discussed in the following five sections."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3433
msgid "Select-list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3437
msgid ":samp:`select-list-column [, select-list-column ...] select-list-column:`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3447
msgid "Define what will be in a result set; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3449
msgid "The *select-list* is a comma-delimited list of expressions, or ``*`` (asterisk). An expression can have an alias provided with an ``[AS [column-name]]`` clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3452
msgid "The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT statement also contains a :ref:`FROM clause <sql_from>` which specifies the table or tables (details about the FROM clause are in the next section). The simple form is ``*`` which means \"all columns\" -- for example, if the select is done for a table which contains three columns ``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all columns in the specified table\", which again must be a result of the FROM clause -- for example, if the table is named ``table1``, then ``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3464
msgid "The ``[AS [column-name]]`` clause determines the column name. The column name is useful for two reasons:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3467
msgid "in a tabular display, the column names are the headings"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3468
msgid "if the results of the SELECT are used in ``CREATE TABLE new-table-name ... AS SELECT select-list ...``, then the column names in the new table will be the column names in the *select-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3472
msgid "If ``[AS [column-name]]`` is missing, Tarantool makes a name equal to the expression, for example ``SELECT 5 * 88`` will cause the column name to be ``5 * 88``, but such names may be ambiguous or illegal in other contexts, so it is better to say, for example, ``SELECT 5 * 88 AS column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3479
msgid "-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3496
msgid "FROM clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3500
msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3509
msgid "Specify the table or tables for the source of a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3511
msgid "The *table-reference* must be a name of an existing table, or a subquery, or a joined table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3514
msgid "A joined table looks like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3516
msgid ":samp:`table-reference-or-joined-table join-operator table-reference-or-joined-table [join-specification]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3518
msgid "A *join-operator* must be any of `the standard types <https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3521
msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3522
msgid "[NATURAL] INNER JOIN, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3523
msgid "CROSS JOIN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3525
msgid "A *join-specification* must be any of:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3527
msgid "ON expression, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3528
msgid "USING (column-name [, column-name ...])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3530
msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3532
msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3536
msgid "-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3551
msgid "WHERE clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3555
msgid ":samp:`WHERE condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3564
msgid "Specify the condition for filtering rows from a table; this is a clause in a :ref:`SELECT <sql_select>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3567
msgid "The condition may contain any expression that returns a BOOLEAN (TRUE or FALSE or UNKNOWN) value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3570
#: ../doc/reference/reference_sql/sql.rst:3767
msgid "For each row in the table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3572
#: ../doc/reference/reference_sql/sql.rst:3769
msgid "if the condition is true, then the row is kept;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3573
#: ../doc/reference/reference_sql/sql.rst:3770
msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3575
msgid "In effect, WHERE condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3580
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3591
msgid "GROUP BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3595
msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3604
msgid "Make a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3606
msgid "The expressions should be column names in the table, and each column should be specified only once."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3609
msgid "In effect, the GROUP BY clause takes a table with rows that may have matching values, combines rows that have matching values into single rows, and returns a table which, because it is the result of GROUP BY, is called a grouped table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3614
msgid "Thus, if the input is a table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3616
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3626
msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3628
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3637
msgid "The rows where column ``a`` and column ``b`` have the same value have been merged; column ``c`` has been preserved but its value should not be depended on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3641
msgid "It is useful to envisage a grouped table as having hidden extra columns for the aggregation of the values, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3644
msgid "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'  'b'         2      2    'b'\n"
"1    'b'  'b'         1      1    'b'\n"
"2    'a'  'b'         1      2    'b'\n"
"     'a'  'b'         1      3    'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3653
msgid "These extra columns are what :ref:`aggregate functions <sql_aggregate>` are for."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3657
msgid "-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3666
msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3667
msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3668
msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3676
msgid "Aggregate functions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3680
#: ../doc/reference/reference_sql/sql.rst:4764
msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3682
msgid "Apply a built-in aggregate function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3685
msgid "Aggregate functions are only legal in certain clauses of a :ref:`SELECT statement <sql_select>` for grouped tables. (A table is a grouped table if a GROUP BY clause is present.) Also, if an aggregate function is used in a select-list and the GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3692
msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3697
msgid "``AVG([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3695
msgid "Return the average value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3697
msgid "Example: :samp:`AVG({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3702
msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3700
msgid "Return the number of occurrences of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3702
msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3707
msgid "``COUNT(*)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3705
msgid "Return the number of occurrences of a row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3707
msgid "Example: :samp:`COUNT(*)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3715
msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3710
msgid "Return a list of *expression-1* values, separated by commas if *expression-2* is omitted, or separated by the *expression-2* value if *expression-2* is not omitted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3715
msgid "Example: :samp:`GROUP_CONCAT{column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3720
msgid "``MAX([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3718
msgid "Return the maximum value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3720
msgid "Example: :samp:`MAX({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3725
msgid "``MIN([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3723
msgid "Return the minimum value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3725
msgid "Example: :samp:`MIN({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3730
msgid "``SUM([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3728
#: ../doc/reference/reference_sql/sql.rst:3733
msgid "Return the sum of values of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3730
msgid "Example: :samp:`SUM({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3735
msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3735
msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3743
msgid "HAVING clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3747
msgid ":samp:`HAVING condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3756
msgid "Specify the condition for filtering rows from a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3759
msgid "The clause preceding the HAVING clause may be a GROUP BY clause. HAVING operates on the table that the GROUP BY produces, which may contain grouped columns and aggregates."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3763
msgid "If the preceding clause is not a GROUP BY clause, then there is only one group and the HAVING clause may only contain aggregate functions or literals."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3772
msgid "In effect, HAVING condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3777
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3790
msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3796
msgid "ORDER BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3800
msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3809
msgid "Put rows in order; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3811
msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3813
msgid "Expression is a positive integer, representing the ordinal position of the column in the select list. For example, in the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order by the second column in the select list\", which is ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3818
msgid "Expression is a name of a column in the select list, which is determined by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3823
msgid "Expression contains a name of a column in a table of the FROM clause. For example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3829
msgid "If both tables contain a column named ``z``, then Tarantool will choose the first column that it finds."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3832
msgid "The expression may also contain operators and function names and literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column ``t.z``\", which may be similar to doing ordering in a case-insensitive manner."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3838
msgid "Type 3 is illegal if the SELECT statement contains :ref:`UNION or EXCEPT or INTERSECT <sql_union>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3841
msgid "If an ORDER BY clause contains multiple expressions, then expressions on the left are processed first and expressions on the right are processed only if necessary for tie-breaking. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both have the same values for column ``x``, then an additional check is made to see which row has a greater value for column ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3850
msgid "In effect, ORDER BY clause takes a table with rows that may be out of order, and returns a table with rows in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3853
msgid "Sorting order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3855
msgid "The default order is ASC (ascending), the optional order is DESC (descending)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3856
msgid "NULLs come first, then BOOLEANs, then numbers (INTEGER or NUMBER), then STRINGs, then VARBINARYs."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3857
msgid "Within STRINGs, ordering is according to collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3858
msgid "Collation may be specified with a :ref:`COLLATE clause <sql_collate_clause>` within the ORDER BY column-list, or may be default."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3862
msgid "-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO h VALUES (7, 'A'), (4, 'A '), (-4, 'AZ'), (17, 17), (23, NULL);\n"
"INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'a'), (0, ''), (-1, '');\n"
"SELECT * FROM h ORDER BY s2, s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [7, 'A']\n"
"  - [4, 'A ']\n"
"  - [-4, 'AZ']\n"
"  - [1e+300, 'a']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3887
msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3895
msgid "LIMIT clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3899
msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3900
msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3904
msgid "The above is not a typo: *offset-expression* and *limit-expression* are in reverse order if a comma is used."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3914
msgid "Specify a maximum number of rows and a start row; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3917
msgid "Expressions may contain integers and arithmetic operators or functions, for example ``ABS(-3 / 1)``. However, the result must be an integer value greater than or equal to zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3921
msgid "Usually the LIMIT clause follows an :ref:`ORDER BY clause <sql_order_by>`, because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3926
msgid "-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3937
msgid "If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all must be DESC."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3946
msgid "VALUES"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3950
msgid ":samp:`VALUES (expression [, expression ...]) [, (expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3959
msgid "Select one or more rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3961
msgid "VALUES has the same effect as :ref:`SELECT <sql_select>`, that is, it returns a result set, but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3964
msgid "VALUES may be used wherever SELECT may be used, for example in :ref:`subqueries <sql_subquery>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3968
msgid "-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3981
msgid "Subquery"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3985
msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3986
msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3988
msgid "A subquery has the same syntax as a :ref:`SELECT statement <sql_select>` or :ref:`VALUES statement <sql_values>` embedded inside a main statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3994
msgid "The SELECT and VALUES statements are called \"queries\" because they return answers, in the form of result sets."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3997
msgid "Subqueries may be the second part of :ref:`INSERT statements <sql_insert>`. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3999
msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4003
msgid "Subqueries may be in the :ref:`FROM clause <sql_from>` of SELECT statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4005
msgid "Subqueries may be expressions, or be inside expressions. In this case they must be parenthesized, and usually the number of rows must be 1. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4009
msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4013
msgid "Subqueries may be expressions on the right side of certain comparison operators, and in this unusual case the number of rows may be greater than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4017
msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4021
msgid "Subqueries may refer to values in the outer query. In this case, the subquery is called a \"correlated subquery\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4024
msgid "Subqueries may refer to rows which are being updated or deleted by the main query. In that case, the subquery finds the matching rows first, before starting to update or delete. For example, after:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4028
msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO t VALUES (1, 3), (2, 1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4034
msgid "only one of the rows is deleted, not both rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4040
msgid "WITH clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4042
msgid "**WITH clause (common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4046
msgid ":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement | DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4057
msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4061
msgid "is equivalent to :ref:`creating a view <sql_create_view>` and selecting from it:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4063
msgid "CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4068
msgid "The difference is that a WITH-clause \"view\" is temporary and only useful within the same statement. No CREATE privilege is required."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4071
msgid "The WITH-clause can also be thought of as a :ref:`subquery <sql_subquery>` that has a name. This is useful when the same subquery is being repeated. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4074
msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4078
msgid "can be replaced with:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4080
msgid "WITH s AS (SELECT s1 FROM x) SELECT * FROM t,s WHERE a < s.s1 AND b < s.s1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4084
msgid "This \"factoring out\" of a repeated expression is regarded as good practice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4088
msgid "WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4096
msgid "WITH can only be used at the beginning of a statement, therefore it cannot be used at the beginning of a subquery or after a :ref:`set operator <sql_union>` or inside a CREATE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4100
msgid "A WITH-clause \"view\" is read-only because Tarantool does not support updatable views."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4107
msgid "WITH RECURSIVE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4109
msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4111
msgid "The real power of WITH lies in the WITH RECURSIVE clause, which is useful when it is combined with :ref:`UNION or UNION ALL <sql_union>`:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4114
msgid ":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-recursive-table-name;` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4127
msgid "In non-SQL this can be read as: starting with a seed value from a non-recursive table, produce a recursive viewed table, UNION that with itself, UNION that with itself, UNION that with itself ... forever, or until a condition in the WHERE clause says \"stop\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4134
msgid "CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4144
msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4146
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [1] -- adds 1 because the select list says \"s1+1\", and so it has one row: [2]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4150
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [2] -- adds 1 because the select list says \"s1+1\", and so it has one row: [3]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4154
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [3] -- adds 1 because the select list says \"s1+1\", and so it has one row: [4]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4158
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [4] -- and now the importance of the WHERE clause becomes evident, because \"s1 < 4\" is false for this row, and therefore we have reached the \"stop\" condition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4163
msgid "So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and the result of the statement looks like:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4166
msgid "tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4180
msgid "In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-incrementing values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4187
msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4191
msgid ":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4192
msgid ":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4193
msgid ":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4212
msgid "UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or \"table operators\". In particular:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4215
msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4216
msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4217
msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4219
msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4221
msgid "The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT ...;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4223
msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4225
msgid "The *select-statements* may be replaced with :ref:`VALUES statements <sql_values>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4227
msgid "The maximum number of set operations is 50."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4231
msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
"INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4244
msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4245
msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4246
msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4247
msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4251
msgid "Parentheses are not allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4252
msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4256
msgid "CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t01 VALUES (1, 'A');\n"
"INSERT INTO t02 VALUES (1, 'B');\n"
"INSERT INTO t03 VALUES (1, 'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4272
msgid "INDEXED BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4276
msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4285
msgid "The INDEXED BY clause may be used in a :ref:`SELECT <sql_select>`, :ref:`DELETE <sql_delete>`, or :ref:`UPDATE <sql_update>` statement, immediately after the *table-name*. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4289
msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4293
msgid "In this case the search for 'a' will take place within ``index7``. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4295
msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4299
msgid "In this case the search for 'a' will be done via a search of the whole table, what is sometimes called a \"full table scan\", even if there is an index for ``column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4303
msgid "Ordinarily Tarantool chooses the appropriate index or lookup method depending on a complex set of \"optimizer\" rules; the INDEXED BY clause overrides the optimizer choice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4309
msgid "Suppose a table has two columns:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4311
msgid "The first column is the primary key and therefore it has an automatic index named ``pk_unnamed_T_1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4313
msgid "The second column has an index created by the user."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4315
msgid "The user selects with ``INDEXED BY the-index-on-column1``, then selects with ``INDEXED BY the-index-on-column-2``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4318
msgid "CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE INDEX idx_column2_t_1 ON t (column2);\n"
"INSERT INTO t VALUES (1, 2), (2, 1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY i;\n"
"-- Result for the first select: (1, 2), (2, 1)\n"
"-- Result for the second select: (2, 1), (1, 2)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4328
msgid "Limitations: Often INDEXED BY has no effect. Often INDEXED BY affects a choice of covering index, but not a WHERE clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4336
msgid "Transactions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4342
msgid "START TRANSACTION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4346
msgid ":samp:`START TRANSACTION;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4355
msgid "Start a transaction. After ``START TRANSACTION;``, a transaction is \"active\". If a transaction is already active, then ``START TRANSACTION;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4358
msgid "Transactions should be active for fairly short periods of time, to avoid concurrency issues. To end a transaction, say :ref:`COMMIT; <sql_commit>` or :ref:`ROLLBACK; <sql_rollback>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4361
msgid "Just as in NoSQL, transaction control statements are subject to limitations set by the :ref:`storage engine <engines-chapter>` involved:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4364
msgid "For the memtx storage engine, if a yield happens within an active transaction, the transaction is rolled back."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4366
msgid "For the vinyl engine, yields are allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4368
msgid "However,transaction control statements still may not work as you expect when run over a network connection: a transaction is associated with a fiber, not a network connection, and different transaction control statements sent via the same network connection may be executed by different fibers from the fiber pool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4374
msgid "In order to ensure that all statements are part of the intended transaction, put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4378
msgid "Enclose each separate SQL statement in a :ref:`box.execute() <box-sql_box_execute>` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4380
msgid "Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4382
msgid "If you are using a console, you can do this by writing everything on a single line."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4385
msgid "If you are using :ref:`net.box <net_box-module>`, you can do this by putting all the function calls in a single string and calling :ref:`eval(string) <net_box-eval>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4391
msgid "START TRANSACTION;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4395
msgid "Example of a whole transaction sent to a server on ``localhost:3301`` with ``eval(string)``:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4398
msgid "net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION;]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
"s = s .. 'box.execute([[ROLLBACK;]]) '\n"
"conn:eval(s)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4411
msgid "COMMIT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4415
msgid ":samp:`COMMIT;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4424
msgid "Commit an active transaction, so all changes are made permanent and the transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4427
msgid "COMMIT is illegal unless a transaction is active. If a transaction is not active then SQL statements are committed automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4432
msgid "COMMIT;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4440
msgid "SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4444
msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4453
msgid "Set a savepoint, so that :ref:`ROLLBACK TO savepoint-name <sql_rollback>` is possible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4455
msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4457
msgid "If a savepoint with the same name already exists, it is released before the new savepoint is set."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4462
msgid "SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4470
msgid "RELEASE SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4474
msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4483
msgid "Release (destroy) a savepoint created by a :ref:`SAVEPOINT statement <sql_savepoint>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4485
msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4487
msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4491
msgid "RELEASE SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4499
msgid "ROLLBACK"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4503
msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4512
msgid "If ROLLBACK does not specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`START TRANSACTION <sql_start_transaction>` are cancelled, and the transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4517
msgid "If ROLLBACK does specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`SAVEPOINT savepoint-name <sql_savepoint>` are cancelled, and the transaction does not end."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4522
msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4526
msgid "-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4533
msgid "-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 STRING PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4553
msgid "PRAGMA"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4557
msgid ":samp:`PRAGMA {pragma-name} = pragma-value;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4558
msgid "or :samp:`PRAGMA {pragma-name} (pragma-value);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4559
msgid "or (rarely) :samp:`PRAGMA {pragma-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4560
msgid "or (once) :samp:`PRAGMA;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4565
msgid "Some PRAGMA statements will change DBMS behavior. Others will give rudimentary information about table 'metadata', although it is better to get such information via :ref:`system tables <sql_system_tables>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4569
msgid "We recommend: use ``PRAGMA pragma-name(pragma-value);`` rather than ``PRAGMA pragma-name = pragma-value;``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4571
msgid "Often pragma values are INTEGER but can be treated as BOOLEAN, and can be specified with any of: ``true`` | ``on`` | ``1`` | ``yes`` | ``'true'`` | ``'on'`` | ``'yes'`` ... ``false`` | ``off`` | ``0`` | ``no`` | ``'false'`` | ``'off'`` | ``'no'``. We recommend: use TRUE or FALSE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4577
msgid "Less commonly pragma values are strings and can be specified with any of: inside ``\"\"`` double quotes, inside ``''`` single quotes, or without quotes. We recommend: use single quotes. When a string is used for searching, results must match according to a binary collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4581
msgid "``PRAGMA;`` -- returns an incomplete list of pragmas and their current values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4583
msgid "**Pragma statements that determine behavior**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4585
msgid "In a forthcoming version, behavior change will be done by updating a system table, as described in `Issue#4511 <https://github.com/tarantool/tarantool/issues/4511>`_. Also one of the settings will be affected by `Issue#3792 <https://github.com/tarantool/tarantool/issues/3792>`_. Therefore use of PRAGMA for determining behavior is deprecated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4591
msgid "**Pragma statements that display data about the data and the server performance**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4600
msgid "Pragma"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4600
msgid "Parameter"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4600
msgid "Effect"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4602
msgid "foreign_key_list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4602
#: ../doc/reference/reference_sql/sql.rst:4636
#: ../doc/reference/reference_sql/sql.rst:4653
msgid "string |br| table-name"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4602
msgid "Return a result set with one row for each foreign key of \"table-name\". Each row contains: |br| (INTEGER) id -- identification number |br| (INTEGER) seq -- sequential number |br| (STRING) table -- name of table |br| (STRING) from  -- referencing key |br| (STRING) to -- referenced key |br| (STRING) on_update -- ON UPDATE clause |br| (STRING) on_delete -- ON DELETE clause |br| (STRING) match -- MATCH clause |br| The system table is ``\"_fk_constraint\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4615
msgid "collation_list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4615
msgid "Return a result set with one row for each supported collation. The first four collations are ``'none'`` and ``'unicode'`` and ``'unicode_ci'`` and ``'binary'``, then come about 270 predefined collations, the exact count may vary because users can add their own collations. |br| The system table is ``\"_collation\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4624
msgid "index_info"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4624
msgid "string |br| table-name . index-name (do not use quote marks, for example say ``T.I`` not ``'T.I'``)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4624
msgid "Return a result set with one row for each column in \"table-name.index-name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal position in the index (first column is 0) |br| (INTEGER) cid -- the column's ordinal position in the table (first column is 0) |br| (STRING) name -- name of the column |br| (INTEGER) desc -- 0 if ASC, 1 if DESC |br| (STRING) collation name |br| (STRING) type -- data type |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4636
msgid "index_list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4636
msgid "Return a result set with one row for each index of \"table-name\". Each row contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name -- index name |br| (INTEGER) unique -- whether the index is unique, 0 = false, 1 = true |br| The system table is ``\"_index\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4645
msgid "stats"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4645
msgid "Return a result set with one row for each index of each table. Each row contains: |br| (STRING) table -- name of the table |br| (STRING) index -- name of the index |br| (INTEGER) width -- arbitrary information |br| (INTEGER) height -- arbitrary information"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4653
msgid "table_info"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4653
msgid "Return a result set with one row for each column in \"table-name\". Each row contains: |br| (INTEGER) cid -- ordinal position in the table |br| (first column number is 0) |br| (STRING) name -- column name |br| (INTEGER) notnull -- whether the column is NOT NULL. 0 is false, 1 is true. |br| (STRING) dflt_value -- default value |br| (INTEGER) pk -- whether the column is a PRIMARY KEY column. 0 is false, 1 is true."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4668
msgid "Example: (not showing metadata)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4670
msgid "PRAGMA table_info('T');\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4683
msgid "EXPLAIN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4687
msgid ":samp:`EXPLAIN explainable-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4692
msgid "EXPLAIN will show what steps Tarantool would take if it executed explainable-statement. This is primarily a debugging and optimization aid for the Tarantool team."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4695
msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4697
msgid "- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
"  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
"  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
"  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
"  - [4, 'Goto', 0, 1, 0, '', '00', '']"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4705
msgid "Variation: ``EXPLAIN QUERY PLAN statement;`` shows the steps of a search."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4760
msgid "Functions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4766
msgid "Apply a built-in function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4768
msgid "Tarantool supports 32 built-in functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4770
msgid "The maximum number of operands for any function is 127."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4776
msgid "ABS"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4780
msgid ":samp:`ABS({numeric-expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4782
msgid "Return the absolute value of numeric-expression, which can be any numeric type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4784
msgid "Example: ``ABS(-1)`` is 1."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4790
msgid "CAST"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4794
msgid ":samp:`CAST({expression} AS {data-type})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4796
msgid "Return the expression value after casting to the specified :ref:`data type <sql_column_def_data_type>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4799
msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4805
msgid "CHAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4809
msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4811
msgid "Return the characters whose Unicode code point values are equal to the numeric expressions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4814
msgid "Short example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4816
msgid "The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65, 66, 67) is 'ABC'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4819
msgid "Long example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4821
msgid "For the current list of Unicode characters, in order by code point, see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt <http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that list, there is a line for a Linear B ideogram"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4827
msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4829
msgid "Therefore, for a string with a chariot in the middle, use the concatenation operator ``||`` and the CHAR function"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4832
msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4838
msgid "COALESCE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4842
msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4844
msgid "Return the value of the first non-NULL expression, or, if all expression values are NULL, return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4848
msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4854
msgid "GREATEST"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4858
msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4860
msgid "Return the greatest value of the supplied expressions, or, if any expression is NULL, return NULL. The reverse of ``GREATEST`` is :ref:`LEAST <sql_function_least>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4864
msgid "Examples: ``GREATEST(7, 44, -1)`` is 44; ``GREATEST(1E308, 'a', 0, X'00')`` is '\\0' = the nul character; ``GREATEST(3, NULL, 2)`` is NULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4872
msgid "HEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4876
msgid ":samp:`HEX(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4878
msgid "Return the hexadecimal code for each byte in **expression**, which may be either a string or a byte sequence. For ASCII characters, this is straightforward because the encoding is the same as the code point value. For non-ASCII characters, since character strings are usually encoded in UTF-8, each character will require two or more bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4889
msgid "``HEX('A')`` will return ``41``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4890
msgid "``HEX('Д')`` will return ``D094``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4896
msgid "IFNULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4900
msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4902
msgid "Return the value of the first non-NULL expression, or, if both expression values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the same as ``COALESCE(expression, expression)``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4908
msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4914
msgid "LEAST"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4918
msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4920
msgid "Return the least value of the supplied expressions, or, if any expression is NULL, return . The reverse of ``LEAST`` is :ref:`GREATEST <sql_function_greatest>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4924
msgid "Examples: ``LEAST(7, 44, -1)`` is -1; ``LEAST(1E308, 'a', 0, X'00')`` is 0; ``LEAST(3, NULL, 2)`` is NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4932
msgid "LENGTH"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4936
msgid ":samp:`LENGTH(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4938
msgid "Return the number of characters in the **expression**, or the number of bytes in the **expression**. It depends on the data type: strings with data type STRING are counted in characters, byte sequences with data type VARBINARY are counted in bytes and are not ended by the nul character. There are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4949
msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4950
msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4951
msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4952
msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4958
msgid "LIKELIHOOD"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4962
msgid ":samp:`LIKELIHOOD({expression}, {number literal})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4964
msgid "Return the result of the expression, provided that the number literal is between 0 and 1."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4966
msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4972
msgid "LIKELY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4976
msgid ":samp:`LIKELY({expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4978
msgid "Return TRUE if the expression is probably true."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4980
msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4986
msgid "LOWER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4990
msgid ":samp:`LOWER({string-expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4992
msgid "Return the expression, with upper-case characters converted to lower case. The reverse of ``LOWER`` is :ref:`UPPER <sql_function_upper>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:4995
msgid "Example: ``LOWER('ДA')`` is 'дa'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5001
msgid "NULLIF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5005
msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5007
msgid "Return *expression-1* if *expression-1* <> *expression-2*, otherwise return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5012
msgid "``NULLIF('a', 'A')`` is 'a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5013
msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5019
msgid "POSITION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5023
msgid ":samp:`POSITION({expression-1}, {expression-2})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5025
msgid "Return the position of expression-1 within expression-2, or return 0 if expression-1 does not appear within expression-2. The data types of the expressions must be either STRING or VARBINARY. If the expressions have data type STRING, then the result is the character position. If the expressions have data type VARBINARY, then the result is the byte position."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5033
msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5036
msgid "Long example: The UTF-8 encoding for the Latin letter A is hexadecimal 41; the UTF-8 encoding for the Cyrillic letter Д is hexadecimal D094 -- you can confirm this by saying SELECT HEX('ДA'); and seeing that the result is 'D09441'. If you now execute ``SELECT POSITION('A', 'ДA');`` the result will be 2, because 'A' is the second character in the string. However, if you now execute ``SELECT POSITION(X'41', X'D09441');`` the result will be 3, because X'41' is the third byte in the byte sequence."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5053
msgid "PRINTF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5057
msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5059
msgid "Return a string formatted according to the rules of the C ``sprintf()`` function, where ``%d%s`` means the next two arguments are a number and a string, and so on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5063
msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5065
msgid "'0' if the format requires an integer,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5066
msgid "'0.0' if the format requires a number with a decimal point,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5067
msgid "'' if the format requires a string."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5069
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5075
msgid "QUOTE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5079
msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5081
msgid "Return a string with enclosing quotes if necessary, and with quotes inside the enclosing quotes if necessary. This function is useful for creating strings which are part of SQL statements, because of SQL's rules that string literals are enclosed by single quotes, and single quotes inside such strings are shown as two single quotes in a row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5088
msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5094
msgid "RAISE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5098
msgid ":samp:`RAISE(FAIL, {error-message})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5100
msgid "This may only be used within a triggered statement. See also :ref:`Trigger Activation <sql_trigger_activation>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5106
msgid "RANDOM"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5108
msgid "Syntax: :samp:`RANDOM()`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5110
msgid "Return a 19-digit integer which is generated by a pseudo-random number generator,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5112
msgid "Example: ``RANDOM()`` is 6832175749978026034, or it is any other integer"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5118
msgid "RANDOMBLOB"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5122
msgid ":samp:`RANDOMBLOB({n})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5124
msgid "Return a byte sequence, n bytes long, data type = VARBINARY, containing bytes generated by a pseudo-random byte generator. The result can be translated to hexadecimal. If n is less than 1 or is NULL or is infinity, then NULL is returned."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5128
msgid "Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', or it is the hex value for any other three-byte string"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5139
msgid ":samp:`REPLACE({expression-1}, {xpression-2}, {expression-3})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5141
msgid "Return expression-1, except that wherever expression-1 contains expression-2, replace expression-2 with expression-3. The expressions should all have data type STRING or VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5146
msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5152
msgid "ROUND"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5156
msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5158
msgid "Return the rounded value of numeric-expression-1, always rounding .5 upward for floating-point positive numbers or downward for negative numbers. If numeric-expression-2 is supplied then rounding is to the nearest numeric-expression-2 digits after the decimal point; if numeric-expression-2 is not supplied then rounding is to the nearest integer."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5164
msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5170
msgid "ROW_COUNT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5172
msgid ":samp:`ROW_COUNT()`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5174
msgid "Return the number of rows that were inserted / updated / deleted by the last :ref:`INSERT <sql_insert>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` or :ref:`REPLACE <sql_replace>` statement. Rows which were updated by an UPDATE statement are counted even if there was no change. Rows which were inserted / updated / deleted due to foreign-key action are not counted. Rows which were inserted / updated / deleted due to a view's :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` are  not counted. After a CREATE or DROP statement, ROW_COUNT() is 1. After other statements,  ROW_COUNT() is 0."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5186
msgid "Example: ``ROW_COUNT()`` is 1 after a successful INSERT of a single row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5188
msgid "Special rule if there are BEFORE or AFTER triggers: In effect the ROW_COUNT() counter is pushed at the beginning of a series of triggered statements, and popped at the end. Therefore, after the following statements:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5192
msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"CREATE TABLE t2 (s1 INTEGER, s2 STRING, s3 INTEGER, PRIMARY KEY (s1, s2, s3));\n"
"CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
"  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
"  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
"  END;\n"
"INSERT INTO t1 VALUES (1),(2),(3);\n"
"DELETE FROM t1;\n"
"INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
"SELECT * FROM t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5205
msgid "The result is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5207
msgid "---\n"
"- - [1, '#2 Triggered', 3]\n"
"  - [1, '#3 Triggered', 1]\n"
"  - [2, '#2 Triggered', 3]\n"
"  - [2, '#3 Triggered', 1]\n"
"  - [3, '#2 Triggered', 3]\n"
"  - [3, '#3 Triggered', 1]\n"
"  - [4, '#4 Untriggered', 3]\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5223
msgid "SOUNDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5227
msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5229
msgid "Return a four-character string which represents the sound of ``string-expression``. Often words and names which have different spellings will have the same Soundex representation if they are pronounced similarly, so it is possible to search by what they sound like. The algorithm works with characters in the Latin alphabet and works best with English words."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5237
msgid "Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return ``C636``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5243
msgid "SUBSTR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5247
msgid ":samp:`SUBSTR({expression-1}, {numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5249
msgid "If expression-1 has data type STRING, then return the substring which begins at character position numeric-expression-1 and continues for numeric-expression-2 characters (if numeric-expression-2 is supplied), or continues till the end of string-expression-1 (if numeric-expression-2 is not supplied)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5256
msgid "If expression-1 has data type VARBINARY rather than data type STRING, then positioning and counting is by bytes rather than by characters."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5260
msgid "Example: ``SUBSTR('ABCDEFG', 3, 2)`` is 'CD'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5266
msgid "TRIM"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5270
msgid ":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] FROM] {expression-2})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5272
msgid "Return expression-2 after removing all leading and/or trailing characters or bytes. The expressions should have data type STRING or VARBINARY. If LEADING|TRAILING|BOTH is omitted, the default is BOTH. If expression-1 is omitted, the default is ' ' (space) for data type STRING or X'00' (nul) for data type VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5278
msgid "Examples: ``TRIM('a' FROM 'abaaaaa')`` is 'b' -- all repetitions of 'a' are removed on both sides; ``TRIM(TRAILING 'ב' FROM 'אב')`` is 'א' -- if all characters are Hebrew, TRAILING means \"left\"; ``TRIM(X'004400')`` is X'44' -- the default byte sequence to trim is X'00' when data type is VARBINARY' ``TRIM(LEADING 'abc' FROM 'abcd')`` is 'd' -- expression-1 can have more than 1 character"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5288
msgid "TYPEOF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5292
msgid ":samp:`TYPEOF({expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5294
msgid "Return the :ref:`data type <sql_column_def_data_type>` of the expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5296
msgid "Examples: ``TYPEOF('A')`` returns 'string'; ``TYPEOF(RANDOMBLOB(1))`` returns 'varbinary'; ``TYPEOF(1e44)`` returns 'number'; ``TYPEOF(-44)`` returns 'integer'; ``TYPEOF(NULL)`` returns 'boolean'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5307
msgid "UNICODE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5311
msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5313
msgid "Return the Unicode code point value of the first character of **string-expression**. If *string-expression* is empty, the return is NULL. This is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5317
msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5323
msgid "UNLIKELY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5327
msgid ":samp:`UNLIKELY({expression})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5329
msgid "Return TRUE if the expression is probably false. Limitation: in fact ``UNLIKELY`` may return the same thing as :ref:`LIKELY <sql_function_likely>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5332
msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5338
msgid "UPPER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5342
msgid ":samp:`UPPER(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5344
msgid "Return the expression, with lower-case characters converted to upper case. The reverse of ``UPPER`` is :ref:`LOWER <sql_function_lower>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5347
msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5353
msgid "VERSION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5357
msgid ":samp:`VERSION()`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5359
msgid "Return the Tarantool version."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5361
msgid "Example: for a December 2019 build VERSION() is ``2.3.0-258-g960e9c0c7``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5367
msgid "ZEROBLOB"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5371
msgid ":samp:`ZEROBLOB({n})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5373
msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5379
msgid "COLLATE clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5381
msgid ":samp:`COLLATE collation-name`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5383
msgid "The collation-name must identify an existing collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5385
msgid "The COLLATE clause is allowed for STRING or SCALAR items: |br| () in :ref:`CREATE INDEX <sql_create_index>` |br| () in :ref:`CREATE TABLE <sql_create_table>` as part of :ref:`column definition <sql_column_def>` |br| () in CREATE TABLE as part of :ref:`UNIQUE definition <sql_table_constraints>` |br| () in string expressions |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5393
msgid "-- In CREATE INDEX\n"
"CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
"-- In CREATE TABLE\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING COLLATE \"unicode_ci\");\n"
"-- In CREATE TABLE ... UNIQUE\n"
"CREATE TABLE mb (a STRING, b STRING, PRIMARY KEY(a), UNIQUE(b COLLATE \"unicode_ci\" DESC));\n"
"-- In string expressions\n"
"SELECT 'a' = 'b' COLLATE \"unicode\"\n"
"    FROM t\n"
"    WHERE s1 = 'b' COLLATE \"unicode\"\n"
"    ORDER BY s1 COLLATE \"unicode\";"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5407
msgid "The list of collations can be seen with: :ref:`PRAGMA collation_list; <sql_pragma>`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5409
msgid "The collation rules comply completely with the Unicode Technical Standard #10 (`\"Unicode Collation Algorithm\" <http://unicode.org/reports/tr10/>`_) and the default character order is as in the `Default Unicode Collation Element Table (DUCET) <https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There are many permanent collations; the commonly used ones include: |br| |nbsp| |nbsp| ``\"none\"`` (not applicable) |br| |nbsp| |nbsp| ``\"unicode\"`` (characters are in DUCET order with strength = 'tertiary') |br| |nbsp| |nbsp| ``\"unicode_ci\"`` (characters are in DUCET order with strength = 'primary') |br| |nbsp| |nbsp| ``\"binary\"`` (characters are in code point order) |br| These identifiers must be quoted and in lower case because they are in lower case in :ref:`Tarantool/NoSQL collations <index-collation>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5421
msgid "If one says ``COLLATE \"binary\"``, this is equivalent to asking for what is sometimes called \"code point order\" because, if the contents are in the UTF-8 character set, characters with larger code points will appear after characters with lower code points."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5425
msgid "In an expression, ``COLLATE`` is an operator with higher precedence than anything except ``~``. This is fine because there are no other useful operators except ``||`` and comparison. After ``||``, collation is preserved."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5429
msgid "In an expression with more than one ``COLLATE`` clause, if the collation names differ, there is an error: \"Illegal mix of collations\". In an expression with no ``COLLATE`` clauses, literals have collation ``\"binary\"``, columns have the collation specified by ``CREATE TABLE``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5434
msgid "In other words, to pick a collation, we use: |br| the first ``COLLATE`` clause in an expression if it was specified, |br| else the the column's ``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5439
msgid "However, for searches and sometimes for sorting, the collation may be an index's collation, so all non-index ``COLLATE`` clauses are ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5442
msgid ":ref:`EXPLAIN <sql_explain>` will not show the name of what collation was used, but will show the collation's characteristics."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5444
msgid "Example with Swedish collation: |br| Knowing that \"sv\" is the two-letter code for Swedish, |br| and knowing that \"s1\" means strength = 1, |br| and seeing with ``PRAGMA collation_list;`` that there is a collation named unicode_sv_s1, |br| check whether two strings are equal according to Swedish rules (yes they are): |br| ``SELECT 'ÄÄ' = 'ĘĘ' COLLATE \"unicode_sv_s1\";``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5451
msgid "Example with Russian and Ukrainian and Kyrgyz collations: |br| Knowing that Russian collation is practically the same as Unicode default, |br| and knowing that the two-letter codes for Ukrainian and Kyrgyz are 'uk' and 'ky', |br| and knowing that in Russian (but not Ukrainian) 'Г' = 'Ґ' with strength=primary, |br| and knowing that in Russian (but not Kyrgyz) 'Е' = 'Ё' with strength=primary, |br| the three SELECT statements here will return results in three different orders: |br| ``CREATE TABLE things (remark STRING PRIMARY KEY);`` |br| ``INSERT INTO things VALUES ('Е2'), ('Ё1');`` |br| ``INSERT INTO things VALUES ('Г2'), ('Ґ1');`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_uk_s1\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_ky_s1\";``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5473
msgid "SQL PLUS LUA -- Adding Tarantool/NoSQL to Tarantool/SQL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5475
msgid "The Adding Tarantool/NoSQL To Tarantool/SQL Guide contains descriptions of NoSQL database objects that can be accessed from SQL, of SQL database objects that can be accessed from NoSQL, of the way to call SQL from Lua, and of the way to call Lua from SQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5480
msgid "Lua Requests"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5482
msgid "A great deal of functionality is not specifically part of Tarantool's SQL feature, but is part of the Tarantool Lua application server and DBMS. Here we will give examples so it is clear where to look in other sections of the Tarantool manual."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5486
msgid "NoSQL :ref:`\"spaces\" <index-box_space>` can be accessed as SQL ``\"tables\"``, and vice versa. For example, suppose a table has been created with |br| ``CREATE TABLE things (id INTEGER PRIMARY KEY, remark SCALAR);``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5490
msgid "This is viewable from Tarantool's NoSQL feature as a memtx space named THINGS with a primary-key :ref:`TREE index <index-box_index>` ..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5493
msgid "tarantool> box.space.THINGS\n"
"---\n"
"- engine: memtx\n"
"  before_replace: 'function: 0x40bb4608'\n"
"  on_replace: 'function: 0x40bb45e0'\n"
"  ck_constraint: []\n"
"  field_count: 2\n"
"  temporary: false\n"
"  index:\n"
"    0: &0\n"
"      unique: true\n"
"      parts:\n"
"     - type: integer\n"
"        is_nullable: false\n"
"        fieldno: 1\n"
"      id: 0\n"
"      space_id: 520\n"
"      type: TREE\n"
"      name: pk_unnamed_THINGS_1\n"
"    pk_unnamed_THINGS_1: *0\n"
"  is_local: false\n"
"  enabled: true\n"
"  name: THINGS\n"
"  id: 520"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5520
msgid "The NoSQL :ref:`basic data operation requests <index-box_data-operations>` select, insert, replace, upsert, update, delete will all work. Particularly interesting are the requests that come only via NoSQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5524
msgid "To create a HASH index on things (remark), say: |br| ``box.space.THINGS:create_index('hash', {type='hash', parts={2, 'scalar'}})``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5527
msgid "(If the SQL data type name is SCALAR, then the NoSQL type is 'scalar', as described earlier. See the chart in section :ref:`Operands <sql_operands>`.)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5530
msgid "To :ref:`grant <box_schema-user_grant>` database-access privileges to user 'guest', say |br| ``box.schema.user.grant('guest', 'execute', 'universe')`` |br| To grant SELECT privileges on table things to user 'guest', say |br| ``box.schema.user.grant('guest',  'read', 'space', 'THINGS')`` |br| To grant UPDATE privileges on table things to user 'guest', say: |br| ``box.schema.user.grant('guest', 'read,write', 'space', 'THINGS')`` |br| To grant DELETE or INSERT privileges on table things if no reading is involved, say: |br| ``box.schema.user.grant('guest', 'write', 'space', 'THINGS')`` |br| To grant DELETE or INSERT privileges on table things if reading is involved, say: |br| ``box.schema.user.grant('guest',  'read,write',  'space',  'THINGS')`` |br| To grant CREATE TABLE privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_schema')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| To grant CREATE TRIGGER privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_trigger')`` |br| To grant CREATE INDEX privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| To grant CREATE TABLE ... INTEGER PRIMARY KEY AUTOINCREMENT to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_schema')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space_sequence')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_sequence')`` |br| ``box.schema.user.grant('guest', 'create', 'sequence')`` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5561
msgid "To write a stored procedure that inserts 5 rows in things, say |br| ``function f() for i = 3, 7 do box.space.THINGS:insert{i, i} end end`` |br| For client-side API functions, see section :ref:`\"Connectors\" <index-box_connectors>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5565
msgid "To make spaces with field names that SQL can understand, use :ref:`space_object:format() <box_space-format>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5568
msgid "To handle replication and sharding of SQL data, see section :ref:`Sharding <shard-module>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5571
msgid "Limitations: (`Issue#2368 <https://github.com/tarantool/tarantool/issues/2368>`_) * after ``box.schema.user.grant('guest','read,write,execute','universe')``, user ``'guest'`` can create tables. But this is a powerful set of privileges.."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5578
msgid "System Tables"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5580
msgid "There is a way to get some information about the database objects, for example the names of all the tables and their indexes, using :ref:`SELECT statements <sql_select>`. This is done by looking at special read-only tables which Tarantool updates automatically whenever objects are created or dropped. See the :ref:`submodule box.space <box_space>` overview section. Names of system tables are in lower case so always enclose them in ``\"quotes\"``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5588
msgid "For example, the :ref:`_space <box_space-space>` system table has these fields which are seen in SQL as columns: |br| |nbsp|  id = numeric identifier |br| |nbsp|  owner = for example, 1 if the object was made by the ``'admin'`` user |br| |nbsp|  name = the name that was used with CREATE TABLE |br| |nbsp|  engine = usually ``'memtx'`` (the ``'vinyl'`` engine can be used but is not default) |br| |nbsp|  field_count = sometimes 0, but usually a count of the table's columns |br| |nbsp|  flags = usually empty |br| |nbsp|  format = what a Lua format() function or an SQL CREATE statement produced |br| Example selection: |br| |nbsp|  ``SELECT \"id\", \"name\" FROM \"_space\";``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5599
msgid "See also: :ref:`Lua functions to make views of metadata <sql_lua_functions>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5698
msgid "Calling Lua routines from SQL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5700
msgid "SQL statements can invoke functions that are written in Lua. This is Tarantool's equivalent for the \"stored procedure\" feature found in other SQL DBMSs. Tarantool server-side stored procedures are written in Lua rather than SQL/PSM dialect."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5704
msgid "Functions can be invoked anywhere that the SQL syntax allows a literal or a column name for reading. Function parameters can include any number of SQL values. If a SELECT statement's result list has a million rows, and the select list invokes a non-deterministic function, then the function is called a million times."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5709
msgid "To create a Lua function that you can call from SQL, use :ref:`box.schema.func.create(func-name, {options-with-body}) <box_schema-func_create_with-body>` with these additional options:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5713
msgid "``exports = {'LUA', 'SQL'}`` -- This indicates what languages can call the function. The default is ``'LUA'``. Specify both: ``'LUA', 'SQL'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5716
msgid "``param_list = {list}`` -- This is the list of parameters. Specify the Lua type names for each parameter of the function. Remember that a Lua type name is :ref:`the same as <sql_operands>` an SQL data type name, in lower case. The Lua type should not be an array."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5722
msgid "Also it is good to specify ``{deterministic = true}`` if possible, because that may allow Tarantool to generate more efficient SQL byte code."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5725
msgid "For a useful example, here is a general function for decoding a single Lua ``'map'`` field:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5727
msgid "box.schema.func.create('_DECODE',\n"
"   {language = 'LUA',\n"
"    returns = 'string',\n"
"    body = [[function (field, part)\n"
"             __GLOBAL= field\n"
"             return dostring(\"return require('msgpack').decode(__GLOBAL,1).\" .. part)\n"
"             end]],\n"
"    is_sandboxed = false,\n"
"    param_list = {'string', \"string\"},\n"
"    exports = {'LUA', 'SQL'},\n"
"    is_deterministic = true})"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5741
msgid "See it work with, say, the _trigger space. That space has a ``'map'`` field named opts which has a part named sql. By selecting from the space and passing the field and the part name to _DECODE, you can get a list of all the trigger bodies."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5746
msgid "__GLOBAL = \"\"\n"
"box.execute([[SELECT _decode(\"opts\", 'sql') FROM \"_trigger\";]])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5751
msgid "Remember that SQL converts :ref:`regular identifiers <sql_identifiers>` to upper case, so this example works with a function named _DECODE. If the function had been named _decode, then the SELECT statement would have to be: |br| ``box.execute([[SELECT \"_decode\"(\"opts\", 'sql') FROM \"_trigger\";]])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5756
msgid "Here is another example, which illustrates the way that Tarantool creates a view which includes the table_name and table_type columns in the same way that the standard-SQL information_schema.tables view contains them. The difficulty is that, in order to discover whether table_type should be ``'BASE TABLE'`` or should be ``'VIEW'``, we need to know the value of the ``\"flags\"`` field in the Tarantool/NoSQL :ref:`\"_space\" <box_space-space>` or ``\"_vspace\"`` space. The ``\"flags\"`` field type is ``\"map\"``, which SQL does not understand well. If there were no Lua functions, we would have to treat it as a VARBINARY and look for ``POSITION(X'A476696577C3',\"flags\")  > 0`` (A4 is a MsgPack signal that a 4-byte string follows, 76696577 is UTF8 encoding for 'view', C3 is a MsgPack code meaning true). But we have a more sophisticated way, we can create a function that returns true if ``\"flags\".view`` is true. So our way of making the function looks like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5771
msgid "box.schema.func.create('TABLES_IS_VIEW',\n"
"     {language = 'LUA',\n"
"      returns = 'boolean',\n"
"      body = [[function (flags)\n"
"          local view\n"
"          view = require('msgpack').decode(flags).view\n"
"          if view == nil then return false end\n"
"          return view\n"
"          end]],\n"
"     is_sandboxed = false,\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_deterministic = true})"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5787
msgid "And this creates the view:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5789
msgid "box.execute([[\n"
"CREATE VIEW vtables AS SELECT\n"
"\"name\" AS table_name,\n"
"CASE WHEN tables_is_view(\"flags\") == TRUE THEN 'VIEW'\n"
"     ELSE 'BASE TABLE' END AS table_type,\n"
"\"id\" AS id,\n"
"\"engine\" AS engine,\n"
"(SELECT \"name\" FROM \"_vuser\" x\n"
" WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"\"field_count\" AS field_count\n"
"FROM \"_vspace\" y;\n"
"]])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5804
msgid "Remember that these Lua functions are persistent, so if the server has to be restarted then they do not have to be re-declared."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5808
msgid "Executing Lua chunks"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5810
msgid "To execute Lua code without creating a function, use: |br| :samp:`LUA({Lua-code-string})` |br| where Lua-code-string is any amount of Lua code. The string should begin with ``'return '``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5815
msgid "For example this will show the number of seconds since the epoch: |br| ``box.execute([[SELECT lua('return os.time()');]])`` |br| For example this will show a database configuration member: |br| ``box.execute([[SELECT lua('return box.cfg.memtx_memory');]])`` For example this will return FALSE because Lua nil and box.NULL are the same as SQL NULL: |br| ``box.execute([[SELECT lua('return box.NULL') IS NOT NULL;]])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5822
msgid "Warning: the SQL statement must not invoke a Lua function, or execute a Lua chunk, that accesses a space that underlies any SQL table that the SQL statement accesses. For example, if function ``f()`` contains a request ``\"box.space.TEST:insert{0}\"``, then the SQL statement ``\"SELECT f() FROM test;\"`` will try to access the same space in two ways. The results of such conflict may include a hang or an infinite loop."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5830
msgid "Example Session -- Create, Insert, Select"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5832
msgid "Assume that the task is to create two tables, put some rows in each table, create a :ref:`view <sql_create_view>` that is based on a join of the tables, then select from the view all rows where the second column values are not null, ordered by the first column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5837
msgid "That is, what we want is |br| ``CREATE TABLE t1 (c1 INTEGER PRIMARY KEY, c2 STRING);`` |br| ``CREATE TABLE t2 (c1 INTEGER PRIMARY KEY, x2 STRING);`` |br| ``INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');`` |br| ``INSERT INTO t1 VALUES (4, 'D'), (5, 'E'), (6, 'F');`` |br| ``INSERT INTO t2 VALUES (1, 'C'), (4, 'A'), (6, NULL);`` |br| ``CREATE VIEW v AS SELECT * FROM t1 NATURAL JOIN t2;`` |br| ``SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5846
msgid "So the session looks like this: |br| ``box.cfg{}`` |br| ``box.execute([[CREATE TABLE t1 (c1 INTEGER PRIMARY KEY, c2 STRING);]])`` |br| ``box.execute([[CREATE TABLE t2 (c1 INTEGER PRIMARY KEY, x2 STRING);]])`` |br| ``box.execute([[INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');]])`` |br| ``box.execute([[INSERT INTO t1 VALUES (4, 'D'), (5, 'E'), (6, 'F');]])`` |br| ``box.execute([[INSERT INTO t2 VALUES (1, 'C'), (4, 'A'), (6, NULL);]])`` |br| ``box.execute([[CREATE VIEW v AS SELECT * FROM t1 NATURAL JOIN t2;]])`` |br| ``box.execute([[SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;)]])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5856
msgid "If one executes the above requests with Tarantool as a client, provided the database objects do not already exist, the execution will be successful and the final display will be |br| tarantool> box.execute([[SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;]]) ``---`` |br| ``- - [1, 'A', 'C']`` |br| ``  - [4, 'D', 'A']`` |br| ``  - [6, 'F', null]`` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5866
msgid "Example Session -- Get a List of Columns"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5868
msgid "Here  is a function which will create a table that contains a list of all the columns and their Lua types, for all tables. It is not a necessary function because one can create a :ref:`_COLUMNS view <sql__columns_view>` instead. It merely shows, with simpler Lua code, how to make a base table instead of a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5874
msgid "function create_information_schema_columns()\n"
"  box.execute([[DROP TABLE IF EXISTS information_schema_columns;]])\n"
"  box.execute([[CREATE TABLE information_schema_columns (\n"
"                    table_name STRING,\n"
"                    column_name STRING,\n"
"                    ordinal_position INTEGER,\n"
"                    data_type STRING,\n"
"                    PRIMARY KEY (table_name, column_name));]]);\n"
"  local space = box.space._vspace:select()\n"
"  local sqlstring = ''\n"
"  for i = 1, #space do\n"
"      for j = 1, #space[i][7] do\n"
"          sqlstring = \"INSERT INTO information_schema_columns VALUES (\"\n"
"                  .. \"'\" .. space[i][3] .. \"'\"\n"
"                  .. \",\"\n"
"                  .. \"'\" .. space[i][7][j].name .. \"'\"\n"
"                  .. \",\"\n"
"                  .. j\n"
"                  .. \",\"\n"
"                  .. \"'\" .. space[i][7][j].type .. \"'\"\n"
"                  .. \");\"\n"
"          box.execute(sqlstring)\n"
"      end\n"
"  end\n"
"  return\n"
"end"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5903
msgid "If you now execute the function by saying |br| ``create_information_schema_columns()`` |br| you will see that there is a table named information_schema_columns containing table_name and column_name and ordinal_position and data_type for everything that was accessible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5910
msgid "Example Session -- Million-Row Insert"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5912
msgid "Here is a variation of the Lua tutorial :ref:`\"Insert one million tuples with a Lua stored procedure\" <c_lua_tutorial-insert_one_million_tuples>`. The differences are: the creation is done with an SQL :ref:`CREATE TABLE statement <sql_create_table>`, and the inserting is done with an SQL :ref:`INSERT statement <sql_insert>`. Otherwise, it is the same. It is the same because Lua and SQL are compatible, just as Lua and NoSQL are compatible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5920
msgid "box.execute([[CREATE TABLE tester (s1 INTEGER PRIMARY KEY, s2 STRING);]])\n"
"\n"
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"    local string_value, t, sql_statement\n"
"    for i = 1,1000000, 1 do\n"
"    string_value = string_function()\n"
"    sql_statement = \"INSERT INTO tester VALUES (\" .. i .. \",'\" .. string_value .. \"')\"\n"
"    box.execute(sql_statement)\n"
"    end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5948
msgid "Limitations: The function takes more time than the original (Tarantool/NoSQL)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5955
msgid "Lua functions to make views of metadata"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5957
msgid "Tarantool does not include all the standard-SQL `information_schema <https://en.wikipedia.org/wiki/information_schema>`_ views, which are for looking at metadata, that is, \"data about the data\". But here is the Lua code and SQL code for creating equivalents: |br| :ref:`_TABLES <sql__tables_view>` nearly equivalent to INFORMATION_SCHEMA.TABLES |br| :ref:`_COLUMNS <sql__columns_view>` nearly equivalent to INFORMATION_SCHEMA.COLUMNS |br| :ref:`_VIEWS <sql__views_view>` nearly equivalent to INFORMATION_SCHEMA.VIEWS |br| :ref:`_TRIGGERS <sql__triggers_view>` nearly equivalent to INFORMATION_SCHEMA.TRIGGERS |br| :ref:`_REFERENTIAL_CONSTRAINTS <sql__referential_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS |br| :ref:`_CHECK_CONSTRAINTS <sql__check_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.CHECK_CONSTRAINTS |br| :ref:`_TABLE_CONSTRAINTS <sql__table_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.TABLE_CONSTRAINTS. |br| For each view we show an example of a SELECT from the view, and the code. Users who want metadata can simply copy the code. Use this code only with Tarantool version 2.3.0 or later. With an earlier Tarantool version, a :ref:`PRAGMA statement <sql_pragma>` may be useful."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5977
msgid "_TABLES view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5981
msgid "tarantool>SELECT * FROM _tables WHERE id > 340 LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+\n"
"| TABLE_CATALOG | TABLE_SCHEMA | TABLE_NAME     | TABLE_TYPE | ID  | ENGINE | OWNER | FIELD_COUNT |\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+\n"
"| NULL          | NULL         | _fk_constraint | BASE TABLE | 356 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _ck_constraint | BASE TABLE | 364 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _func_index    | BASE TABLE | 372 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _COLUMNS       | VIEW       | 513 | memtx  | admin |        8    |\n"
"| NULL          | NULL         | _VIEWS         | VIEW       | 514 | memtx  | admin |        7    |\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5995
#: ../doc/reference/reference_sql/sql.rst:6066
#: ../doc/reference/reference_sql/sql.rst:6168
#: ../doc/reference/reference_sql/sql.rst:6223
#: ../doc/reference/reference_sql/sql.rst:6385
msgid "Definition of the function and the CREATE VIEW statement:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:5997
msgid "box.schema.func.drop('_TABLES_IS_VIEW',{if_exists = true})\n"
"box.schema.func.create('_TABLES_IS_VIEW',\n"
"     {language = 'LUA',\n"
"      returns = 'boolean',\n"
"      body = [[function (flags)\n"
"          local view\n"
"          view = require('msgpack').decode(flags).view\n"
"          if view == nil then return false end\n"
"          return view\n"
"          end]],\n"
"     is_sandboxed = false,\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     setuid = false,\n"
"     is_deterministic = true})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TABLES_IS_VIEW')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_TABLES', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _tables;]])\n"
"box.execute([[\n"
"CREATE VIEW _tables AS SELECT\n"
"    CAST(NULL AS STRING) AS table_catalog,\n"
"    CAST(NULL AS STRING) AS table_schema,\n"
"    \"name\" AS table_name,\n"
"    CASE\n"
"        WHEN _tables_is_view(\"flags\") = TRUE THEN 'VIEW'\n"
"        ELSE 'BASE TABLE' END\n"
"        AS table_type,\n"
"    \"id\" AS id,\n"
"    \"engine\" AS engine,\n"
"    (SELECT \"name\" FROM \"_vuser\" x WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"    \"field_count\" AS field_count\n"
"FROM \"_vspace\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TABLES')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6040
msgid "_COLUMNS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6042
msgid "This is also an example of how one can use :ref:`recursive views <sql_with>` to make temporary tables with multiple rows for each tuple in the original ``\"_vtable\"`` space. It requires a global variable, _G.box.FORMATS, as a temporary static variable."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6046
msgid "Warning: Use this code only with Tarantool version 2.3.2 or later. Use with earlier versions will cause an assertion. See `Issue#4504 <https://github.com/tarantool/tarantool/issues/4504>`_."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6052
msgid "tarantool>SELECT * FROM _columns WHERE ordinal_position = 9;\n"
"OK 6 rows selected (0.0 seconds)\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+\n"
"| CATALOG_NAME | SCHEMA_NAME | TABLE_NAME               | COLUMN_NAME  | ORDINAL_POSITION | IS_NULLABLE | DATA_TYPE | ID  |\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+\n"
"| NULL         | NULL        | _sequence                | cycle        |                9 | YES         | boolean   | 284 |\n"
"| NULL         | NULL        | _vsequence               | cycle        |                9 | YES         | boolean   | 286 |\n"
"| NULL         | NULL        | _func                    | returns      |                9   YES           string    | 296 |\n"
"| NULL         | NULL        | _fk_constraint           | parent_cols  |                9 | YES         | array     | 356 |\n"
"| NULL         | NULL        | _REFERENTIAL_CONSTRAINTS | MATCH_OPTION |                9 | YES         | string    | 518 |\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6068
msgid "box.schema.func.drop('_COLUMNS_FORMATS', {if_exists = true})\n"
"box.schema.func.create('_COLUMNS_FORMATS',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[\n"
"     function (row_number_, ordinal_position)\n"
"         if row_number_ == 0 then\n"
"             _G.box.FORMATS = {}\n"
"             local vspace = box.space._vspace:select()\n"
"             for i = 1, #vspace do\n"
"                 local format = vspace[i][\"format\"]\n"
"                 for j = 1, #format do\n"
"                     local is_nullable = 'YES'\n"
"                     if format[j].is_nullable == false then\n"
"                         is_nullable = 'NO'\n"
"                     end\n"
"                     table.insert(_G.box.FORMATS,\n"
"                                  {vspace[i].name, format[j].name, j,\n"
"                                   is_nullable, format[j].type, vspace[i].id})\n"
"                 end\n"
"             end\n"
"             return ''\n"
"         end\n"
"         if row_number_ > #_G.box.FORMATS then\n"
"             _G.box.FORMATS = {}\n"
"             return ''\n"
"         end\n"
"         return _G.box.FORMATS[row_number_][ordinal_position]\n"
"     end\n"
"     ]],\n"
"    param_list = {'integer', 'integer'},\n"
"    exports = {'LUA', 'SQL'},\n"
"    is_sandboxed = false,\n"
"    setuid = false,\n"
"    is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_COLUMNS_FORMATS')\n"
"\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_COLUMNS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _columns;]])\n"
"box.execute([[\n"
"CREATE VIEW _columns AS\n"
"WITH RECURSIVE r_columns AS\n"
"(\n"
"SELECT 0 AS row_number_,\n"
"      '' AS table_name,\n"
"      '' AS column_name,\n"
"      0 AS ordinal_position,\n"
"      '' AS is_nullable,\n"
"      '' AS data_type,\n"
"      0 AS id\n"
"UNION ALL\n"
"SELECT row_number_ + 1 AS row_number_,\n"
"       _columns_formats(row_number_, 1) AS table_name,\n"
"       _columns_formats(row_number_, 2) AS column_name,\n"
"       _columns_formats(row_number_, 3) AS ordinal_position,\n"
"       _columns_formats(row_number_, 4) AS is_nullable,\n"
"       _columns_formats(row_number_, 5) AS data_type,\n"
"       _columns_formats(row_number_, 6) AS id\n"
"    FROM r_columns\n"
"    WHERE row_number_ == 0 OR row_number_ <= lua('return #_G.box.FORMATS + 1')\n"
")\n"
"SELECT CAST(NULL AS STRING) AS catalog_name,\n"
"       CAST(NULL AS STRING) AS schema_name,\n"
"       table_name,\n"
"       column_name,\n"
"       ordinal_position,\n"
"       is_nullable,\n"
"       data_type,\n"
"       id\n"
"    FROM r_columns\n"
"    WHERE data_type <> '';\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_COLUMNS')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6150
msgid "_VIEWS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6154
msgid "tarantool>SELECT table_name, substr(view_definition,1,20), id, owner, field_count FROM _views LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+--------------------------+------------------------------+-----+-------+-------------+\n"
"| TABLE_NAME               | SUBSTR(VIEW_DEFINITION,1,20) | ID  | OWNER | FIELD_COUNT |\n"
"+--------------------------+------------------------------+-----+-------+-------------+\n"
"| _COLUMNS                 | CREATE VIEW _columns         | 513 | admin |           8 |\n"
"| _TRIGGERS                | CREATE VIEW _trigger         | 515 | admin |           4 |\n"
"| _CHECK_CONSTRAINTS       | CREATE VIEW _check_c         | 517 | admin |           8 |\n"
"| _REFERENTIAL_CONSTRAINTS | CREATE VIEW _referen         | 518 | admin |          12 |\n"
"| _TABLE_CONSTRAINTS       | CREATE VIEW _table_c         | 519 | admin |          11 |\n"
"+--------------------------+------------------------------+-----+-------+-------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6170
msgid "box.schema.func.drop('_VIEWS_DEFINITION',{if_exists = true})\n"
"box.schema.func.create('_VIEWS_DEFINITION',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[function (flags)\n"
"                  return require('msgpack').decode(flags).sql end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_VIEWS_DEFINITION')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_VIEWS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _views;]])\n"
"box.execute([[\n"
"CREATE VIEW _views AS SELECT\n"
"    CAST(NULL AS STRING) AS table_catalog,\n"
"    CAST(NULL AS STRING) AS table_schema,\n"
"    \"name\" AS table_name,\n"
"    CAST(_views_definition(\"flags\") AS STRING) AS VIEW_DEFINITION,\n"
"    \"id\" AS id,\n"
"    (SELECT \"name\" FROM \"_vuser\" x WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"    \"field_count\" AS field_count\n"
"    FROM \"_vspace\" y\n"
"    WHERE _tables_is_view(\"flags\") = TRUE;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_VIEWS')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6202
msgid "_TABLES_IS_VIEW() was described earlier, see :ref:`_TABLES view <sql__tables_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6208
msgid "_TRIGGERS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6212
msgid "tarantool>SELECT trigger_name, opts_sql FROM _triggers;\n"
"OK 2 rows selected (0.0 seconds)\n"
"+--------------+-------------------------------------------------------------------------------------------------+\n"
"| TRIGGER_NAME | OPTS_SQL                                                                                        |\n"
"+--------------+-------------------------------------------------------------------------------------------------+\n"
"| THINGS1_AD   | CREATE TRIGGER things1_ad AFTER DELETE ON things1 FOR EACH ROW BEGIN DELETE FROM things2; END;  |\n"
"| THINGS1_BI   | CREATE TRIGGER things1_bi BEFORE INSERT ON things1 FOR EACH ROW BEGIN DELETE FROM things2; END; |\n"
"+--------------+-------------------------------------------------------------------------------------------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6225
msgid "box.schema.func.drop('_TRIGGERS_OPTS_SQL',{if_exists = true})\n"
"box.schema.func.create('_TRIGGERS_OPTS_SQL',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[function (opts)\n"
"                  return require('msgpack').decode(opts).sql end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TRIGGERS_OPTS_SQL')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_TRIGGERS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _triggers;]])\n"
"box.execute([[\n"
"CREATE VIEW _triggers AS SELECT\n"
"    CAST(NULL AS STRING) AS trigger_catalog,\n"
"    CAST(NULL AS STRING) AS trigger_schema,\n"
"    \"name\" AS trigger_name,\n"
"    CAST(_triggers_opts_sql(\"opts\") AS STRING) AS opts_sql,\n"
"    \"space_id\" AS space_id\n"
"    FROM \"_trigger\";\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TRIGGERS')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6254
msgid "Users who select from this view will need 'read' privilege on the _trigger space."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6260
msgid "_REFERENTIAL_CONSTRAINTS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6264
msgid "tarantool>SELECT constraint_name, update_rule, delete_rule, match_option,\n"
"> referencing, referenced\n"
"> FROM _referential_constraints;\n"
"OK 2 rows selected (0.0 seconds)\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+\n"
"| CONSTRAINT_NAME      | UPDATE_RULE | DELETE_RULE | MATCH_OPTION | REFERENCING | REFERENCED |\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+\n"
"| fk_unnamed_THINGS2_1 | no_action   | no_action   | simple       | THINGS2     | THINGS1    |\n"
"| fk_unnamed_THINGS3_1 | no_action   | no_action   | simple       | THINGS3     | THINGS1    |\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6277
#: ../doc/reference/reference_sql/sql.rst:6332
msgid "Definition of the CREATE VIEW statement:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6279
msgid "pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_REFERENTIAL_CONSTRAINTS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _referential_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _referential_constraints AS SELECT\n"
"    CAST(NULL AS STRING) AS constraint_catalog,\n"
"    CAST(NULL AS STRING) AS constraint_schema,\n"
"    \"name\" AS constraint_name,\n"
"    CAST(NULL AS STRING) AS unique_constraint_catalog,\n"
"    CAST(NULL AS STRING) AS unique_constraint_schema,\n"
"    '' AS unique_constraint_name,\n"
"    \"on_update\" AS update_rule,\n"
"    \"on_delete\" AS delete_rule,\n"
"    \"match\" AS match_option,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"child_id\") AS referencing,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"parent_id\") AS referenced,\n"
"    \"is_deferred\" AS is_deferred,\n"
"    \"child_id\" AS child_id,\n"
"    \"parent_id\" AS parent_id\n"
"    FROM \"_fk_constraint\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_REFERENTIAL_CONSTRAINTS')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6305
msgid "We are not taking child_cols or parent_cols from the _fk_constraint space because in standard SQL those are in a separate table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6309
msgid "Users who select from this view will need 'read' privilege on the _fk_constraint space."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6315
msgid "_CHECK_CONSTRAINTS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6319
msgid "tarantool>SELECT constraint_name, check_clause, space_name, language\n"
"> FROM _check_constraints;\n"
"OK 3 rows selected (0.0 seconds)\n"
"+------------------------+-------------------------+------------+----------+\n"
"| CONSTRAINT_NAME        | CHECK_CLAUSE            | SPACE_NAME | LANGUAGE |\n"
"+------------------------+-------------------------+------------+----------+\n"
"| ck_unnamed_Employees_1 | first_name LIKE 'Влад%' | Employees  | SQL      |\n"
"| ck_unnamed_Critics_1   | first_name LIKE 'Vlad%' | Critics    | SQL      |\n"
"| ck_unnamed_ACTORS_1    | salary > 0              | ACTORS     | SQL      |\n"
"+------------------------+-------------------------+------------+----------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6334
msgid "pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_CHECK_CONSTRAINTS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _check_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _check_constraints AS SELECT\n"
"    CAST(NULL AS STRING) AS constraint_catalog,\n"
"    CAST(NULL AS STRING) AS constraint_schema,\n"
"    \"name\" AS constraint_name,\n"
"    \"code\" AS check_clause,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"space_id\") AS space_name,\n"
"    \"language\" AS language,\n"
"    \"is_deferred\" AS is_deferred,\n"
"    \"space_id\" AS space_id\n"
"    FROM \"_ck_constraint\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_CHECK_CONSTRAINTS')"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6354
msgid "Users who select from this view will need 'read' privilege on the _ck_constraint space."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6360
msgid "_TABLE_CONSTRAINTS view"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6362
msgid "This has only the constraints (primary-key and unique-key) that can be found by looking at the :ref:`_index <box_space-index>` space. It is not a list of indexes, that is, it is not equivalent to INFORMATION_SCHEMA.STATISTICS. We do not take the columns of the index because in standard SQL they would be in a different table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6369
msgid "tarantool>SELECT constraint_name, constraint_type, table_name, id, iid, index_type\n"
"> FROM _table_constraints\n"
"> LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+-----------------+-----------------+-------------+-----+-----+------------+\n"
"| CONSTRAINT_NAME | CONSTRAINT_TYPE | TABLE_NAME  | ID  | IID | INDEX_TYPE |\n"
"+-----------------+-----------------+-------------+-----+-----+------------+\n"
"| primary         | PRIMARY         | _schema     | 272 |   0 | tree       |\n"
"| primary         | PRIMARY         | _collation  | 276 |   0 | tree       |\n"
"| name            | UNIQUE          | _collation  | 276 |   1 | tree       |\n"
"| primary         | PRIMARY         | _vcollation | 277 |   0 | tree       |\n"
"| name            | UNIQUE          | _vcollation | 277 |   1 | tree       |\n"
"+-----------------+-----------------+-------------+-----+-----+------------+"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:6387
msgid "box.schema.func.drop('_TABLE_CONSTRAINTS_OPTS_UNIQUE',{if_exists = true})\n"
"function _TABLE_CONSTRAINTS_OPTS_UNIQUE (opts) return require('msgpack').decode(opts).unique end\n"
"box.schema.func.create('_TABLE_CONSTRAINTS_OPTS_UNIQUE',\n"
"    {language = 'LUA',\n"
"     returns = 'boolean',\n"
"     body = [[function (opts) return require('msgpack').decode(opts).unique end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TABLE_CONSTRAINTS_OPTS_UNIQUE')\n"
"pcall(function ()\n"
"box.schema.role.revoke('public', 'read', 'space', '_TABLE_CONSTRAINTS', {if_exists = true})\n"
"end)\n"
"box.execute([[DROP VIEW IF EXISTS _table_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _table_constraints AS SELECT\n"
"CAST(NULL AS STRING) AS constraint_catalog,\n"
"CAST(NULL AS STRING) AS constraint_schema,\n"
"\"name\" AS constraint_name,\n"
"(SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"id\") AS table_name,\n"
"CASE WHEN \"iid\" = 0 THEN 'PRIMARY' ELSE 'UNIQUE' END AS constraint_type,\n"
"CAST(NULL AS STRING) AS initially_deferrable,\n"
"CAST(NULL AS STRING) AS deferred,\n"
"CAST(NULL AS STRING) AS enforced,\n"
"\"id\" AS id,\n"
"\"iid\" AS iid,\n"
"\"type\" AS index_type\n"
"FROM \"_vindex\" y\n"
"WHERE _table_constraints_opts_unique(\"opts\") = TRUE;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TABLE_CONSTRAINTS')"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:5
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:7
msgid "``tarantoolctl`` is a utility for administering Tarantool :ref:`instances <tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:13
msgid "See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:20
msgid "Command format"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:22
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:24
msgid "where:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:26
msgid "``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, ``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:30
msgid "``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:`module <app_server-modules>`."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:33
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:35
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:37
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:43
msgid "Commands for managing Tarantool instances"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:49
msgid "``tarantoolctl start NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:46
msgid "Start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:48
msgid "Additionally, this command sets the TARANTOOLCTL environment variable to 'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:52
msgid "``tarantoolctl stop NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:52
msgid "Stop a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:60
msgid "``tarantoolctl status NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:55
msgid "Show an instance's status (started/stopped). If pid file exists and an alive control socket exists, the return code is ``0``. Otherwise, the return code is not ``0``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:59
msgid "Reports typical problems to stderr (e.g. pid file exists and control socket doesn't)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:67
msgid "``tarantoolctl restart NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:63
msgid "Stop and start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:65
msgid "Additionally, this command sets the TARANTOOL_RESTARTED environment variable to 'true', to mark that the instance was restarted by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:72
msgid "``tarantoolctl logrotate NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:70
msgid "Rotate logs of a started Tarantool instance. Works only if logging-into-file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:75
msgid "``tarantoolctl check NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:75
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:83
msgid "``tarantoolctl enter NAME [--language=language]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:78
msgid "Enter an instance's interactive Lua or SQL console."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:80
msgid "Supported option:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:82
msgid "``--language=language`` to set :ref:`interactive console <interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:86
msgid "``tarantoolctl eval NAME FILE``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:86
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:90
msgid "``tarantoolctl connect URI``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:89
msgid "Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix sockets."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:96
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:99
msgid "``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:99
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:102
msgid "``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:102
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:104
#: ../doc/reference/tarantoolctl.rst:155
msgid "Supported options:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:106
msgid "``--space=space_no`` to filter the output by space number. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:108
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:109
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:110
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:111
msgid "``--replica=replica_id`` to filter the output by replica id. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:118
msgid "Commands for managing Tarantool modules"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:121
msgid "``tarantoolctl rocks install NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:121
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:124
msgid "``tarantoolctl rocks remove NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:124
msgid "Remove a module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:127
msgid "``tarantoolctl rocks show NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:127
msgid "Show information about an installed module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:130
msgid "``tarantoolctl rocks search NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:130
msgid "Search the repository for modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:133
msgid "``tarantoolctl rocks list``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:133
msgid "List all installed modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:143
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:136
msgid "Create a rock by packing sources or binaries."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:138
#: ../doc/reference/tarantoolctl.rst:148
msgid "As an argument, you can specify:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:140
msgid "a ``.rockspec`` file to create a source rock containing the module's sources, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:142
msgid "the name of an installed module (and its version if there are more than one) to create a binary rock containing the compiled module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:153
msgid "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> [version]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:146
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:150
msgid "source or binary rock files,"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:151
msgid "``.rockspec`` files, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:152
msgid "names of rocks or ``.rockspec`` files in remote repositories (and the rock version if there are more than one)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:157
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:158
msgid "``--only-server=server_name`` check this server only, ignore the usual list."
msgstr ""

