# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-23 11:38+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/reference/configuration/index.rst:5
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:5
msgid "Configuration reference"
msgstr ""

#: ../doc/reference/configuration/index.rst:7
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:10
msgid "Tarantool is started by entering either of the following command:"
msgstr ""

#: ../doc/reference/configuration/index.rst:49
msgid "$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/reference/configuration/index.rst:23
msgid "Command options"
msgstr ""

#: ../doc/reference/configuration/index.rst:27
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/reference/configuration/index.rst:33
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:35
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/reference/configuration/index.rst:42
#: ../doc/reference/reference_sql/sql.rst:2282
msgid "In this example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:44
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../doc/reference/configuration/index.rst:47
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/reference/configuration/index.rst:55
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../doc/reference/configuration/index.rst:60
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/reference/configuration/index.rst:70
msgid "URI"
msgstr ""

#: ../doc/reference/configuration/index.rst:72
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
msgid "URI fragment"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
#: ../doc/reference/reference_lua/digest.rst:361
#: ../doc/reference/reference_lua/fiber.rst:748
#: ../doc/reference/reference_lua/fiber.rst:945
#: ../doc/reference/reference_lua/fiber.rst:1074
#: ../doc/reference/reference_lua/log.rst:144
#: ../doc/reference/reference_lua/msgpack.rst:172
#: ../doc/reference/reference_lua/net_box.rst:636
#: ../doc/reference/reference_lua/tap.rst:348
#: ../doc/reference/reference_lua/uuid.rst:132
#: ../doc/reference/reference_lua/yaml.rst:68
#: ../doc/reference/reference_rock/dbms.rst:249
#: ../doc/reference/reference_rock/dbms.rst:590
msgid "Example"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "port"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "username:password@host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:100
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/reference/configuration/index.rst:104
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:110
msgid "Initialization file"
msgstr ""

#: ../doc/reference/configuration/index.rst:112
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/reference/configuration/index.rst:120
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/reference/configuration/index.rst:131
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../doc/reference/configuration/index.rst:135
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/reference/configuration/index.rst:149
msgid "If you wish to start an interactive session on the same terminal after initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:165
msgid "Configuration parameters"
msgstr ""

#: ../doc/reference/configuration/index.rst:167
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/reference/configuration/index.rst:169
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/reference/configuration/index.rst:171
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/reference/configuration/index.rst:176
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/reference/configuration/index.rst:181
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/reference/configuration/index.rst:184
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, for logging, and for feedback."
msgstr ""

#: ../doc/reference/configuration/index.rst:190
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:11
msgid "Basic parameters"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:13
msgid ":ref:`strip_core <cfg_basic-strip_core>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:19
msgid "Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../doc/reference/configuration/cfg_basic.rst:112
#: ../doc/reference/configuration/cfg_basic.rst:233
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/reference/configuration/cfg_replication.rst:124
#: ../doc/reference/configuration/cfg_logging.rst:134
#: ../doc/reference/configuration/cfg_logging.rst:291
#: ../doc/reference/configuration/cfg_deprecated.rst:25
#: ../doc/reference/configuration/cfg_deprecated.rst:55
#: ../doc/reference/configuration/cfg_deprecated.rst:66
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:95
msgid "Type: boolean"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:24
#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/reference/configuration/cfg_replication.rst:125
#: ../doc/reference/configuration/cfg_deprecated.rst:26
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:31
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:42
msgid "Default: false"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:25
#: ../doc/reference/configuration/cfg_basic.rst:87
#: ../doc/reference/configuration/cfg_basic.rst:98
#: ../doc/reference/configuration/cfg_basic.rst:142
#: ../doc/reference/configuration/cfg_basic.rst:169
#: ../doc/reference/configuration/cfg_basic.rst:183
#: ../doc/reference/configuration/cfg_basic.rst:208
#: ../doc/reference/configuration/cfg_basic.rst:235
#: ../doc/reference/configuration/cfg_storage.rst:43
#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../doc/reference/configuration/cfg_storage.rst:69
#: ../doc/reference/configuration/cfg_storage.rst:93
#: ../doc/reference/configuration/cfg_storage.rst:115
#: ../doc/reference/configuration/cfg_storage.rst:139
#: ../doc/reference/configuration/cfg_storage.rst:152
#: ../doc/reference/configuration/cfg_storage.rst:164
#: ../doc/reference/configuration/cfg_storage.rst:175
#: ../doc/reference/configuration/cfg_storage.rst:186
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:216
#: ../doc/reference/configuration/cfg_replication.rst:238
#: ../doc/reference/configuration/cfg_logging.rst:112
#: ../doc/reference/configuration/cfg_logging.rst:136
#: ../doc/reference/configuration/cfg_deprecated.rst:27
#: ../doc/reference/configuration/cfg_deprecated.rst:57
#: ../doc/reference/configuration/cfg_deprecated.rst:95
#: ../doc/reference/configuration/cfg_deprecated.rst:110
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:53
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:77
msgid "Dynamic: no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:31
msgid "Add the given string to the server's process title (what’s shown in the COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:35
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:38
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:43
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:46
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:51
#: ../doc/reference/configuration/cfg_basic.rst:85
#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:140
#: ../doc/reference/configuration/cfg_basic.rst:167
#: ../doc/reference/configuration/cfg_basic.rst:181
#: ../doc/reference/configuration/cfg_basic.rst:206
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/reference/configuration/cfg_replication.rst:44
#: ../doc/reference/configuration/cfg_replication.rst:214
#: ../doc/reference/configuration/cfg_replication.rst:236
#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../doc/reference/configuration/cfg_logging.rst:189
#: ../doc/reference/configuration/cfg_logging.rst:302
msgid "Type: string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:52
#: ../doc/reference/configuration/cfg_basic.rst:74
#: ../doc/reference/configuration/cfg_basic.rst:97
#: ../doc/reference/configuration/cfg_basic.rst:168
#: ../doc/reference/configuration/cfg_basic.rst:207
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/reference/configuration/cfg_replication.rst:45
#: ../doc/reference/configuration/cfg_replication.rst:104
#: ../doc/reference/configuration/cfg_replication.rst:215
#: ../doc/reference/configuration/cfg_replication.rst:237
#: ../doc/reference/configuration/cfg_networking.rst:15
#: ../doc/reference/configuration/cfg_logging.rst:111
msgid "Default: null"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:53
#: ../doc/reference/configuration/cfg_basic.rst:75
#: ../doc/reference/configuration/cfg_basic.rst:114
#: ../doc/reference/configuration/cfg_basic.rst:159
#: ../doc/reference/configuration/cfg_basic.rst:222
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:100
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:112
#: ../doc/reference/configuration/cfg_deprecated.rst:68
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:32
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:43
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:87
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:97
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:109
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:124
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:145
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:160
msgid "Dynamic: yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:59
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:66
msgid "A typical value is 3301."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:70
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:73
msgid "Type: integer or string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:81
msgid "A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:86
#: ../doc/reference/configuration/cfg_basic.rst:141
#: ../doc/reference/configuration/cfg_basic.rst:182
msgid "Default: \".\""
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:93
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:104
msgid "Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. After this, any requests that try to change persistent data will fail with error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :ref:`replication <replication>`. Read-only mode does not affect data-change requests for spaces defined as :ref:`temporary <box_schema-space_create>`. Although read-only mode prevents the server from writing to the :ref:`WAL <internals-wal>`, it does not prevent writing diagnostics with the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:116
msgid "Setting ``read_only == true`` affects spaces differently depending on the options that were used during :ref:`box.schema.space.create <box_schema-space_create>`, as summarized by this chart:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Option"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be created?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be written to?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is replicated?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is persistent?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
msgid "(default)"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:127
msgid "temporary"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "is_local"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:136
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:148
msgid "The vinyl storage engine has a scheduler which does compaction. When vinyl is low on available memory, the compaction scheduler may be unable to keep up with incoming update requests. In that situation, queries may time out after ``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would throttle inserts when it is running low on compaction bandwidth. Compaction can also be ordered manually with :ref:`index_object:compact() <box_index-compact>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:157
#: ../doc/reference/configuration/cfg_storage.rst:28
#: ../doc/reference/configuration/cfg_storage.rst:67
#: ../doc/reference/configuration/cfg_storage.rst:162
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/reference/configuration/cfg_replication.rst:75
#: ../doc/reference/configuration/cfg_replication.rst:148
#: ../doc/reference/configuration/cfg_replication.rst:165
#: ../doc/reference/configuration/cfg_networking.rst:14
#: ../doc/reference/configuration/cfg_logging.rst:146
#: ../doc/reference/configuration/cfg_logging.rst:312
#: ../doc/reference/configuration/cfg_deprecated.rst:93
#: ../doc/reference/configuration/cfg_deprecated.rst:108
msgid "Type: float"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:158
msgid "Default: 60"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:165
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:175
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:189
msgid "A directory where database working files will be stored. The server instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:195
msgid "box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:203
msgid "will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:215
msgid "The maximum number of threads to use during execution of certain internal processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:220
#: ../doc/reference/configuration/cfg_storage.rst:41
#: ../doc/reference/configuration/cfg_storage.rst:53
#: ../doc/reference/configuration/cfg_storage.rst:78
#: ../doc/reference/configuration/cfg_storage.rst:91
#: ../doc/reference/configuration/cfg_storage.rst:101
#: ../doc/reference/configuration/cfg_storage.rst:113
#: ../doc/reference/configuration/cfg_storage.rst:137
#: ../doc/reference/configuration/cfg_storage.rst:150
#: ../doc/reference/configuration/cfg_storage.rst:173
#: ../doc/reference/configuration/cfg_storage.rst:184
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:110
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:58
#: ../doc/reference/configuration/cfg_replication.rst:103
#: ../doc/reference/configuration/cfg_networking.rst:50
#: ../doc/reference/configuration/cfg_networking.rst:67
#: ../doc/reference/configuration/cfg_logging.rst:28
msgid "Type: integer"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:221
#: ../doc/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:228
msgid "Whether coredump files should include memory allocated for tuples. (This can be large if Tarantool runs under heavy load.) Setting to ``true`` means \"do not include\". In an older version of Tarantool the default value of this parameter was ``false``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:234
#: ../doc/reference/configuration/cfg_logging.rst:292
#: ../doc/reference/configuration/cfg_deprecated.rst:56
#: ../doc/reference/configuration/cfg_deprecated.rst:67
msgid "Default: true"
msgstr ""

#: ../doc/reference/configuration/index.rst:196
msgid "Configuring the storage"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:19
msgid "How much memory Tarantool allocates to actually store tuples, in bytes. When the limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the ``memtx_memory`` limit to allocate tuples, but there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:30
#: ../doc/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:36
msgid "Size of the largest allocation unit, in bytes, for the memtx storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:42
#: ../doc/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:49
msgid "Size of the smallest allocation unit, in bytes. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:61
msgid "Bloom filter false positive rate -- the suitable probability of the `bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:75
msgid "The cache size for the vinyl storage engine, in bytes. The cache can be resized dynamically."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:79
#: ../doc/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:80
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/reference/configuration/cfg_replication.rst:46
#: ../doc/reference/configuration/cfg_replication.rst:60
#: ../doc/reference/configuration/cfg_replication.rst:77
#: ../doc/reference/configuration/cfg_replication.rst:105
#: ../doc/reference/configuration/cfg_replication.rst:126
#: ../doc/reference/configuration/cfg_replication.rst:150
#: ../doc/reference/configuration/cfg_replication.rst:167
#: ../doc/reference/configuration/cfg_networking.rst:16
#: ../doc/reference/configuration/cfg_networking.rst:52
#: ../doc/reference/configuration/cfg_networking.rst:69
#: ../doc/reference/configuration/cfg_logging.rst:30
#: ../doc/reference/configuration/cfg_logging.rst:148
#: ../doc/reference/configuration/cfg_logging.rst:191
#: ../doc/reference/configuration/cfg_logging.rst:293
#: ../doc/reference/configuration/cfg_logging.rst:304
#: ../doc/reference/configuration/cfg_logging.rst:314
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:86
msgid "Size of the largest allocation unit, in bytes, for the vinyl storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:99
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:109
msgid "Page size, in bytes. Page is a read/write unit for vinyl disk operations. The ``vinyl_page_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:114
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:121
msgid "The default maximum range size for a vinyl index, in bytes. The maximum range size affects the decision whether to :ref:`split <engines-vinyl_split>` a range."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:125
msgid "If ``vinyl_range_size`` is not nil and not 0, then it is used as the default value for the ``range_size`` option in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:130
msgid "If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified when the index is created, then Tarantool sets a value later depending on performance considerations. To see the actual value, use :ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:135
msgid "In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value was 1073741824."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:138
msgid "Default = nil"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:145
msgid "The maximal number of runs per level in vinyl LSM tree. If this number is exceeded, a new level is created. The ``vinyl_run_count_per_level`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:151
#: ../doc/reference/configuration/cfg_storage.rst:185
msgid "Default = 2"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:158
msgid "Ratio between the sizes of different levels in the LSM tree. The ``vinyl_run_size_ratio`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:163
msgid "Default = 3.5"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:170
msgid "The maximum number of read threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:174
msgid "Default = 1"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:181
msgid "The maximum number of write threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/index.rst:204
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:3
msgid ":ref:`checkpoint_wal_threshold <cfg_checkpoint_daemon-checkpoint_wal_threshold>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:5
msgid "The checkpoint daemon is a fiber which is constantly running. At intervals, it may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may delete old snapshot files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:9
msgid "The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before deletions occur."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:16
msgid "**Tarantool garbage collector**"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:18
msgid "The checkpoint daemon may activate the Tarantool garbage collector which deletes old files. This garbage collector is distinct from the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ which is for Lua objects, and distinct from a Tarantool garbage collector which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:25
msgid "If the checkpoint daemon deletes an old snapshot file, then the Tarantool garbage collector will also delete any :ref:`write-ahead log (.xlog) <internals-wal>` files which are older than the snapshot file and which contain information that is present in the snapshot file. It will also delete obsolete vinyl ``.run`` files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:31
msgid "The checkpoint daemon and the Tarantool garbage collector will not delete a file if:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:33
msgid "a **backup** is ongoing and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:36
msgid "**replication** is ongoing and the file has not been relayed to a replica (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:39
msgid "a replica is connecting, or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:41
msgid "a replica has fallen behind. The progress of each replica is tracked; if a replica's position is far from being up to date, then the server stops to give it a chance to catch up. If an administrator concludes that a replica is permanently down, then the correct procedure is to restart the server, or (preferably) :ref:`remove the replica from the cluster <replication-remove_instances>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:53
msgid "The interval between actions by the checkpoint daemon, in seconds. If ``checkpoint_interval`` is set to a value greater than zero, and there is activity which causes change to a database, then the checkpoint daemon will call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, creating a new snapshot file each time. If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:60
#: ../doc/reference/reference_lua/box_error.rst:70
#: ../doc/reference/reference_lua/digest.rst:235
#: ../doc/reference/reference_rock/dbms.rst:82
#: ../doc/reference/reference_rock/dbms.rst:435
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:452
#: ../doc/reference/reference_sql/sql.rst:1125
#: ../doc/reference/reference_sql/sql.rst:2172
msgid "For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:62
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:66
msgid "will cause the checkpoint daemon to create a new database snapshot once per minute, if there is activity."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:70
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:77
msgid "The maximum number of snapshots that may exist on the :ref:`memtx_dir <cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does not delete old snapshots. For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:83
msgid "box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:90
msgid "will cause the checkpoint daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will delete the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:94
msgid "Remember that, as noted earlier, snapshots will not be deleted if replication is ongoing and the file has not been relayed to a replica. Therefore ``checkpoint_count`` has no effect unless all replicas are alive."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:97
msgid "Default: 2"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:106
msgid "The threshold for the total size in bytes of all WAL files created since the last checkpoint. Once the configured threshold is exceeded, the WAL thread notifies the checkpoint daemon that it must make a new checkpoint and delete old WAL files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:111
msgid "Default: 10^18 (a large number so in effect there is no limit by default)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:114
msgid "This parameter was added in version 2.1. It enables administrators to handle a problem that could occur with calculating how much disk space to allocate for a partition containing WAL files. For example, suppose :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` = 2 and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` = 5 and the average amount that Tarantool writes between each checkpoint interval = 1 GB. Then one could calculate that the necessary amount is (2*5*1) 10GB. But this calculation would be wrong if, instead of writing 1 GB during one checkpoint interval, Tarantool encounters an unusual spike and tries to write 11 GB, causing an operating-system ENOSPC (\"no space\") error. By setting checkpoint_wal_threshold to a lower value, say 9 GB, an administrator could prevent the error."
msgstr ""

#: ../doc/reference/configuration/index.rst:210
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If ``force_recovery`` equals true, Tarantool tries to continue if there is an error while reading a :ref:`snapshot file<index-box_persistence>` (at server instance start) or a :ref:`write-ahead log file<internals-wal>` (at server instance start or when applying an update at a replica): skips invalid records, reads as much data as possible and lets the process finish with a warning. Users can prevent the error from recurring by writing to the database and executing :ref:`box.snapshot() <box-snapshot>`."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid "The maximum number of bytes in a single write-ahead log file. When a request would cause an .xlog file to become larger than ``wal_max_size``, Tarantool creates another WAL file -- the same effect that happens when the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit is reached."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid "Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and moving snapshots to a separate disk. The limit also affects what :ref:`box.stat.vinyl().regulator <box_introspection-box_stat_vinyl_regulator>` may show for the write rate of dumps to .run and .index files."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of :ref:`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:218
msgid "Hot standby"
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:5
msgid "Hot standby is a feature which provides a simple form of failover without :ref:`replication <replication>`."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:8
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:12
msgid "To initiate the standby instance, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings -- including the same directories and same non-null URIs -- and with the additional configuration setting ``hot_standby = true``. Expect to see a notification ending with the words ``I> Entering hot standby mode``. This is fine. It means that the standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:22
msgid "The standby instance will initialize and will try to take a lock on :ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has made a lock on ``wal_dir``. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in sync), and trying to take the lock. If the primary instance goes down for any reason, the lock will be released. In this case, the standby instance will succeed in taking the lock, will connect on the :ref:`listen <cfg_basic-listen>` address and will become the primary instance. Expect to see a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:39
msgid "if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:43
msgid "if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:45
msgid "for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/reference/configuration/index.rst:224
msgid "Replication"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:3
msgid ":ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:4
msgid ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:5
msgid ":ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:15
msgid "If ``replication`` is not an empty string, the instance is considered to be a Tarantool :ref:`replica <replication>`. The replica will try to connect to the master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:22
msgid "If there is more than one replication source in a replica set, specify an array of URIs, for example (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:28
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it is possible to use the same ``replication`` specification on multiple server instances, as shown in :ref:`these examples <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:36
msgid "A read-only replica does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:39
msgid "The ``replication`` parameter is dynamic, that is, to enter master mode, simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:52
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:59
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:108
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:123
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:159
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:189
msgid "Default: 1"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:66
msgid "The number of seconds that a replica will wait when trying to connect to a master in a cluster. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:70
msgid "This parameter is different from :ref:`replication_timeout <cfg_replication-replication_timeout>`, which is only used to automatically reconnect replication when it gets no heartbeats."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:83
msgid "By default a replica will try to connect to all the masters, or it will not start. (The default is recommended so that all replicas will receive the same replica set UUID.)"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:87
msgid "However, by specifying ``replication_connect_quorum = N``, where N is a number greater than or equal to zero, users can state that the replica only needs to connect to N masters."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:91
msgid "This parameter has effect during bootstrap and during :ref:`configuration update <replication-configuration_update>`. Setting ``replication_connect_quorum = 0`` makes Tarantool require no immediate reconnect only in case of recovery. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:97
#: ../doc/reference/configuration/cfg_replication.rst:118
#: ../doc/reference/configuration/cfg_replication.rst:208
#: ../doc/reference/configuration/cfg_replication.rst:230
#: ../doc/reference/reference_lua/other.rst:163
#: ../doc/reference/reference_lua/swim.rst:142
#: ../doc/reference/reference_lua/swim.rst:225
#: ../doc/reference/reference_lua/swim.rst:238
#: ../doc/reference/reference_lua/swim.rst:336
#: ../doc/reference/reference_lua/swim.rst:517
#: ../doc/reference/reference_lua/swim.rst:549
#: ../doc/reference/reference_lua/swim.rst:711
#: ../doc/reference/reference_lua/swim.rst:736
#: ../doc/reference/reference_lua/swim.rst:921
#: ../doc/reference/reference_sql/sql.rst:758
#: ../doc/reference/reference_sql/sql.rst:1335
#: ../doc/reference/reference_sql/sql.rst:1423
#: ../doc/reference/reference_sql/sql.rst:2269
#: ../doc/reference/reference_sql/sql.rst:2294
#: ../doc/reference/reference_sql/sql.rst:2346
#: ../doc/reference/reference_sql/sql.rst:2424
#: ../doc/reference/reference_sql/sql.rst:2465
#: ../doc/reference/reference_sql/sql.rst:2495
#: ../doc/reference/reference_sql/sql.rst:2524
#: ../doc/reference/reference_sql/sql.rst:2645
#: ../doc/reference/reference_sql/sql.rst:2687
msgid "Example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:111
msgid "By default, if a replica adds a unique key that another replica has added, replication :ref:`stops <replication-replication_stops>` with error = ER_TUPLE_FOUND."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:115
msgid "However, by specifying ``replication_skip_conflict = true``, users can state that such errors may be ignored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:133
msgid "The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a replica. When a replica :ref:`syncs <replication-orphan_status>` (gets updates from a master), it may not catch up completely. The number of seconds that the replica is behind the master is called the \"lag\". Syncing is considered to be complete when the replica's lag is less than or equal to ``replication_sync_lag``."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:140
msgid "If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 (TIMEOUT_INFINITY), then lag does not matter -- the replica is always considered to be \"synced\". Also, the lag is ignored (assumed to be infinite) in case the master is running Tarantool older than 1.7.7, which does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:145
msgid "This parameter is ignored during bootstrap. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:156
msgid "The number of seconds that a replica will wait when trying to sync with a master in a cluster, or a :ref:`quorum <cfg_replication-replication_connect_quorum>` of masters, after connecting or during :ref:`configuration update <replication-configuration_update>`. This could fail indefinitely if ``replication_sync_lag`` is smaller than network latency, or if the replica cannot keep pace with master updates. If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan status <replication-orphan_status>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:173
msgid "As described in section :ref:`\"Replication architecture\" <replication-architecture>`, each replica set is identified by a `universally unique identifier <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called **replica set UUID**, and each instance is identified by an **instance UUID**."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:180
msgid "Ordinarily it is sufficient to let the system generate and format the UUID strings which will be permanently stored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:183
msgid "However, some administrators may prefer to store Tarantool configuration information in a central repository, for example `Apache ZooKeeper <https://zookeeper.apache.org>`_. Such administrators can assign their own UUID values for either -- or both -- instances (:ref:`instance_uuid <cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), when starting up for the first time."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:192
msgid "The values must be true unique identifiers, not shared by other instances or replica sets within the common infrastructure."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:195
msgid "The values must be used consistently, not changed after initial setup (the initial values are stored in :ref:`snapshot files <index-box_persistence>` and are checked whenever the system is restarted)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:199
msgid "The values must comply with `RFC 4122 <https://tools.ietf.org/html/rfc4122>`_. The `nil UUID <https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:203
msgid "The UUID format includes sixteen octets represented as 32 hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric characters and four hyphens)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:222
msgid "For replication administration purposes, it is possible to set the `universally unique identifiers <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the instance (``instance_uuid``) and the replica set (``replicaset_uuid``), instead of having the system generate the values."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:227
msgid "See the description of :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` parameter for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr ""

#: ../doc/reference/configuration/index.rst:230
msgid "Networking"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:9
msgid "The instance will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:22
msgid "To handle messages, Tarantool allocates fibers. To prevent fiber overhead from affecting the whole system, Tarantool restricts how many messages the fibers handle, so that some pending requests are blocked."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:27
msgid "On powerful systems, increase ``net_msg_max`` and the scheduler will immediately start processing pending requests."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:30
msgid "On weaker systems, decrease ``net_msg_max`` and the overhead may decrease although this may take some time because the scheduler must wait until already-running requests finish."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:34
msgid "When ``net_msg_max`` is reached, Tarantool suspends processing of incoming packages until it has processed earlier messages. This is not a direct restriction of the number of fibers that handle network messages, rather it is a system-wide restriction of channel bandwidth. This in turn causes restriction of the number of incoming network messages that the :ref:`transaction processor thread <atomic-threads_fibers_yields>` handles, and therefore indirectly affects the fibers that handle network messages. (The number of fibers is smaller than the number of messages because messages can be released as soon as they are delivered, while incoming requests might not be processed until some time after delivery.)"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:58
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr ""

#: ../doc/reference/configuration/index.rst:236
msgid "Logging"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:13
msgid "What level of detail the :ref:`log <admin-logs>` will have. There are seven levels:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:15
#: ../doc/reference/reference_lua/log.rst:91
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:17
#: ../doc/reference/reference_lua/log.rst:93
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:23
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:32
msgid "Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:41
msgid "By default, Tarantool sends the log to the standard error stream (``stderr``). If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:47
msgid "box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:53
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``log`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:59
msgid "box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:65
msgid "This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:73
msgid "box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:83
msgid "If the ``log`` string begins with \"syslog:\", then it is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. The setting can be 'syslog:', 'syslog:facility=...', 'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:90
msgid "The ``syslog:identity`` setting is an arbitrary string which will be placed at the beginning of all messages. The default value is: tarantool."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:93
msgid "The ``syslog:facility`` setting is currently ignored but will be used in the future. The value must be one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd where the message should go. The possible values are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7. The default value is: user."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:100
msgid "The ``syslog:server`` setting is the locator for the syslog server. It can be a Unix socket path beginning with \"unix:\", or an ipv4 port number. The default socket value is: dev/log (on Linux) or /var/run/syslog (on Mac OS). The default port value is: 514, the UDP port."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:105
msgid "When logging to a file, Tarantool reopens the log on `SIGHUP <https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:118
msgid "If ``log_nonblock`` equals true, Tarantool does not block during logging when the system is not ready for writing, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go to the log, setting ``log_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:124
msgid "This parameter has effect only if the output is going to \"syslog:\" or \"pipe:\". Setting ``log_nonblock`` to true is illegal if the output is going to a file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:129
msgid "The default ``log_nonblock`` value is nil, which means that blocking behavior corresponds to the type of logger. This is a behavior change: in earlier versions of the Tarantool server, the default value was true."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:135
msgid "Default: nil"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:142
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:147
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:86
msgid "Default: 0.5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:154
msgid "Log entries have two possible formats:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:156
#: ../doc/reference/reference_lua/log.rst:21
msgid "'plain' (the default), or"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:157
#: ../doc/reference/reference_lua/log.rst:22
msgid "'json' (with more detail and with JSON labels)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:159
#: ../doc/reference/reference_lua/log.rst:24
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:161
#: ../doc/reference/reference_lua/log.rst:26
msgid "2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' configuration option to \"plain\""
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:165
#: ../doc/reference/reference_lua/log.rst:30
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:167
#: ../doc/reference/reference_lua/log.rst:32
msgid "{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:179
msgid "The ``log_format='plain'`` entry has time, process id, cord name, :ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:184
msgid "The ``log_format='json'`` entry has the same things along with their labels, and in addition has the file name and line number of the Tarantool source."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:187
msgid "Setting ``log_format`` to 'json' is illegal if the output is going to \"syslog:\"."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:190
msgid "Default: 'plain'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:197
msgid "Logging example"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:199
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:202
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:204
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:207
msgid "box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:213
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1517
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:221
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:223
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:227
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1530
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:234
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool instance. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1540
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:244
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:246
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:250
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1554
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:259
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:1562
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:269
msgid "Feedback"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:271
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:272
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:273
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:275
msgid "By default a Tarantool daemon sends a small packet once per hour, to https://feedback.tarantool.io. The packet contains three values from :ref:`box.info <box_introspection-box_info>`: ``box.info.version``, ``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the feedback configuration parameters, users can adjust or turn off this feature."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:286
msgid "Whether to send feedback."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:288
msgid "If this is set to ``true``, feedback will be sent as described above. If this is set to ``false``, no feedback will be sent."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:299
msgid "The address to which the packet is sent. Usually the recipient is Tarantool, but it can be any URL."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:303
msgid "Default: 'https://feedback.tarantool.io'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:310
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:313
msgid "Default: 3600"
msgstr ""

#: ../doc/reference/configuration/index.rst:242
msgid "Deprecated parameters"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:8
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:9
msgid ":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:33
msgid "**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:41
msgid "**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:49
#: ../doc/reference/configuration/cfg_deprecated.rst:63
msgid "**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:52
msgid "If there is an error while reading a snapshot file (at server instance start), abort."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:74
msgid "**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:86
msgid "How much memory Tarantool allocates to actually store tuples, **in gigabytes**. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:103
msgid "The multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:116
msgid "**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:125
msgid "**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:134
msgid "**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:142
msgid "**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:151
msgid "**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/index.rst:5
msgid "Reference"
msgstr ""

#: ../doc/reference/interactive_console.rst:5
msgid "Interactive console"
msgstr ""

#: ../doc/reference/interactive_console.rst:7
msgid "The \"interactive console\" is Tarantool's basic \"command-line interface\" for entering requests and seeing results. It is what users see when they start the server without an :ref:`instance file <admin-instance_file>`, or start :ref:`tarantoolctl <tarantoolctl>` with ``enter``. It is often called the Lua console to distinguish it from the administrative console, but in fact it can handle both Lua and SQL input. The majority of examples in this manual show what users see with the interactive console, including the prompt (which can be \"tarantool> \"), the instruction (which can be a Lua request or an SQL statement), and the response (which can be a display in either YAML format or Lua format)."
msgstr ""

#: ../doc/reference/interactive_console.rst:18
msgid "-- Typical interactive console example with Lua input and YAML output\n"
"tarantool> box.info().replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: a5d22f66-2d28-4a35-b78f-5bf73baf6c8a\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/reference/interactive_console.rst:29
msgid "The **input language** can be changed to SQL with ``\\set language sql`` or changed to Lua (the default) with ``\\set language lua``."
msgstr ""

#: ../doc/reference/interactive_console.rst:32
msgid "The **delimiter** can be changed to any character with :samp:`\\set delimiter <character>`. The default is nothing, which means input does not need to end with a delimiter. But a common recommendation is to say ``set delimiter ;`` especially if input is SQL."
msgstr ""

#: ../doc/reference/interactive_console.rst:38
msgid "The **output format** can be changed to Lua with ``\\set output lua`` or changed to YAML (the default) with ``\\set output yaml``."
msgstr ""

#: ../doc/reference/interactive_console.rst:41
msgid "Ordinarily. output from the console has `YAML format <http://yaml.org/spec>`_. That means that there is a line for document-start ``\"---\"``, and each item begins on a separate line starting with ``\"- \"``, and each sub-item in a nested structure is indented, and there is a line for document-end ``\"...\"``."
msgstr ""

#: ../doc/reference/interactive_console.rst:47
msgid "Optionally, output from the console can have Lua format. That means that there are no lines for document-start or document-end, and items are not on separate lines (they are only separated by commas), and each sub-item in a nested structure is placed inside \"``{}``\" braces. So, when input is a Lua object description, output will equal input."
msgstr ""

#: ../doc/reference/interactive_console.rst:53
msgid "YAML is good for readability. Lua is good for re-using results as requests. A third format, MsgPack, is good for database storage. Currently the default output format is YAML but it may be Lua in a future version, and it may be Lua if the last :ref:`set_default_output <console-set_default_output>` call was ``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/interactive_console.rst:69
#: ../doc/reference/reference_sql/sql.rst:426
msgid "Type"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "Lua input"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "Lua output"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "YAML output"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "MsgPack storage"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#: ../doc/reference/reference_sql/sql.rst:255
msgid "scalar"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#: ../doc/reference/interactive_console.rst:71
msgid ":code:`1`"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
msgid ":code:`---` |br| :code:`- 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
msgid ":code:`\\x01`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid "scalar sequence"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
#: ../doc/reference/interactive_console.rst:75
msgid ":code:`1,2,3`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid ":code:`---` |br| :code:`- 1` |br| :code:`- 2` |br| :code:`- 3` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid ":code:`\\x01 \\x02 \\x03`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid "2-element table"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
#: ../doc/reference/interactive_console.rst:81
msgid ":code:`{1,2}`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`---` |br| :code:`- - 1` |br| :code:`- - 2` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`0x92 0x01 0x02`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid "map"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
#: ../doc/reference/interactive_console.rst:86
msgid ":code:`{key=1}`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`---` |br| :code:`- key: 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`\\x81 \\xa3 \\x6b \\x65 \\x79 \\x01`"
msgstr ""

#: ../doc/reference/lua_tips.rst:5
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/reference/lua_tips.rst:7
msgid "The Lua syntax for :ref:`data-manipulation functions <index-box_data-operations>` can vary. Here are examples of the variations with ``select()`` requests. The same rules exist for the other data-manipulation functions."
msgstr ""

#: ../doc/reference/lua_tips.rst:11
msgid "Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For these examples, we assume that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/reference/lua_tips.rst:20
msgid "Object reference variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:22
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:24
msgid "-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:34
msgid "Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form (#1). However, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:38
msgid "Also, descriptions in this manual use the syntax \"``space_object:``\" for references to objects which are spaces, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/reference/lua_tips.rst:47
msgid "Parameter variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:49
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:51
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/reference/lua_tips.rst:70
msgid "Lua allows to omit parentheses ``()`` when invoking a function if its only argument is a Lua table, and we use it sometimes in our examples. This is why ``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, as in examples #6 and #7."
msgstr ""

#: ../doc/reference/lua_tips.rst:76
msgid "Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the ``{1}`` form. However, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:85
msgid "Rules for object names"
msgstr ""

#: ../doc/reference/lua_tips.rst:87
msgid "Database objects have loose **rules for names**: the maximum length is 65000 bytes (not characters), and almost any legal Unicode character is allowed, including spaces, ideograms and punctuation."
msgstr ""

#: ../doc/reference/lua_tips.rst:92
msgid "In those cases, to prevent confusion with Lua operators and separators, object references should have the literal-in-square-brackets form (#2), or the variable form (#3). For example:"
msgstr ""

#: ../doc/reference/lua_tips.rst:96
msgid "tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:102
msgid "Disallowed:"
msgstr ""

#: ../doc/reference/lua_tips.rst:104
msgid "characters which are unassigned code points,"
msgstr ""

#: ../doc/reference/lua_tips.rst:105
msgid "line and paragraph separators,"
msgstr ""

#: ../doc/reference/lua_tips.rst:106
msgid "control characters,"
msgstr ""

#: ../doc/reference/lua_tips.rst:107
msgid "the replacement character (U+FFFD)."
msgstr ""

#: ../doc/reference/lua_tips.rst:109
msgid "Not recommended: characters which cannot be displayed."
msgstr ""

#: ../doc/reference/lua_tips.rst:111
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:5
msgid "Module `box`"
msgstr ""

#: ../doc/reference/reference_lua/box.rst:7
msgid "As well as executing Lua chunks or defining your own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:10
msgid "Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:15
msgid "To catch errors that functions in ``box`` submodules may throw, use :ref:`pcall <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:17
msgid "The contents of the ``box`` module can be inspected at runtime with ``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:3
msgid "Submodule box.backup"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:5
msgid "The box.backup submodule contains two functions that are helpful for :ref:`backup <admin-backups>` in certain situations."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:12
msgid "Informs the server that activities related to the removal of outdated backups must be suspended."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:15
msgid "To guarantee an opportunity to copy these files, Tarantool will not delete them. But there will be no read-only mode and checkpoints will continue by schedule as usual."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_once.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
msgid "Parameters"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:19
msgid "optional argument starting with Tarantool 1.10.1 that indicates the checkpoint to use relative to the latest checkpoint. For example ``n = 0`` means “backup will be based on the latest checkpoint”, ``n = 1`` means \"backup will be based on the first checkpoint before the latest checkpoint (counting backwards)\", and so on. The default value for n is zero."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:26
msgid "**Return:**  a table with the names of snapshot and vinyl files that should be copied"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:29
#: ../doc/reference/reference_lua/box_error.rst:80
#: ../doc/reference/reference_lua/box_error.rst:120
#: ../doc/reference/reference_lua/box_error.rst:160
#: ../doc/reference/reference_lua/box_snapshot.rst:49
#: ../doc/reference/reference_lua/buffer.rst:23
#: ../doc/reference/reference_lua/clock.rst:78
#: ../doc/reference/reference_lua/clock.rst:103
#: ../doc/reference/reference_lua/clock.rst:124
#: ../doc/reference/reference_lua/clock.rst:145
#: ../doc/reference/reference_lua/clock.rst:167
#: ../doc/reference/reference_lua/console.rst:86
#: ../doc/reference/reference_lua/console.rst:117
#: ../doc/reference/reference_lua/console.rst:142
#: ../doc/reference/reference_lua/console.rst:181
#: ../doc/reference/reference_lua/crypto.rst:71
#: ../doc/reference/reference_lua/crypto.rst:103
#: ../doc/reference/reference_lua/crypto.rst:132
#: ../doc/reference/reference_lua/csv.rst:77
#: ../doc/reference/reference_lua/csv.rst:159
#: ../doc/reference/reference_lua/csv.rst:204
#: ../doc/reference/reference_lua/errno.rst:60
#: ../doc/reference/reference_lua/fiber.rst:201
#: ../doc/reference/reference_lua/fiber.rst:240
#: ../doc/reference/reference_lua/fiber.rst:263
#: ../doc/reference/reference_lua/fiber.rst:283
#: ../doc/reference/reference_lua/fiber.rst:303
#: ../doc/reference/reference_lua/fiber.rst:318
#: ../doc/reference/reference_lua/fiber.rst:337
#: ../doc/reference/reference_lua/fiber.rst:356
#: ../doc/reference/reference_lua/fiber.rst:383
#: ../doc/reference/reference_lua/fiber.rst:409
#: ../doc/reference/reference_lua/fiber.rst:433
#: ../doc/reference/reference_lua/fiber.rst:458
#: ../doc/reference/reference_lua/fiber.rst:485
#: ../doc/reference/reference_lua/fiber.rst:508
#: ../doc/reference/reference_lua/fiber.rst:535
#: ../doc/reference/reference_lua/fiber.rst:566
#: ../doc/reference/reference_lua/fiber.rst:634
#: ../doc/reference/reference_lua/fiber.rst:684
#: ../doc/reference/reference_lua/fiber.rst:717
#: ../doc/reference/reference_lua/fiber.rst:736
#: ../doc/reference/reference_lua/fio.rst:184
#: ../doc/reference/reference_lua/fio.rst:206
#: ../doc/reference/reference_lua/fio.rst:226
#: ../doc/reference/reference_lua/fio.rst:245
#: ../doc/reference/reference_lua/fio.rst:321
#: ../doc/reference/reference_lua/fio.rst:357
#: ../doc/reference/reference_lua/fio.rst:396
#: ../doc/reference/reference_lua/fio.rst:416
#: ../doc/reference/reference_lua/fio.rst:437
#: ../doc/reference/reference_lua/fio.rst:460
#: ../doc/reference/reference_lua/fio.rst:477
#: ../doc/reference/reference_lua/fio.rst:492
#: ../doc/reference/reference_lua/fio.rst:516
#: ../doc/reference/reference_lua/fio.rst:538
#: ../doc/reference/reference_lua/fio.rst:561
#: ../doc/reference/reference_lua/fio.rst:587
#: ../doc/reference/reference_lua/fio.rst:613
#: ../doc/reference/reference_lua/fio.rst:637
#: ../doc/reference/reference_lua/fio.rst:660
#: ../doc/reference/reference_lua/fio.rst:682
#: ../doc/reference/reference_lua/fio.rst:708
#: ../doc/reference/reference_lua/fio.rst:726
#: ../doc/reference/reference_lua/fio.rst:827
#: ../doc/reference/reference_lua/fio.rst:858
#: ../doc/reference/reference_lua/fio.rst:978
#: ../doc/reference/reference_lua/fio.rst:998
#: ../doc/reference/reference_lua/fio.rst:1023
#: ../doc/reference/reference_lua/fio.rst:1044
#: ../doc/reference/reference_lua/fio.rst:1077
#: ../doc/reference/reference_lua/fio.rst:1099
#: ../doc/reference/reference_lua/http.rst:83
#: ../doc/reference/reference_lua/iconv.rst:57
#: ../doc/reference/reference_lua/iconv.rst:78
#: ../doc/reference/reference_lua/json.rst:56
#: ../doc/reference/reference_lua/json.rst:95
#: ../doc/reference/reference_lua/json.rst:126
#: ../doc/reference/reference_lua/key_def.rst:138
#: ../doc/reference/reference_lua/key_def.rst:164
#: ../doc/reference/reference_lua/key_def.rst:187
#: ../doc/reference/reference_lua/key_def.rst:212
#: ../doc/reference/reference_lua/net_box.rst:240
#: ../doc/reference/reference_lua/net_box.rst:256
#: ../doc/reference/reference_lua/net_box.rst:271
#: ../doc/reference/reference_lua/net_box.rst:312
#: ../doc/reference/reference_lua/net_box.rst:326
#: ../doc/reference/reference_lua/net_box.rst:348
#: ../doc/reference/reference_lua/net_box.rst:362
#: ../doc/reference/reference_lua/net_box.rst:376
#: ../doc/reference/reference_lua/net_box.rst:390
#: ../doc/reference/reference_lua/net_box.rst:488
#: ../doc/reference/reference_lua/net_box.rst:540
#: ../doc/reference/reference_lua/osmodule.rst:88
#: ../doc/reference/reference_lua/osmodule.rst:111
#: ../doc/reference/reference_lua/osmodule.rst:130
#: ../doc/reference/reference_lua/osmodule.rst:147
#: ../doc/reference/reference_lua/osmodule.rst:165
#: ../doc/reference/reference_lua/osmodule.rst:180
#: ../doc/reference/reference_lua/osmodule.rst:193
#: ../doc/reference/reference_lua/osmodule.rst:208
#: ../doc/reference/reference_lua/osmodule.rst:223
#: ../doc/reference/reference_lua/osmodule.rst:238
#: ../doc/reference/reference_lua/osmodule.rst:253
#: ../doc/reference/reference_lua/osmodule.rst:269
#: ../doc/reference/reference_lua/osmodule.rst:284
#: ../doc/reference/reference_lua/other.rst:52
#: ../doc/reference/reference_lua/other.rst:92
#: ../doc/reference/reference_lua/pickle.rst:91
#: ../doc/reference/reference_lua/pickle.rst:138
#: ../doc/reference/reference_lua/socket.rst:138
#: ../doc/reference/reference_lua/socket.rst:156
#: ../doc/reference/reference_lua/socket.rst:175
#: ../doc/reference/reference_lua/socket.rst:257
#: ../doc/reference/reference_lua/socket.rst:416
#: ../doc/reference/reference_lua/strict.rst:18
#: ../doc/reference/reference_lua/string.rst:78
#: ../doc/reference/reference_lua/string.rst:103
#: ../doc/reference/reference_lua/string.rst:126
#: ../doc/reference/reference_lua/string.rst:151
#: ../doc/reference/reference_lua/string.rst:181
#: ../doc/reference/reference_lua/string.rst:211
#: ../doc/reference/reference_lua/string.rst:237
#: ../doc/reference/reference_lua/string.rst:263
#: ../doc/reference/reference_lua/string.rst:293
#: ../doc/reference/reference_lua/string.rst:321
#: ../doc/reference/reference_lua/swim.rst:396
#: ../doc/reference/reference_lua/table.rst:44
#: ../doc/reference/reference_lua/tap.rst:180
#: ../doc/reference/reference_lua/tap.rst:226
#: ../doc/reference/reference_lua/tarantool.rst:20
#: ../doc/reference/reference_lua/uri.rst:65
#: ../doc/reference/reference_lua/uri.rst:92
#: ../doc/reference/reference_lua/utf8.rst:72
#: ../doc/reference/reference_lua/utf8.rst:101
#: ../doc/reference/reference_lua/utf8.rst:130
#: ../doc/reference/reference_lua/utf8.rst:154
#: ../doc/reference/reference_lua/utf8.rst:176
#: ../doc/reference/reference_lua/utf8.rst:198
#: ../doc/reference/reference_lua/utf8.rst:220
#: ../doc/reference/reference_lua/utf8.rst:252
#: ../doc/reference/reference_lua/utf8.rst:276
#: ../doc/reference/reference_lua/utf8.rst:297
#: ../doc/reference/reference_lua/utf8.rst:335
#: ../doc/reference/reference_lua/utf8.rst:357
#: ../doc/reference/reference_lua/xlog.rst:27
#: ../doc/reference/reference_rock/dbms.rst:188
#: ../doc/reference/reference_rock/dbms.rst:212
#: ../doc/reference/reference_rock/dbms.rst:236
#: ../doc/reference/reference_rock/dbms.rst:530
#: ../doc/reference/reference_rock/dbms.rst:554
#: ../doc/reference/reference_rock/dbms.rst:577
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:64
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:135
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:456
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:471
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:488
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:549
msgid "**Example:**"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:31
msgid "tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:45
msgid "informs the server that normal operations may resume."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:3
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:9
#: ../doc/reference/reference_lua/clock.rst:9
#: ../doc/reference/reference_lua/console.rst:9
#: ../doc/reference/reference_lua/crypto.rst:11
#: ../doc/reference/reference_lua/csv.rst:9
#: ../doc/reference/reference_lua/debug_facilities.rst:9
#: ../doc/reference/reference_lua/digest.rst:11
#: ../doc/reference/reference_lua/errno.rst:11
#: ../doc/reference/reference_lua/fiber.rst:9
#: ../doc/reference/reference_lua/fio.rst:11
#: ../doc/reference/reference_lua/http.rst:11
#: ../doc/reference/reference_lua/iconv.rst:11
#: ../doc/reference/reference_lua/json.rst:9
#: ../doc/reference/reference_lua/log.rst:11
#: ../doc/reference/reference_lua/merger.rst:9
#: ../doc/reference/reference_lua/msgpack.rst:9
#: ../doc/reference/reference_lua/net_box.rst:9
#: ../doc/reference/reference_lua/osmodule.rst:11
#: ../doc/reference/reference_lua/socket.rst:9
#: ../doc/reference/reference_lua/string.rst:9
#: ../doc/reference/reference_lua/swim.rst:9
#: ../doc/reference/reference_lua/tap.rst:7
#: ../doc/reference/reference_lua/uri.rst:7
#: ../doc/reference/reference_lua/utf8.rst:9
#: ../doc/reference/reference_lua/uuid.rst:7
#: ../doc/reference/reference_lua/yaml.rst:9
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:11
msgid "Overview"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:11
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:19
#: ../doc/reference/reference_lua/clock.rst:18
#: ../doc/reference/reference_lua/console.rst:17
#: ../doc/reference/reference_lua/crypto.rst:22
#: ../doc/reference/reference_lua/csv.rst:41
#: ../doc/reference/reference_lua/debug_facilities.rst:33
#: ../doc/reference/reference_lua/digest.rst:22
#: ../doc/reference/reference_lua/errno.rst:19
#: ../doc/reference/reference_lua/fiber.rst:22
#: ../doc/reference/reference_lua/fio.rst:27
#: ../doc/reference/reference_lua/http.rst:19
#: ../doc/reference/reference_lua/iconv.rst:24
#: ../doc/reference/reference_lua/json.rst:18
#: ../doc/reference/reference_lua/log.rst:46
#: ../doc/reference/reference_lua/merger.rst:16
#: ../doc/reference/reference_lua/msgpack.rst:18
#: ../doc/reference/reference_lua/net_box.rst:71
#: ../doc/reference/reference_lua/osmodule.rst:28
#: ../doc/reference/reference_lua/pickle.rst:7
#: ../doc/reference/reference_lua/socket.rst:28
#: ../doc/reference/reference_lua/string.rst:22
#: ../doc/reference/reference_lua/tap.rst:17
#: ../doc/reference/reference_lua/uri.rst:35
#: ../doc/reference/reference_lua/uuid.rst:17
#: ../doc/reference/reference_lua/yaml.rst:16
msgid "Index"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:21
msgid "Below is a list of all ``box.error`` functions."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Name"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Use"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid ":ref:`box.error() <box_error-error>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid "Throw an error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid "Get a description of the last error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid "Clear the record of errors"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid "Create an error but do not throw"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:46
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:49
msgid "description of an error, defined by user"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:50
msgid "numeric code for this error, defined by user"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:54
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:61
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:67
#: ../doc/reference/reference_lua/box_error.rst:157
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:68
#: ../doc/reference/reference_lua/box_error.rst:158
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:72
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:0
msgid "except"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:78
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:82
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:101
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:111
msgid "rtype: table"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:117
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:122
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:152
msgid "Create an error object, but do not throw. This is useful when error information should be saved for later retrieval. The parameters are the same as for :ref:`box.error() <box_error-error>`, see the description there."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:162
msgid "tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = ''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:5
msgid "Function `box.once`"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:9
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:14
msgid "See an example of using ``box.once()`` while :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:17
msgid "If an error occurs inside ``box.once()`` when initializing a database, you can re-execute the failed ``box.once()`` block without stopping the database. The solution is to delete the ``once`` object from the system space :ref:`_schema <box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` object there and delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:24
msgid "When ``box.once()`` is used for initialization, it may be useful to wait until the database is in an appropriate state (read-only or read-write). In that case, see the functions in the :ref:`box.ctl submodule <box_ctl>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:28
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:48
msgid "a value that will be checked"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:49
msgid "a function"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:50
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:5
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:9
msgid "Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` will not remove files which were created before the snapshot started, it will not remove them until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:23
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Users may restrict the speed by changing :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:31
msgid "As long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore you need to have some extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:39
msgid "**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and this view is written to the snapshot file by a separate thread (the \"Write Ahead Log\" thread)."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:45
msgid "Although ``box.snapshot()`` does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:51
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:66
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicated data is up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:72
msgid "An alternative way to save a snapshot is to send a SIGUSR1 signal to the instance. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:7
msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:10
msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time on the server, if the client application has its own routine for decoding MsgPack strings."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/merger.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/swim.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
msgid "return"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/xlog.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "rtype"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:21
#: ../doc/reference/reference_lua/uuid.rst:61
#: ../doc/reference/reference_lua/uuid.rst:83
#: ../doc/reference/reference_lua/uuid.rst:91
msgid "cdata"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:25
msgid "Assume a Tarantool server is listening on farhost:3301. Assume it has a space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then we create a buffer, and use it as an option for a ``conn.space...select()`` call. The result will be in MsgPack_ format. To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:38
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:50
#: ../doc/reference/reference_lua/buffer.rst:110
msgid "The result of the final request looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:52
#: ../doc/reference/reference_lua/buffer.rst:73
msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:62
msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:69
msgid "**Module buffer and skip-header**"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:71
msgid "The example in the previous section"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:81
msgid "showed that, ordinarily, the response from net.box includes a header -- 48 (hexadecimal 30) is the :ref:`key <internals-unified_packet_structure>` for IPROTO_DATA. But in some situations, for example when passing the buffer to a C function that expects a MsgPack byte array without a header, the header can be skipped. This is done by specifying ``skip-header=true`` as an option to :ref:`conn.space.space-name:select{...} <conn-select>` or :ref:`conn.space.space-name:insert{...} <conn-insert>` or :ref:`conn.space.space-name:replace{...} <conn-replace>` or :ref:`conn.space.space-name:update{...} <conn-update>` or :ref:`conn.space.space-name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-name:delete{...} <conn-delete>`. The default is ``skip-header=false``."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:96
msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:98
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:112
msgid "tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:120
msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:122
msgid "The result is still inside an array, as is clear from the fact that it is shown inside square brackets. It is possible to skip the array header too, with :ref:`msgpack.decode_array_header() <msgpack-decode_array_header>`."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:5
msgid "Module `clock`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:11
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:20
msgid "Below is a list of all ``clock`` functions."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:30
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:31
msgid "Get the wall clock time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:35
msgid ":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:36
msgid "Get the wall clock time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid "Get the monotonic time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid "Get the monotonic time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid "Get the processor time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid "Get the processor time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid "Get the thread time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid "Get the thread time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid "Measure the time a function takes within a processor"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:71
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:75
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:76
#: ../doc/reference/reference_lua/clock.rst:101
#: ../doc/reference/reference_lua/clock.rst:122
#: ../doc/reference/reference_lua/clock.rst:143
msgid "number or number64"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:80
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:86
msgid "See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:94
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:100
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:105
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:116
msgid "The processor time. Derived from C function ``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:121
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:126
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:137
msgid "The thread time. Derived from C function ``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:142
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:147
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:157
msgid "The time that a function takes within a processor. This function uses ``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:161
msgid "function or function reference"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:162
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:164
msgid "**table**. first element - seconds of CPU time, second element - whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:169
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:5
msgid "Module `console`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:11
msgid "The console module allows one Tarantool instance to access another Tarantool instance, and allows one Tarantool instance to start listening on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:19
msgid "Below is a list of all ``console`` functions."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid ":ref:`console.connect() <console-connect>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid "Connect to an instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid ":ref:`console.listen() <console-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid "Listen for incoming requests"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid ":ref:`console.start() <console-start>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid "Start the console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid ":ref:`console.ac() <console-ac>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid "Set the auto-completion flag"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid "Set a delimiter"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:44
msgid ":ref:`console.get_default_output() <console-get_default_output>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:44
msgid "Get default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:47
msgid ":ref:`console.set_default_output() <console-set_default_output>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:47
msgid "Set default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:58
msgid "Connect to the instance at :ref:`URI <index-uri>`, change the prompt from '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:62
msgid "The console.connect function allows one Tarantool instance, in interactive mode, to access another Tarantool instance. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote instance and the local instance is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote instance. Results are displayed on the local instance. To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:70
msgid "If the Tarantool instance at :samp:`uri` requires authentication, the connection might look something like: ``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:74
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote instance is done with user name = 'guest'. The remote instance could allow for this by granting at least one privilege: ``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:80
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:81
#: ../doc/reference/reference_lua/fiber.rst:483
#: ../doc/reference/reference_lua/fiber.rst:531
#: ../doc/reference/reference_lua/fiber.rst:632
#: ../doc/reference/reference_lua/fiber.rst:1062
#: ../doc/reference/reference_lua/fiber.rst:1070
#: ../doc/reference/reference_lua/log.rst:115
#: ../doc/reference/reference_lua/log.rst:140
#: ../doc/reference/reference_lua/msgpack.rst:281
#: ../doc/reference/reference_lua/tap.rst:130
#: ../doc/reference/reference_lua/tap.rst:164
#: ../doc/reference/reference_lua/tap.rst:224
msgid "nil"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:83
msgid "Possible errors: the connection will fail if the target Tarantool instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:88
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:102
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in ``box.cfg{listen=...}``. The alternative way of listening is via the URI specified in ``console.listen(...)``. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:109
msgid "the URI of the local instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:111
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:119
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:140
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:144
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the Tarantool instance with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:149
msgid "local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:158
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using Tarantool as a client or the user is using Tarantool via ``console.connect()``, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:167
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:169
msgid "The default end-of-request marker is a newline (line feed). Custom markers are not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an end keyword). Nonetheless for special needs, or for entering multi-line requests in older Tarantool versions, you can change the end-of-request marker. As a result, newline alone is not treated as end of request."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:177
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:179
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:183
msgid "tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:202
msgid "Return the current default output format. The result will be ``fmt=\"yaml\"``, or it will be ``fmt=\"lua\"`` if the last :ref:`set_default_output <console-set_default_output>` call was ``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:211
msgid "Set the default output format. The possible values are 'yaml' (the default default) or 'lua'. The output format can be changed within a session by executing :samp:`console.eval('\\\\\\\\set output {yaml}|{lua}')`; see the description of output format in the :ref:`Interactive console <interactive_console_output>` section."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:5
msgid "Module `crypto`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:13
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``crypto`` module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:24
msgid "Below is a list of all ``crypto`` functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid "Encrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid "Decrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid "Get a digest"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid ":ref:`crypto.hmac.{algorithm}() <crypto-hmac>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid "Get a hash key"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:53
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:56
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:57
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:58
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:59
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:62
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:64
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:65
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:66
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:67
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:69
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:73
msgid "_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:88
msgid "Pass or return a digest derived from the string. The eleven algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:91
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:92
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:93
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:94
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:95
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:96
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:97
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:98
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:99
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:100
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:101
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:105
msgid "crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:118
msgid "Pass a key and a string. The result is an `HMAC <https://en.wikipedia.org/wiki/HMAC>`_ message authentication code. The eight algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:123
msgid "md4 or md4_hex - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:124
msgid "md5 or md5_hex - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:125
msgid "ripemd160 or ripemd160_hex - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:126
msgid "sha1 or sha1_hex - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:127
msgid "sha224 or sha224_hex - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:128
msgid "sha256 or sha256_hex - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:129
msgid "sha384 or sha384_hex - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:130
msgid "sha512 or sha512_hex - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:134
msgid "crypto.hmac.md4('key', 'string')\n"
"crypto.hmac.md4_hex('key', 'string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:141
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:143
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:149
msgid "crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:175
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:177
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:180
msgid "crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:3
msgid "Module `csv`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:11
msgid "The ``csv`` module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:14
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:16
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:18
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:19
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:20
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:21
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:22
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:28
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:30
msgid ":samp:`delimiter = {string}` (default: comma) -- single-byte character to designate end-of-field"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:32
msgid ":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to designate encloser of string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:34
msgid ":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:36
msgid ":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at the start (usually for a header)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:43
msgid "Below is a list of all ``csv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid ":ref:`csv.load() <csv-load>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid "Load a CSV file"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid "Transform input into a CSV-formatted string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid "Iterate over CSV records"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:67
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:71
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:73
#: ../doc/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:75
#: ../doc/reference/reference_lua/fiber.rst:354
#: ../doc/reference/reference_lua/fio.rst:435
#: ../doc/reference/reference_lua/fio.rst:456
#: ../doc/reference/reference_lua/fio.rst:1042
#: ../doc/reference/reference_lua/http.rst:170
#: ../doc/reference/reference_lua/json.rst:93
#: ../doc/reference/reference_lua/key_def.rst:210
#: ../doc/reference/reference_lua/pickle.rst:136
#: ../doc/reference/reference_lua/socket.rst:173
#: ../doc/reference/reference_lua/socket.rst:561
#: ../doc/reference/reference_lua/socket.rst:573
#: ../doc/reference/reference_lua/string.rst:291
#: ../doc/reference/reference_lua/table.rst:42
#: ../doc/reference/reference_lua/utf8.rst:292
#: ../doc/reference/reference_lua/yaml.rst:58
#: ../doc/reference/reference_rock/membership.rst:181
#: ../doc/reference/reference_rock/membership.rst:190
#: ../doc/reference/reference_rock/membership.rst:203
msgid "table"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:79
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:82
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:94
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:97
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:106
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:114
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:118
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:145
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:151
#: ../doc/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:163
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:177
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:193
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:206
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:211
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:5
msgid "Debug facilities"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:11
msgid "Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:13
msgid "Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see details below) and"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:15
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:19
msgid "The ``debug`` library provides an interface for debugging Lua programs. All functions in this library reside in the ``debug`` table. Those functions that operate on a thread have an optional first parameter that specifies the thread to operate on. The default is always the current thread."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:26
msgid "This library should be used only for debugging and profiling and not as a regular programming tool, as the functions provided here can take too long to run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:35
msgid "Below is a list of all ``debug`` functions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid "Enter an interactive mode"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid "Get an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid "Get a thread's current hook settings"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid "Get information about a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid "Get a local variable's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid "Get an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid "Get the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid "Get an upvalue's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid "Set an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid "Set a given function as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid "Assign a value to a local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid "Set an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid "Assign a value to an upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid ":ref:`debug.sourcedir() <debug-sourcedir>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid "Get the source directory name"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:87
msgid ":ref:`debug.sourcefile() <debug-sourcefile>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:87
msgid "Get the source file name"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid "Get a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:99
msgid "Enters an interactive mode and runs each string that the user types in. The user can, among other things, inspect global and local variables, change their values and evaluate expressions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:103
msgid "Enter ``cont`` to exit this function, so that the caller can continue its execution."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:108
msgid "Commands for ``debug.debug()`` are not lexically nested within any function and so have no direct access to local variables."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:115
msgid "object to get the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:118
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:124
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:126
msgid "the current hook function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:127
msgid "the current hook mask"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:128
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:134
msgid "function to get information on"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:136
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:138
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:140
msgid "You can pass in a ``function`` directly, or you can give a number that specifies a function running at level ``function`` of the call stack of the given ``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is the function that called ``getinfo()``, and so on. If ``function`` is a number larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:147
msgid "The default for ``what`` is to get all information available, except the table of valid lines. If present, the option ``f`` adds a field named ``func`` with the function itself. If present, the option ``L`` adds a field named ``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:156
#: ../doc/reference/reference_lua/debug_facilities.rst:233
msgid "level of the stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:157
#: ../doc/reference/reference_lua/debug_facilities.rst:234
msgid "index of the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:159
msgid "the name and the value of the local variable with the index ``local`` of the function at level ``level`` of the stack or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:166
#: ../doc/reference/reference_lua/debug_facilities.rst:244
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:172
msgid "object to get the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:175
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:182
msgid "the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:188
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:189
#: ../doc/reference/reference_lua/debug_facilities.rst:264
msgid "index of the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:191
msgid "the name and the value of the upvalue with the index ``up`` of the function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:199
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:201
msgid "object to change the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:203
msgid "table to set the object environment to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:205
msgid "the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:211
msgid "Sets the given function as a hook.  When called without arguments, turns the hook off."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:214
msgid "function to set as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; may have the following values:  * ``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the ``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:218
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:219
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:220
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:222
msgid "describes when the ``hook`` will be called; when different from zero, the ``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:230
msgid "Assigns the value ``value`` to the local variable with the index ``local`` of the function at level ``level`` of the stack."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:235
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:238
msgid "the name of the local variable or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:250
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:252
msgid "object to change the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:254
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:260
msgid "Assigns the value ``value`` to the upvalue with the index ``up`` of the function ``func``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:263
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:265
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:268
msgid "the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:275
#: ../doc/reference/reference_lua/debug_facilities.rst:294
msgid "the level of the call stack which should contain the path (default is 2)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:278
msgid "a string with the relative path to the source file directory"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:280
msgid "Instead of ``debug.sourcedir()`` one can say ``debug.__dir__`` which means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:282
msgid "Determining the real path to a directory is only possible if the function was defined in a Lua file (this restriction may not apply for `loadstring() <https://www.lua.org/pil/8.html>`_ since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:287
msgid "If ``debug.sourcedir()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcedir())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:297
msgid "a string with the relative path to the source file"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:299
msgid "Instead of ``debug.sourcefile()`` one can say ``debug.__file__`` which means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:301
msgid "Determining the real path to a file is only possible if the function was defined in a Lua file (this restriction may not apply to ``loadstring()`` since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:306
msgid "If ``debug.sourcefile()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcefile())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:313
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:314
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:317
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:319
msgid "**Debug example:**"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:321
msgid "Make a file in the /tmp directory named example.lua, containing:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:323
msgid "function w()\n"
"  print(debug.sourcedir())\n"
"  print(debug.sourcefile())\n"
"  print(debug.traceback())\n"
"  print(debug.getinfo(1)['currentline'])\n"
"end\n"
"w()"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:333
msgid "Execute ``tarantool /tmp/example.lua``. Expect to see this:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:335
msgid "/tmp\n"
"/tmp/example.lua\n"
"stack traceback:\n"
"    /tmp/example.lua:4: in function 'w'\n"
"    /tmp/example.lua:7: in main chunk\n"
"5"
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:5
msgid "Module `decimal`"
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:9
msgid "The ``decimal`` module has functions for working with exact numbers. This is important when numbers are large or even the slighest inaccuracy is unacceptable. For example Lua calculates ``0.16666666666667 * 6`` with floating-point so the result is 1. But with the decimal module (using ``decimal.new`` to convert the number to decimal type) ``decimal.new('0.16666666666667') * 6`` is 1.00000000000002."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:18
msgid "To construct a decimal number, bring in the module with ``require('decimal')`` and then use ``decimal.new(n)`` or any function in the decimal module: :ref:`abs(n) <decimal-abs>` :ref:`exp(n) <decimal-exp>` :ref:`ln(n) <decimal-ln>` :ref:`log10(n) <decimal-log10>` :ref:`new(n) <decimal-new>` :ref:`precision(n) <decimal-precision>` :ref:`rescale(decimal-number, new-scale) <decimal-rescale>` :ref:`scale(n) <decimal-scale>` :ref:`sqrt(n) <decimal-sqrt>` :ref:`trim(decimal-number) <decimal-trim>`, where n can be a string or a non-decimal number or a decimal number. If it is a string or a non-decimal number, Tarantool converts it to a decimal number before working with it. It is best to construct from strings, and to convert back to strings after calculations, because Lua numbers have only 15 digits of precision. Decimal numbers have 38 digits of precision, that is, the total number of digits before and after the decimal point can be 38. Tarantool supports the usual arithmetic and comparison operators + - * / % ^ < > <= >= ~= ==. If an operation has both decimal and non-decimal operands, then the non-decimal operand is converted to decimal before the operation happens."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:46
msgid "Use ``tostring(decimal-number)`` to convert back to a string."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:48
msgid "A decimal operation will fail if overflow happens (when a number is greater than 10^38 - 1 or less than -10^38 - 1). A decimal operation will fail if arithmetic is impossible (such as division by zero or square root of minus 1). A decimal operation will not fail if rounding of post-decimal digits is necessary to get 38-digit precision."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:59
msgid "Returns absolute value of a decimal number. For example if a is -1 then ``decimal.abs(a)`` returns 1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:66
msgid "Returns *e* raised to the power of a decimal number. For example if a is 1 then ``decimal.exp(a)`` returns 2.7182818284590452353602874713526624978. Compare ``math.exp(1)`` from the `Lua math library <https://www.lua.org/pil/18.html>`_, which returns 2.718281828459."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:77
msgid "Returns natural logarithm of a decimal number. For example if a is 1 then ``decimal.ln(a)`` returns 0."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:84
msgid "Returns base-10 logarithm of a decimal number. For example if a is 100 then ``decimal.log10(a)`` returns 2."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:91
msgid "Returns the value of the input as a decimal number. For example if a is 1E-1 then ``decimal.new(a)`` returns 0.1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:99
msgid "Returns the number of digits in a decimal number. For example if a is 123.4560 then ``decimal.precision(a)`` returns 7."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:106
msgid "Returns the number after possible rounding or padding. If the number of post-decimal digits is greater than new-scale, then rounding occurs. The rounding rule is: round half away from zero. If the number of post-decimal digits is less than new-scale, then padding of zeros occurs. For example if a is -123.4550 then ``decimal.rescale(a, 2)`` returns -123.46, and ``decimal.rescale(a, 5)`` returns -123.45500."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:118
msgid "Returns the number of post-decimal digits in a decimal number. For example if a is 123.4560 then ``decimal.scale(a)`` returns 4."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:125
msgid "Returns the square root of a decimal number. For example if a is 2 then ``decimal.sqrt(a)`` returns 1.4142135623730950488016887242096980786."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:133
msgid "Returns a decimal number after possible removing of trailing post-decimal zeros. For example if a is 2.20200 then ``decimal.trim(a)`` returns 2.202."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:5
msgid "Module `digest`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:13
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``digest`` module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>`."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:24
msgid "Below is a list of all ``digest`` functions."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid "Encrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid "Decrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid "Get a digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid "Get a hexadecimal digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid "Get a digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid "Get a hexadecimal digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid "Get a digest made with PBKDF2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid "Get a digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid "Get a hexadecimal digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid "Get a 224-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid "Get a 256-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid "Get a 384-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid "Get a 512-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid "Encode a string to Base64"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid "Decode a Base64-encoded string"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid "Get an array of random bytes"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid "Get a 32-bit checksum made with CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid "Initiate incremental CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid "Get a number made with a consistent hash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid "Get a digest made with MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid "Initiate incremental MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:115
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:121
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:127
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:133
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:139
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:145
msgid "Returns binary string = digest made with PBKDF2. |br| For effective encryption the ``iterations`` value should be at least several thousand. The ``digest-length`` value determines the length of the resulting binary string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:152
msgid "``digest.pbkdf2()`` yields and should not be used in a transaction (between ``box.begin()`` and ``box.commit()``/``box.rollback()``). PBKDF2 is a time-consuming hash algorithm. It runs in a separate coio thread. While calculations are performed, the fiber that calls ``digest.pbkdf2()`` yields and another fiber continues working in the tx thread."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:162
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:168
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:174
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:180
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:186
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:192
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:198
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:204
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:210
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:216
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:222
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:224
msgid "The possible options are:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:226
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:227
msgid "``nowrap`` -- result must not include line feed for splitting lines after 72 characters,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:229
msgid "``urlsafe`` -- result must not include '=' or line feed, and may contain '-' or '_' instead of '+' or '/' for positions 62 and 63 in the index table."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:233
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:237
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:245
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:251
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:257
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:259
msgid "The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other settings are: input = reflected, output = reflected, initial value = 0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:266
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:268
msgid ">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:275
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:277
msgid "use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:284
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:290
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:297
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:299
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:304
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:315
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:321
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes. For example:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:325
msgid "murmur.new({seed=0})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:333
msgid "Incremental methods in the ``digest`` module"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:335
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:341
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:363
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:367
msgid "tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:393
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:396
msgid "tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:5
msgid "Database error codes"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:7
msgid "In the current version of the binary protocol, error messages, which are normally more descriptive than error codes, are not present in server responses. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below are general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:18
msgid "**List of error codes**"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been reached."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "The specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:68
msgid "Handling errors"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:70
msgid "Here are some procedures that can make Lua functions more robust when there are errors, particularly database errors."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:73
msgid "Invoke with pcall."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of simply invoking with"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "say"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-name}) ...`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "For some Tarantool box functions, pcall also returns error details including a file-name and line-number within Tarantool's source code. This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``y:unpack()``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:88
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:91
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:93
msgid "To make a new error and pass it on, the box.error module provides :ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:96
msgid "To find the last error, the box.error module provides :ref:`box.error.last() <box_error-last>`. (There is also a way to find the text of the last operating-system error for certain functions -- :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:101
msgid "Log."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:103
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:105
msgid "And filter messages that are automatically generated, with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:109
msgid "Generally, for Tarantool built-in functions which are designed to return objects: the result will be an object, or nil, or `a Lua error <https://www.lua.org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:113
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:127
msgid "After a function call that might fail, like fio.open() above, it is common to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check for common failures. But if there had been a syntax error, for example fio.opex instead of fio.open, then there would have been a Lua error and f would not have been changed. If checking for such an obvious error had been a concern, the programmer would probably have used pcall()."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:137
msgid "All functions in Tarantool modules should work this way, unless the manual explicitly says otherwise."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:5
msgid "Module `errno`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:13
msgid "The ``errno`` module is typically used within a function or within a Lua program, in association with a module whose functions can return operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:21
msgid "Below is a list of all ``errno`` functions."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid ":ref:`errno() <errno-errno>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid "Get an error number for the last OS-related function"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid "Get an error message for the corresponding error number"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:42
msgid "Return an error number for the last operating-system-related function, or 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:45
#: ../doc/reference/reference_sql/sql.rst:244
msgid "integer"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:51
msgid "Return a string, given an error number. The string will contain the text of the conventional error message for the current operating system. If ``code`` is not supplied, the error message will be for the last operating-system-related function, or 0."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:56
msgid "number of an operating-system error"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:58
#: ../doc/reference/reference_lua/fiber.rst:335
#: ../doc/reference/reference_lua/fiber.rst:454
#: ../doc/reference/reference_lua/fiber.rst:504
#: ../doc/reference/reference_lua/fio.rst:182
#: ../doc/reference/reference_lua/fio.rst:204
#: ../doc/reference/reference_lua/fio.rst:224
#: ../doc/reference/reference_lua/fio.rst:243
#: ../doc/reference/reference_lua/json.rst:54
#: ../doc/reference/reference_lua/msgpack.rst:62
#: ../doc/reference/reference_lua/pickle.rst:83
#: ../doc/reference/reference_lua/socket.rst:294
#: ../doc/reference/reference_lua/socket.rst:328
#: ../doc/reference/reference_lua/socket.rst:344
#: ../doc/reference/reference_lua/string.rst:76
#: ../doc/reference/reference_lua/string.rst:101
#: ../doc/reference/reference_lua/string.rst:124
#: ../doc/reference/reference_lua/string.rst:149
#: ../doc/reference/reference_lua/string.rst:235
#: ../doc/reference/reference_lua/string.rst:261
#: ../doc/reference/reference_lua/string.rst:319
#: ../doc/reference/reference_lua/uri.rst:90
#: ../doc/reference/reference_lua/utf8.rst:88
#: ../doc/reference/reference_lua/utf8.rst:274
#: ../doc/reference/reference_lua/utf8.rst:326
#: ../doc/reference/reference_lua/utf8.rst:350
#: ../doc/reference/reference_lua/yaml.rst:48
#: ../doc/reference/reference_rock/membership.rst:314
#: ../doc/reference/reference_sql/sql.rst:250
msgid "string"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:62
msgid "This function displays the result of a call to :ref:`fio.open() <fio-open>` which causes error 2 (``errno.ENOENT``). The display includes the error number, the associated error string, and the error name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:66
msgid "tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:91
msgid "To see all possible error names stored in the ``errno`` metatable, say ``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:94
msgid "tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:14
msgid "send and receive messages between different processes (i.e. different connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:16
msgid "use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar to \"condition variables\" and similar to operating-system functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid "Create but do not start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid "Yield control"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid "Get information about all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
#: ../doc/reference/reference_lua/fiber.rst:76
msgid "Cancel a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid "Get a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid "Set a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid "Get a fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:76
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid "Make it possible for a new fiber to join"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid "Wait for a fiber's state to become 'dead'"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid "Create a communication channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid "Send a message via a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid "Close a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid "Count messages in a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid "Check if a channel is full"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid "Create a condition variable"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid "Wake up all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:142
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:575
msgid "Fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:144
msgid "A **fiber** is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:148
msgid "A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber is created with :ref:`fiber.new() <fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:154
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:158
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:169
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:176
msgid "Like all Lua objects, dead fibers are garbage collected. The Lua garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:181
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:193
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:195
#: ../doc/reference/reference_lua/fiber.rst:234
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:196
#: ../doc/reference/reference_lua/fiber.rst:235
msgid "what will be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
msgid "Return"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:198
#: ../doc/reference/reference_lua/fiber.rst:237
msgid "created fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:0
msgid "Rtype"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:199
#: ../doc/reference/reference_lua/fiber.rst:238
#: ../doc/reference/reference_lua/fiber.rst:261
#: ../doc/reference/reference_lua/fiber.rst:281
#: ../doc/reference/reference_lua/fio.rst:786
#: ../doc/reference/reference_lua/http.rst:81
#: ../doc/reference/reference_lua/iconv.rst:53
#: ../doc/reference/reference_lua/net_box.rst:218
#: ../doc/reference/reference_lua/socket.rst:136
#: ../doc/reference/reference_lua/socket.rst:154
#: ../doc/reference/reference_lua/socket.rst:385
#: ../doc/reference/reference_lua/tap.rst:99
msgid "userdata"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:203
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:221
msgid "Create but do not start a fiber: the fiber is created but does not begin to run immediately -- it starts after the fiber creator (that is, the job that is calling ``fiber.new()``) yields, under :ref:`transaction control <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:229
msgid "Ordinarily ``fiber.new()`` is used in conjunction with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:242
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:260
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:265
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:278
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:280
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:285
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:298
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:301
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:305
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:315
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does not."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:320
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:330
msgid "Return the status of the current fiber. Or, if optional fiber_object is passed, return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:334
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:339
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:350
msgid "Return information about all fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:352
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:358
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:376
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:380
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
msgid "Exception"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:381
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:385
msgid "tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:397
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:402
msgid "Even if you catch the exception, the fiber will remain cancelled. Most types of calls will check ``fiber.testcancel()``. However, some functions (``id``, ``status``, ``join`` etc.) will return no error. We recommend application developers to implement occasional checks with :ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:411
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:424
#: ../doc/reference/reference_lua/fiber.rst:449
#: ../doc/reference/reference_lua/fiber.rst:477
#: ../doc/reference/reference_lua/fiber.rst:499
#: ../doc/reference/reference_lua/fiber.rst:527
msgid "generally this is an object referenced in the return from :ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or :ref:`fiber.find <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:428
msgid "id of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:429
#: ../doc/reference/reference_lua/fiber.rst:902
#: ../doc/reference/reference_lua/fio.rst:319
#: ../doc/reference/reference_lua/fio.rst:1019
#: ../doc/reference/reference_lua/socket.rst:274
#: ../doc/reference/reference_lua/socket.rst:400
#: ../doc/reference/reference_lua/utf8.rst:55
#: ../doc/reference/reference_lua/utf8.rst:116
#: ../doc/reference/reference_lua/utf8.rst:239
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:486
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:501
#: ../doc/reference/reference_sql/sql.rst:248
msgid "number"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:431
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:435
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:453
msgid "name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:456
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:460
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:471
msgid "Change the fiber name. By default a Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:481
msgid "the new name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:487
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:497
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:503
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:506
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:510
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:521
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause ``error: the fiber is dead``. But a dead fiber can still report its id and status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:533
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:537
msgid "tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:559
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The Lua garbage collector will mark or free the local storage when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:568
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:594
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:600
msgid "``fiber_object:set_joinable(true)`` makes a fiber joinable; ``fiber_object:set_joinable(false)`` makes a fiber not joinable; the default is false."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:604
msgid "A joinable fiber can be waited for, with :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:607
msgid "Best practice is to call ``fiber_object:set_joinable()`` before the fiber function begins to execute, because otherwise the fiber could become 'dead' before ``fiber_object:set_joinable()`` takes effect. The usual sequence could be:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:612
msgid "Call ``fiber.new()`` instead of ``fiber.create()`` to create a new fiber_object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:615
msgid "Do not yield at this point, because that will cause the fiber function to begin."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:618
msgid "Call ``fiber_object:set_joinable(true)`` to make the new fiber_object joinable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:621
msgid "Now it is safe to yield."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:623
msgid "Call ``fiber_object:join()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:625
msgid "Usually ``fiber_object:join()`` should be called, otherwise the fiber's status may become 'suspended' when the fiber function ends, instead of 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:629
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:636
#: ../doc/reference/reference_lua/fiber.rst:686
msgid "The result of the following sequence of requests is:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:638
msgid "the global variable ``d`` will be 6 (which proves that the function was not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` caused a yield);"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:641
msgid "``fiber.status(fi2)`` will be 'suspended' (which proves that after the function was executed the fiber status did not change to 'dead')."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:644
msgid "fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:657
msgid "\"Join\" a joinable fiber. That is, let the fiber's function run and wait until the fiber's status is 'dead' (normally a status becomes 'dead' when the function execution finishes). Joining will cause a yield, therefore, if the fiber is currently in a suspended state, execution of its fiber function will resume."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:665
msgid "This kind of waiting is more convenient than going into a loop and periodically checking the status; however, it works only if the fiber was created with :ref:`fiber.new() <fiber-new>` and was made joinable with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:672
msgid "two values. The first value is boolean. If the first value is true, then the join succeeded because the fiber's function ended normally and the second result has the return value from the fiber's function. If the first value is false, then the join succeeded because the fiber's function ended abnormally and the second result has the details about the error, which one can unpack in the same way that one unpacks :ref:`a pcall result <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:682
msgid "boolean +result type, or boolean + struct error"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:688
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:689
msgid "the ``join()`` call returns true,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:690
msgid "the elapsed time is usually 5 seconds, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:691
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:693
msgid "This proves that the ``join()`` does not return until the function -- which sleeps 5 seconds -- is 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:696
msgid "fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:711
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:715
#: ../doc/reference/reference_lua/fiber.rst:734
msgid "num"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:719
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:731
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:738
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:750
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop. Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:755
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:768
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:771
msgid "tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:779
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:781
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:787
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:792
msgid "tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:799
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:804
msgid "tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:820
msgid "Channels"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:822
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:825
msgid "Call the other routines, via channel, to send messages, receive messages, or check channel status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:828
msgid "Message exchange is synchronous. The Lua garbage collector will mark or free the channel when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:837
msgid "Create a new communication channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:839
msgid "the maximum number of slots (spaces for ``channel:put`` messages) that can be in use at once. The default is 0."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:843
msgid "new channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:844
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:852
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` waits until there is a free slot in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:855
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:856
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:857
msgid "If timeout is specified, and there is no free slot in the channel for the duration of the timeout, then the return value is ``false``. If the channel is closed, then the return value is ``false``. Otherwise, the return value is ``true``, indicating success."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:861
#: ../doc/reference/reference_lua/fiber.rst:893
#: ../doc/reference/reference_lua/fiber.rst:913
#: ../doc/reference/reference_lua/fiber.rst:923
#: ../doc/reference/reference_lua/fiber.rst:933
#: ../doc/reference/reference_lua/fiber.rst:941
#: ../doc/reference/reference_lua/fiber.rst:1053
#: ../doc/reference/reference_lua/fio.rst:270
#: ../doc/reference/reference_lua/fio.rst:278
#: ../doc/reference/reference_lua/fio.rst:286
#: ../doc/reference/reference_lua/fio.rst:294
#: ../doc/reference/reference_lua/fio.rst:302
#: ../doc/reference/reference_lua/fio.rst:394
#: ../doc/reference/reference_lua/fio.rst:414
#: ../doc/reference/reference_lua/fio.rst:514
#: ../doc/reference/reference_lua/fio.rst:536
#: ../doc/reference/reference_lua/fio.rst:559
#: ../doc/reference/reference_lua/fio.rst:611
#: ../doc/reference/reference_lua/fio.rst:635
#: ../doc/reference/reference_lua/fio.rst:658
#: ../doc/reference/reference_lua/fio.rst:706
#: ../doc/reference/reference_lua/fio.rst:724
#: ../doc/reference/reference_lua/fio.rst:825
#: ../doc/reference/reference_lua/fio.rst:884
#: ../doc/reference/reference_lua/fio.rst:969
#: ../doc/reference/reference_lua/fio.rst:996
#: ../doc/reference/reference_lua/net_box.rst:238
#: ../doc/reference/reference_lua/net_box.rst:254
#: ../doc/reference/reference_lua/net_box.rst:269
#: ../doc/reference/reference_lua/net_box.rst:286
#: ../doc/reference/reference_lua/socket.rst:255
#: ../doc/reference/reference_lua/socket.rst:361
#: ../doc/reference/reference_lua/socket.rst:437
#: ../doc/reference/reference_lua/socket.rst:449
#: ../doc/reference/reference_lua/string.rst:176
#: ../doc/reference/reference_lua/string.rst:206
#: ../doc/reference/reference_lua/tap.rst:155
#: ../doc/reference/reference_lua/tap.rst:178
#: ../doc/reference/reference_lua/tap.rst:212
#: ../doc/reference/reference_lua/tap.rst:247
#: ../doc/reference/reference_lua/tap.rst:260
#: ../doc/reference/reference_lua/tap.rst:270
#: ../doc/reference/reference_lua/tap.rst:285
#: ../doc/reference/reference_lua/tap.rst:306
#: ../doc/reference/reference_lua/tap.rst:325
#: ../doc/reference/reference_lua/utf8.rst:147
#: ../doc/reference/reference_lua/utf8.rst:172
#: ../doc/reference/reference_lua/utf8.rst:194
#: ../doc/reference/reference_lua/utf8.rst:216
#: ../doc/reference/reference_rock/membership.rst:172
#: ../doc/reference/reference_rock/membership.rst:232
#: ../doc/reference/reference_rock/membership.rst:244
#: ../doc/reference/reference_rock/membership.rst:255
#: ../doc/reference/reference_rock/membership.rst:268
#: ../doc/reference/reference_rock/membership.rst:278
#: ../doc/reference/reference_rock/membership.rst:285
#: ../doc/reference/reference_sql/sql.rst:242
msgid "boolean"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:867
msgid "Close the channel. All waiters in the channel will stop waiting. All following ``channel:get()`` operations will return ``nil``, and all following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:875
msgid "Fetch and remove a message from a channel. If the channel is empty, ``channel:get()`` waits for a message."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:878
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:879
msgid "If timeout is specified, and there is no message in the channel for the duration of the timeout, then the return value is ``nil``. If the channel is closed, then the return value is ``nil``. Otherwise, the return value is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:884
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:890
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:892
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:899
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:901
msgid "the number of messages."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:908
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:910
msgid "``true`` if the channel is full (the number of messages in the channel equals the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:919
msgid "Check whether readers are waiting for a message because they have issued ``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:922
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:929
msgid "Check whether writers are waiting because they have issued ``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:932
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:939
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:947
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:951
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1017
msgid "Condition variables"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1019
msgid "Call ``fiber.cond()`` to create a named condition variable, which will be called 'cond' for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1022
msgid "Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1024
msgid "Call ``cond:signal()`` to send a signal to wake up a single fiber that has executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1027
msgid "Call ``cond:broadcast()`` to send a signal to all fibers that have executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1034
msgid "Create a new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1036
msgid "new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1037
msgid "Lua object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1045
msgid "Make the current fiber go to sleep, waiting until another fiber invokes the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1049
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1050
msgid "If timeout is provided, and a signal doesn't happen for the duration of the timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1059
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1068
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1076
msgid "Assume that a tarantool instance is running and listening for connections on localhost port 3301. Assume that guest users have privileges to connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1080
msgid "On terminal #1, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1082
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1089
msgid "The job will hang because ``cond:wait()`` -- without an optional timeout argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1092
msgid "On terminal #2, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1094
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1099
msgid "Now look again at terminal #1. It will show that the waiting stopped, and the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1102
msgid "This example depended on the use of a global conditional variable with the arbitrary name ``cond``. In real life, programmers would make sure to use different conditional variable names for different applications."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:5
msgid "Module `fio`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:13
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:17
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:19
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:20
msgid "functions for :ref:`directory or file existence and type checks<fio-checks>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:21
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:22
msgid ":ref:`constants <fio-c>` which are the same as POSIX flag values (for example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:29
msgid "Below is a list of all ``fio`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid "Form a path name from one or more partial strings"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid "Get a file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid "Get a directory name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid "Get a directory and file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
#: ../doc/reference/reference_lua/fio.rst:65
msgid "Check if file or directory exists"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid "Check if file or directory is a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid "Check if file or directory is a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid "Check if file or directory is a link"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:65
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid "Set mask bits"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:71
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:72
msgid "Get information about a file object"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:76
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:77
msgid "Create or delete a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid "Change working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid "List files in a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid "Get files whose names match a given string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid "Get the name of a directory for storing temporary files"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid "Get the name of the current working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:96
msgid ":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:99
msgid "Create and delete directories"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:103
msgid ":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| :ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:106
msgid "Create and delete links"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
#: ../doc/reference/reference_lua/osmodule.rst:43
msgid "Rename a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid ":ref:`fio.utime() <fio-utime>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid "Change file update time"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid "Copy a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:122
msgid "Manage rights to and ownership of file objects"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid "Reduce the file size"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid "Ensure that changes are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid ":ref:`fio.open() <fio-open>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid "Open a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:135
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:135
msgid "Close a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:138
msgid ":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-handle:pwrite() <file_handle-pwrite>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:139
msgid "Perform random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:143
msgid ":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-handle:write() <file_handle-write>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:144
msgid "Perform non-random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid "Change the size of an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid "Change position in a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:154
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:154
msgid "Get statistics about an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:157
msgid ":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-handle:fdatasync() <file_handle-fsync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:158
msgid "Ensure that changes made to an open file are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:162
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:162
msgid "Table of constants similar to POSIX flag values"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:172
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:178
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:180
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:181
#: ../doc/reference/reference_lua/fio.rst:200
#: ../doc/reference/reference_lua/fio.rst:221
msgid "path name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:186
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:197
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:201
msgid "suffix"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:203
#: ../doc/reference/reference_lua/fio.rst:240
msgid "file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:208
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:219
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:223
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:228
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:238
msgid "Given a final part (the file name), return the full path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:242
msgid "directory name, that is, path name including file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:247
msgid "tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:258
msgid "Directory or file existence and type checks"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:260
msgid "Functions in this section are similar to some `Python os.path <https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:268
#: ../doc/reference/reference_lua/fio.rst:276
#: ../doc/reference/reference_lua/fio.rst:284
#: ../doc/reference/reference_lua/fio.rst:292
#: ../doc/reference/reference_lua/fio.rst:300
msgid "path to directory or file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:269
msgid "true if path-name refers to a directory or file that exists and is not a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:277
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:285
msgid "true if path-name refers to a file; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:293
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:301
msgid "true if path-name refers to a directory or file that exists or is a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:308
msgid "Common file manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:314
msgid "Set the mask bits used when creating files or directories. For a detailed description type ``man 2 umask``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:317
msgid "mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:318
msgid "previous mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:323
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:335
msgid "Returns information about a file object. For details type ``man 2 lstat`` or ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:338
msgid "path name of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:339
msgid "(If no error) table of fields which describe the file's block size, creation time, size, and other attributes. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:342
msgid "table."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:344
msgid "Additionally, the result of ``fio.stat('file-name')`` will include methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:347
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:348
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:349
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:350
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:351
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:352
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:353
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:355
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:359
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:385
msgid "Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2 rmdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:388
#: ../doc/reference/reference_lua/fio.rst:412
#: ../doc/reference/reference_lua/fio.rst:432
msgid "path of directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:389
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:392
#: ../doc/reference/reference_lua/fio.rst:512
#: ../doc/reference/reference_lua/fio.rst:534
#: ../doc/reference/reference_lua/fio.rst:609
#: ../doc/reference/reference_lua/fio.rst:633
#: ../doc/reference/reference_lua/fio.rst:656
#: ../doc/reference/reference_lua/fio.rst:704
msgid "(If no error) true. |br| (If error) two return values: false, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:398
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:409
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:413
msgid "(If success) true. (If failure) false."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:418
msgid "tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:429
msgid "List files in directory. The result is similar to the result from the ``ls`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:433
msgid "(If no error) a list of files. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:439
msgid "tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:450
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:454
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:455
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:458
#: ../doc/reference/reference_lua/fio.rst:788
#: ../doc/reference/reference_lua/fio.rst:1021
msgid "**Possible errors:** nil."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:462
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:475
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:479
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:490
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:494
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:505
msgid "Copy everything in the from-path, including subdirectory contents, to the to-path. The result is similar to the result that one gets from the ``cp -r`` command. The to-path should be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:510
#: ../doc/reference/reference_lua/fio.rst:511
#: ../doc/reference/reference_lua/fio.rst:533
#: ../doc/reference/reference_lua/fio.rst:556
msgid "path-name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:518
msgid "tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:529
msgid "Create the path, including subdirectories, but without file contents. The result is similar to the result that one gets from the ``mkdir`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:540
msgid "tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:551
msgid "Remove the directory indicated by path-name, including subdirectories. The result is similar to the result that one gets from the ``rmdir`` command, recursively. The directory must be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:557
msgid "(If no error) true. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:563
msgid "tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:577
msgid "Functions to create and delete links. For details type ``man readlink``, ``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:580
msgid "existing file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:581
msgid "linked name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:583
msgid "(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true, ``fio.readlink`` returns the link value. |br| (If error) two return values: false|null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:589
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:604
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:606
msgid "original name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:607
msgid "new name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:615
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:626
msgid "Change the access time and possibly also change the update time of a file. For details type ``man 2 utime``. Times should be expressed as number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:629
msgid "name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:630
msgid "time of last access. default current time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:631
msgid "time of last update. default = access time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:639
msgid "tarantool> fio.utime('/home/username/tmp.txt')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:650
msgid "Copy a file. The effect is similar to the effect that one gets with the ``cp`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:653
msgid "path to original file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:654
msgid "path to new file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:662
msgid "tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:674
msgid "Manage the rights to file objects, or ownership of file objects. For details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:677
msgid "new user uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:678
msgid "new group uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:679
msgid "new permissions"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:680
msgid "null"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:684
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:699
msgid "Reduce file size to a specified value. For details type ``man 2 truncate``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:710
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:721
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:723
#: ../doc/reference/reference_lua/fio.rst:824
#: ../doc/reference/reference_lua/fio.rst:883
#: ../doc/reference/reference_lua/fio.rst:968
#: ../doc/reference/reference_lua/fio.rst:995
#: ../doc/reference/reference_lua/fio.rst:1075
msgid "true if success, false if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:728
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:743
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:745
msgid "Full path to the file to open."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:746
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT (create file if it doesn't exist), * O_DIRECT (do less caching or no caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * O_PATH (get a path for low-level use), * O_SYNC (force writing if it's possible), * O_TMPFILE (the file will be temporary and nameless), * O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:746
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:755
msgid "O_APPEND (start at end of file),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:756
msgid "O_ASYNC (signal when IO is possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:757
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:758
msgid "O_CREAT (create file if it doesn't exist),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:759
msgid "O_DIRECT (do less caching or no caching),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:760
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:761
msgid "O_EXCL (fail if file cannot be created),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:762
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:763
msgid "O_NOATIME (no access-time updating),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:764
msgid "O_NOCTTY (no console tty),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:765
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:766
msgid "O_NONBLOCK (no blocking),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:767
msgid "O_PATH (get a path for low-level use),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:768
msgid "O_SYNC (force writing if it's possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:769
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:770
msgid "O_TRUNC (truncate)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:772
msgid "... and, always, one of:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:774
msgid "O_RDONLY (read only),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:775
msgid "O_WRONLY (write only), or"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:776
msgid "O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:778
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or ``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:783
msgid "(If no error) file handle (abbreviated as 'fh' in later description). |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:790
#: ../doc/reference/reference_lua/http.rst:218
msgid "**Example 1:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:792
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:802
#: ../doc/reference/reference_lua/http.rst:247
msgid "**Example 2:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:804
msgid "Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an octal number:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:807
msgid "tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:820
msgid "Close a file that was opened with ``fio.open``. For details type ``man 2 close``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:823
#: ../doc/reference/reference_lua/fio.rst:845
#: ../doc/reference/reference_lua/fio.rst:878
#: ../doc/reference/reference_lua/fio.rst:919
#: ../doc/reference/reference_lua/fio.rst:964
#: ../doc/reference/reference_lua/fio.rst:994
#: ../doc/reference/reference_lua/fio.rst:1014
#: ../doc/reference/reference_lua/fio.rst:1040
#: ../doc/reference/reference_lua/fio.rst:1074
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:829
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:841
msgid "Perform random-access read operation on a file, without affecting the current seek position of the file. For details type ``man 2 pread``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:846
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:848
#: ../doc/reference/reference_lua/fio.rst:922
msgid "number of bytes to read"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:849
msgid "offset within file where reading begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:851
msgid "If the format is ``pread(count, offset)`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:854
msgid "If the format is ``pread(buffer, count, offset)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:860
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:874
msgid "Perform random-access write operation on a file, without affecting the current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:879
#: ../doc/reference/reference_lua/fio.rst:965
msgid "value to write"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:880
msgid "number of bytes to write (if the format is ``pwrite(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:882
msgid "offset within file where writing begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:886
msgid "If the format is ``pwrite(new-string, offset)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:889
msgid "If the format is ``pwrite(buffer, count, offset)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:893
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:909
msgid "Perform non-random-access read on a file. For details type ``man 2 read`` or ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:914
#: ../doc/reference/reference_lua/fio.rst:959
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:920
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:924
msgid "If the format is ``read()`` -- omitting ``count`` -- then read all bytes in the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:927
msgid "If the format is ``read()``  or ``read([count])`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:930
msgid "If the format is ``read(buffer, count)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:934
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:954
msgid "Perform non-random-access write on a file. For details type ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:966
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:971
msgid "If the format is ``write(new-string)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:974
msgid "If the format is ``write(buffer, count)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:980
msgid "tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:991
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1000
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1011
msgid "Shift position in the file to the specified position. For details type ``man 2 seek``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1015
msgid "position to seek to"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1016
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1018
msgid "the new position if success"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1025
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1036
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1041
msgid "details about the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1046
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1070
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type ``man 2 fsync`` or ``man 2 fdatasync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1079
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1090
msgid "FIO constants"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1096
msgid "Table with constants which are the same as POSIX flag values on the target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1101
msgid "tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:5
msgid "Module `fun`"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:7
msgid "Luafun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:17
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual ``require`` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:23
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:5
msgid "Module `http`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:13
msgid "The ``http`` module, specifically the ``http.client`` submodule, provides the functionality of an HTTP client with support for HTTPS and keepalive. It uses routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:21
msgid "Below is a list of all ``http`` functions."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid ":ref:`http.client.new() <http-new>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid "Create an HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid "Perform an HTTP request"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid "Get a table with statistics"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:47
msgid "integer settings which are passed to libcurl."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:49
msgid "The two possible options are ``max_connections`` and ``max_total_connections``."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:51
msgid "``max_connections`` is the maximum number of entries in the cache. It affects libcurl `CURLMOPT_MAXCONNECTS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_. The default is -1."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:55
msgid "``max_total_connections`` is the maximum number of active connections. It affects libcurl  `CURLMOPT_MAX_TOTAL_CONNECTIONS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_. It is ignored if the curl version is less than 7.30. The default is 0, which allows libcurl to scale accordingly to easy handle the count."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:60
msgid "The default option values are usually good enough but in rare cases it might be good to set them. In that case here are two tips."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:63
msgid "You may want to control the maximum number of sockets that a particular HTTP client uses simultaneously. If a system passes many requests to distinct hosts, then libcurl cannot reuse sockets. In this case setting ``max_total_connections`` may be useful, since it causes curl to avoid creating too many sockets which would not be used anyway."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:68
msgid "Do not set ``max_connections`` less than ``max_total_connections`` unless you are confident about your actions. When ``max_connections`` is less then ``max_total_connections``, in some cases libcurl will not reuse sockets for requests that are going to the same host. If the limit is reached and a new request occurs, then libcurl will first create a new socket, send the request, wait for the first connection to be free, and close it, in order to avoid exceeding the ``max_connections`` cache size. In the worst case, libcurl will create a new socket for every request, even if all requests are going to the same host. See `this Tarantool issue on github <https://github.com/tarantool/tarantool/issues/3945>`_ for details."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:80
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:85
msgid "tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:97
msgid "If ``http_client`` is an HTTP client instance, ``http_client:request()`` will perform an HTTP request and, if there is a successful connection, will return a table with connection information."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:101
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:102
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:103
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:   * ``timeout`` - number of seconds to wait for a curl API read request    before timing out  * ``ca_path`` - path to a directory holding one or more certificates to    verify the peer with  * ``ca_file`` - path to an SSL certificate file to verify the peer with  * ``verify_host`` - set on/off verification of the certificate's name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off verification of the peer's SSL    certificate. See also    `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the operating system    will wait while the connection is idle before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the note below about keepalive_interval.  * ``keepalive_interval`` - the interval, in seconds, that the operating    system will wait between sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both keepalive_idle and keepalive_interval are set, then    Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send Connection:close  * ``low_speed_time`` - set the \"low speed time\" -- the time that the    transfer speed should be below the \"low speed limit\" for the library    to consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    transfer speed in bytes per second that the transfer should be below    during \"low speed time\" seconds for the library to consider it to be    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``verbose`` - set on/off verbose mode  * ``unix_socket`` - a socket name to use instead of an Internet address,    for a local connection. The Tarantool server must be built with    ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>`    later in this section.  * ``max_header_name_len`` - the maximal length of a header name. If a header    name is bigger than this value, it is truncated to this length.    The default value is '32'.  * ``follow_location`` - when the option is set to ``true`` (default)    and the response has a 3xx code, the HTTP client will automatically issue    another request to a location that a server sends in the ``Location``    header. If the new response is 3xx again, the HTTP client will    issue still another request and so on in a loop until a non-3xx response    will be received. This last response will be returned as a result.    Setting this option to ``false`` allows to disable this behavior.    In this case, the HTTP client will return a 3xx response itself."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:107
msgid "``timeout`` - number of seconds to wait for a curl API read request before timing out"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:109
msgid "``ca_path`` - path to a directory holding one or more certificates to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:111
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:112
msgid "``verify_host`` - set on/off verification of the certificate's name (CN) against host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:115
msgid "``verify_peer`` - set on/off verification of the peer's SSL certificate. See also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:118
msgid "``ssl_key`` - path to a private key file for a TLS and SSL client certificate. See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:121
msgid "``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:123
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:124
msgid "``keepalive_idle`` - delay, in seconds, that the operating system will wait while the connection is idle before sending keepalive probes. See also `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note below about keepalive_interval."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:129
msgid "``keepalive_interval`` - the interval, in seconds, that the operating system will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both keepalive_idle and keepalive_interval are set, then Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive and Keep-Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send Connection:close"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:136
msgid "``low_speed_time`` - set the \"low speed time\" -- the time that the transfer speed should be below the \"low speed limit\" for the library to consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:140
msgid "``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed in bytes per second that the transfer should be below during \"low speed time\" seconds for the library to consider it to be too slow and abort. See also `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:145
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:146
msgid "``unix_socket`` - a socket name to use instead of an Internet address, for a local connection. The Tarantool server must be built with ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` later in this section."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:150
msgid "``max_header_name_len`` - the maximal length of a header name. If a header name is bigger than this value, it is truncated to this length. The default value is '32'."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:153
msgid "``follow_location`` - when the option is set to ``true`` (default) and the response has a 3xx code, the HTTP client will automatically issue another request to a location that a server sends in the ``Location`` header. If the new response is 3xx again, the HTTP client will issue still another request and so on in a loop until a non-3xx response will be received. This last response will be returned as a result. Setting this option to ``false`` allows to disable this behavior. In this case, the HTTP client will return a 3xx response itself."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:162
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:164
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:165
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:166
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:167
msgid "``body`` - response body"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:168
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:172
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:174
msgid "``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:176
msgid "``http_client:post (url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:178
msgid "``http_client:put(url, body, options)`` - shortcut for ``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:180
msgid "``http_client:patch(url, body, options)`` - shortcut for ``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:182
msgid "``http_client:options(url, options)`` - shortcut for ``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:184
msgid "``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:186
msgid "``http_client:delete(url, options)`` - shortcut for ``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:188
msgid "``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:190
msgid "``http_client:connect:(url, options)`` - shortcut for ``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:193
msgid "Requests may be influenced by environment variables, for example users can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before initiating any requests. See the web page document `Environment variables libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:203
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:205
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:206
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:207
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:208
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:209
msgid "``http_200_responses`` - total number of requests which have returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:211
msgid "``http_other_responses`` - total number of requests which have not returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:213
msgid "``failed_requests`` - total number of requests which have failed including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:220
msgid "Connect to an HTTP server, look at the size of the response for a 'GET' request, and look at the statistics for the session."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:223
msgid "tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:249
msgid "Start two Tarantool instances on the same computer."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:251
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:253
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:257
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:259
msgid "box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:265
msgid "Terminal #1 will show an error message: \"Invalid MsgPack\". This is not useful but demonstrates the syntax and demonstrates that was sent was received."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:5
msgid "Module `iconv`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:13
msgid "The ``iconv`` module provides a way to convert a string with one encoding to a string with another encoding, for example from ASCII to UTF-8. It is based on the POSIX iconv routines."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:17
msgid "An exact list of the available encodings may depend on environment. Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:26
msgid "Below is a list of all ``iconv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid "Create an iconv instance"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid "Perform conversion on a string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:47
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:49
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:50
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:52
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:55
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:59
msgid "tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:69
msgid "Convert."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:0
msgid "param string input-string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:71
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:73
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:75
msgid "If anything in input-string cannot be converted, there will be an error message and the result string will be unchanged."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:80
msgid "We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is hexadecimal 0414 according to the character database of Unicode_. Therefore that is what it will look like in UTF-16. We know that Tarantool typically uses the UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 target. Since the result is 0414, we see that iconv conversion works. (Different iconv implementations might use different names, for example UTF-16BE instead of UTF16BE.)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:90
msgid "tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:3
msgid "Built-in modules reference"
msgstr ""

#: ../doc/reference/reference_lua/index.rst:7
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:11
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:15
msgid "List of Lua modules"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:5
msgid "Module `json`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:11
msgid "The ``json`` module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford <http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. For a complete manual on Lua-CJSON please read `the official documentation <http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:20
msgid "Below is a list of all ``json`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid ":ref:`json.encode() <json-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid "Convert a Lua object to a JSON string"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid ":ref:`json.decode() <json-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid "Convert a JSON string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
msgid ":ref:`json.NULL <json-null>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
#: ../doc/reference/reference_lua/msgpack.rst:39
#: ../doc/reference/reference_lua/yaml.rst:34
msgid "Analog of Lua's \"nil\""
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid ":ref:`json.cfg() <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid "Set global flags"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:49
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:51
#: ../doc/reference/reference_lua/msgpack.rst:60
#: ../doc/reference/reference_lua/yaml.rst:46
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:52
#: ../doc/reference/reference_lua/json.rst:91
msgid "see :ref:`json.cfg <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:53
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:58
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:88
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:90
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:92
#: ../doc/reference/reference_lua/yaml.rst:57
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:97
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:115
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:123
#: ../doc/reference/reference_lua/msgpack.rst:111
#: ../doc/reference/reference_lua/yaml.rst:64
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:128
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:150
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:152
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:153
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:155
#: ../doc/reference/reference_lua/yaml.rst:101
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:158
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:181
msgid "Set values affecting behavior of :ref:`json.encode <json-encode>` and :ref:`json.decode <json-decode>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:184
msgid "The values are all either integers or boolean ``true``/``false`` values."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:186
msgid "``cfg.encode_deep_as_nil`` (default is false) -- see :ref:`below <json-module.cfg_encode_deep_as_nil>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:187
msgid "``cfg.encode_invalid_as_nil`` (default is false) -- use ``null`` for all unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:189
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:190
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:191
msgid "``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:192
msgid "``cfg.encode_number_precision`` (default is 14) -- maximum post-decimal digits"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:193
msgid "``cfg.encode_sparse_convert`` (default is true) -- handle excessively sparse arrays as maps"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:194
msgid "``cfg.encode_sparse_ratio`` (default is 2) -- how sparse an array can be"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:195
msgid "``cfg.encode_sparse_safe`` (default is 10) -- how much can safely be sparse"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:196
msgid "``cfg.encode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:198
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:199
msgid "``cfg.decode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:200
msgid "``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:201
msgid "``cfg.decode_save_metatables`` (default is true) -- like ``encode_load_metatables``"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:202
msgid "``cfg.decode_sparse_convert`` (default is true) -- like ``encode_sparse_convert``"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:203
msgid "``cfg.decode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:206
msgid "For example, the following code will encode 0/0 as nan (\"not a number\") and 1/0 as inf (\"infinity\"), rather than returning nil or an error message:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:209
msgid "json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:217
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:219
msgid "tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:226
msgid "To achieve the same effect for only one call to ``json.encode()`` without changing the configuration persistently, one could say ``json.encode({1, x, y, 2}, {encode_invalid_numbers = true})``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:230
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:237
msgid "**Behavior change:** Before Tarantool version 1.10.4, if a nested structure was deeper than ``cfg.encode_max_depth``, the deeper levels were cropped (encoded as nil)."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:241
msgid "Now, the result is an error suggesting that ``cfg.encode_max_depth`` is not deep enough. To return to the old behavior, say ``cfg.encode_deep_as_nil = true``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:245
msgid "This option is ignored for ``YAML``."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:5
msgid "Module `key_def`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:9
msgid "The `key_def` module has a function for making a definition of the field numbers and types of a tuple. The definition is usually used in conjunction with an index definition to extract or compare the index key values."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:18
msgid "Create a new key_def instance."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:20
msgid "field numbers and types. There must be at least one part and it must have at least fieldno and type."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:0
#: ../doc/reference/reference_lua/xlog.rst:0
msgid "returns"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:24
msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:26
msgid "The parts table has components which are the same as the ``parts`` option in :ref:`Options for space_object:create_index() <box_space-create_index-options>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:30
msgid "fieldno (integer) for example fieldno=1"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:32
msgid "type (string) for example type='string'"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:34
msgid "Other components are optional."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:36
msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:42
msgid "A key_def object is an object returned by :ref:`key_def.new() <key_def-new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, :ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() <key_def-totable>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:54
msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:56
#: ../doc/reference/reference_lua/key_def.rst:131
#: ../doc/reference/reference_lua/key_def.rst:132
#: ../doc/reference/reference_lua/key_def.rst:157
#: ../doc/reference/reference_lua/key_def.rst:158
#: ../doc/reference/reference_lua/merger.rst:160
msgid "tuple or Lua table with field contents"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:58
msgid "the fields that were defined for the key_def object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:60
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:244
msgid "**Example #1:**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:62
msgid "-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:85
msgid "**Example #2**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:87
msgid "-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:101
msgid "**Example #3**"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:103
msgid "-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:125
msgid "Compare the key fields of tuple_1 to the key fields of tuple_2. This is a tuple-by-tuple comparison so users do not have to write code which compares a field at a time. Each field's type and collation wll be taken into account. In effect it is a comparison of extract_key(tuple_1) with extract_key(tuple_2)."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:134
msgid "> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:140
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:152
msgid "Compare the key fields of tuple_1 to all the fields of tuple_2. This is the same as :ref:`key_def_object:compare() <key_def-compare>` except that tuple_2 contains only the key fields. In effect it is a comparison of extract_key(tuple_1) with tuple_2."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:160
msgid "> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:166
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:178
msgid "Combine the main key_def_object with other_key_def_object. The return value is a new key_def_object containing all the fields of the main key_def_object, then all the fields of other_key_def_object which are not in the main key_def_object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:183
msgid "definition of fields to add"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:185
msgid "key_def_object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:189
msgid "-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:202
msgid "Return a table containing what is in the key_def_object. This is the reverse of ``key_def.new()``:"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:205
msgid "``key_def.new()`` takes a table and returns a key_def object,"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:206
msgid "``key_def_object:totable()`` takes a key_def object and returns a table."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:208
msgid "This is useful for input to ``_serialize`` methods."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:214
msgid "-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:5
msgid "Module `log`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:13
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:18
msgid "As explained in the description of :ref:`log_format <cfg_logging-log_format>` configuration setting, there are two possible formats for log entries:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:48
msgid "Below is a list of all ``log`` functions."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:58
msgid ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:62
msgid "Write a user-generated message to a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid "Get the PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid "Rotate a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:84
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or ``debug``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:88
msgid "As explained in the description of the configuration setting for :ref:`log_level <cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:92
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:94
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:95
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:96
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:97
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:99
msgid "For example, if ``box.cfg.log_level`` is currently 5 (the default value), then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string.  Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string.  Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:107
msgid "Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:111
msgid "Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:117
msgid "The actual output will be a line in the log, containing:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:119
msgid "the current timestamp,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:120
msgid "a module name,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:121
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:122
msgid "``message``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:124
msgid "Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:132
msgid "PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:138
msgid "Rotate the log."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:146
msgid "$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:155
msgid "$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:162
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:164
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:5
msgid "Module `merger`"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:11
msgid "The ``merger`` module takes a stream of tuples and provides access to them as tables."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:18
msgid "The four functions for creating a merger object instance are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:20
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:21
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:22
msgid ":ref:`merger.new_table_source <merger-new_table_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:23
#: ../doc/reference/reference_lua/merger.rst:111
msgid ":ref:`merger.new(merger_source...) <merger-new_merger_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:25
msgid "The methods for using a merger object are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:27
msgid ":ref:`merger_object:select() <merger-select>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:28
#: ../doc/reference/reference_lua/merger.rst:116
msgid ":ref:`merger_object:pairs() <merger-pairs>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:36
msgid "Create a new merger instance from a tuple source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:38
msgid "A tuple source just returns one tuple."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:40
msgid "The generator function ``gen()`` allows creation of multiple tuples via an iterator."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:43
msgid "The ``gen()`` function should return:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:45
msgid "state, tuple each time it is called and a new tuple is available,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:46
msgid "nil when no more tuples are available."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:48
msgid "function for iteratively returning tuples"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:49
msgid "parameter for the gen function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:51
#: ../doc/reference/reference_lua/merger.rst:95
msgid "merger-object :ref:`a merger object <merger-object>`"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:53
#: ../doc/reference/reference_lua/merger.rst:100
msgid "Example: see :ref:`merger_object:pairs() <merger-pairs>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:59
msgid "Create a new merger instance from a buffer source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:61
#: ../doc/reference/reference_lua/merger.rst:73
msgid "Parameters and return: same as for :ref:`merger.new_tuple_source <merger-new_tuple_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:64
msgid "To set up a buffer, or a series of buffers, use :ref:`the buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:71
msgid "Create a new merger instance from a table source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:76
msgid "Example: see :ref:`merger_object:select() <merger-select>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:82
msgid "Create a new merger instance from a merger source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:84
msgid "A merger source is created from a :ref:`key_def <key_def-module>` object and a set of (tuple or buffer or table or merger) sources. It performs a kind of merge sort. It chooses a source with a minimal / maximal tuple on each step, consumes a tuple from this source, and repeats."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:91
msgid "object created with ``key_def``"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:92
msgid "parameter for the ``gen()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:93
msgid "``reverse=true`` if descending, false or nil if ascending"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:97
msgid "A ``key_def`` can be cached across requests with the same ordering rules (typically these would be requests accessing the same space)."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:106
msgid "A merger object is an object returned by:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:108
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:109
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:110
msgid ":ref:`merger.new_table_source <merger-new_table_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:113
msgid "It has methods:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:115
msgid ":ref:`merger_object:select() <merger-select>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:122
msgid "Access the contents of a merger object with familiar ``select`` syntax."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:124
#: ../doc/reference/reference_lua/merger.rst:125
msgid "as in ``net.box`` client :ref:`conn:select <conn-select>` method"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:127
msgid "a table of tuples, similar to what ``select`` would return"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:129
msgid "**Example with new_table_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:131
msgid "-- Source via new_table_source, simple generator function\n"
"-- tarantool> s:select()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger=require('merger')\n"
"k=0\n"
"function merger_function(param)\n"
"  k = k + 1\n"
"  if param[k] == nil then return nil end\n"
"  return box.NULL, param[k]\n"
"  end\n"
"chunks={}\n"
"chunks[1] = {{100}} chunks[2] = {{200}} chunks[3] = nil\n"
"s = merger.new_table_source(merger_function, chunks)\n"
"s:select()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:155
msgid "The ``pairs()`` method (or the equivalent ``ipairs() alias`` method) returns a luafun iterator. It is a Lua iterator, but also provides a set of handy methods to operate in functional style."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:162
msgid "the tuples that can be found with a standard ``pairs()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:164
msgid "**Example with new_tuple_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:166
msgid "-- Source via new_tuple_source, from a space of tables\n"
"-- The result will look like this:\n"
"-- tarantool> so:pairs():totable()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger = require('merger')\n"
"box.schema.space.create('s')\n"
"box.space.s:create_index('i')\n"
"box.space.s:insert({100})\n"
"box.space.s:insert({200})\n"
"so = merger.new_tuple_source(box.space.s:pairs())\n"
"so:pairs():totable()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:183
msgid "**Example with two mergers:**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:185
msgid "-- Source via key_def, and table data\n"
"\n"
"-- Create the key_def object\n"
"merger = require('merger')\n"
"key_def_lib = require('key_def')\n"
"key_def = key_def_lib.new({{\n"
"    fieldno = 1,\n"
"    type = 'string',\n"
"}})\n"
"-- Create the table source\n"
"data = {{'a'}, {'b'}, {'c'}}\n"
"source = merger.new_source_fromtable(data)\n"
"i1 = merger.new(key_def, {source}):pairs()\n"
"i2 = merger.new(key_def, {source}):pairs()\n"
"-- t1 will be 'a' (tuple 1 from merger 1)\n"
"t1 = i1:head():totable()\n"
"-- t3 will be 'c' (tuple 3 from merger 2)\n"
"t3 = i2:head():totable()\n"
"-- t2 will be 'b' (tuple 2 from merger 1)\n"
"t2 = i1:head():totable()\n"
"-- i1:is_null() will be true (merger 1 ends)\n"
"i1:is_null()\n"
"-- i2:is_null() will be true (merger 2 ends)\n"
"i2:is_null()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:212
msgid "**More examples:**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:214
msgid "See `https://github.com/Totktonada/tarantool-merger-examples <https://github.com/Totktonada/tarantool-merger-examples>`_ which, in addition to discussing the merger API in detail, shows Lua code for handling many more situations than are in this manual's brief examples."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:5
msgid "Module `msgpack`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:11
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them. Tarantool makes heavy internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:20
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid "Convert a Lua object to an MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
#: ../doc/reference/reference_lua/msgpack.rst:36
msgid "Convert a MsgPack string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:36
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:39
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid ":ref:`msgpack.decode_array_header <msgpack-decode_array_header>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid "Skip array header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
msgid ":ref:`msgpack.decode_map_header <msgpack-decode_map_header>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
msgid "Skip map header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid "Change configuration"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:58
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:61
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:68
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:70
#: ../doc/reference/reference_lua/msgpack.rst:98
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:71
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:76
msgid "(if ``msgpack_string`` is in valid MsgPack format) the original contents of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar value, such as a string or a number;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:79
msgid "\"next_start_position\". If ``decode`` stops after parsing as far as byte N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, and ``decode(msgpack_string, next_start_position)`` will continue parsing from where the previous ``decode`` stopped, plus 1. Normally ``decode`` parses all of ``msgpack_string``, so \"next_start_position\" will equal ``string.len(msgpack_string)`` + 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:86
msgid "table and number"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:92
msgid "Convert a MsgPack string to a Lua object. Because checking is skipped, ``decode_unchecked()`` can operate with string pointers to buffers which ``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-module>` module."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:102
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:103
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:105
msgid "lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:118
msgid "Call the mp_decode_array function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the array size and a pointer to the first array component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole array."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:122
#: ../doc/reference/reference_lua/msgpack.rst:150
msgid "a pointer to a byte array formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:123
msgid "a number greater than or equal to the string's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:127
msgid "the size of the array;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:128
msgid "a pointer to after the array header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:130
msgid "-- Example of decode_array_header\n"
"-- Suppose we have the raw data '\\x93\\x01\\x02\\x03'.\n"
"-- \\x93 is MsgPack encoding for a header of a three-item array.\n"
"-- We want to skip it and decode the next three items.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_array_header(ffi.cast('char*','\\x93\\x01\\x02\\x03'),4)\n"
"a=msgpack.decode(y,1);b=msgpack.decode(y+1,1);c=msgpack.decode(y+2,1);\n"
"a,b,c\n"
"-- The result will be: 1,2,3."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:146
msgid "Call the mp_decode_map function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the map size and a pointer to the first map component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole map."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:151
msgid "a number greater than or equal to the byte array's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:155
msgid "the size of the map;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:156
msgid "a pointer to after the map header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:158
msgid "-- Example of decode_map_header\n"
"-- Suppose we have the raw data '\\x81\\xa2\\x41\\x41\\xc3'.\n"
"-- \\x81 is MsgPack encoding for a header of a one-item map.\n"
"-- We want to skip it and decode the next map item.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_map_header(ffi.cast('char*','\\x81\\xa2\\x41\\x41\\xc3'),5)\n"
"a=msgpack.decode(y,3);b=msgpack.decode(y+3,1)\n"
"x,a,b\n"
"-- The result will be: 1,\"AA\", true."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:174
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:199
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:201
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:202
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:204
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:208
msgid "function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:228
msgid "**Result:**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:267
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:236
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:243
msgid "and the second encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:282
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:250
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:258
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "{}"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'a'"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "false"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "'false' = c2"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "true"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "'true' = c3"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "127"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "65535"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "4294967295"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:281
msgid "'nil' = c0"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "msgpack.NULL"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "same as nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid "[0] = 5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "[0] = nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "1.5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:298
msgid "Some MsgPack configuration settings can be changed, in the same way that they can be changed for json. See :ref:`Module JSON <json-module_cfg>` for a list of some configuration settings. (The same configuration settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:303
msgid "For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the default), then nan and inf are legal values. If that is not desirable, then ensure that ``msgpack.encode()`` will not accept them, by saying ``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:308
msgid " tarantool> msgpack = require('msgpack'); msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:11
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is for connecting to Tarantool server instances via a network."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:19
msgid "``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:21
msgid "``net_box.connect()`` to connect and get a connection object (named ``conn`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:23
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote database system,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:27
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact that is perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. However for some cases a single connection is not enough —- for example, when it is necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:36
msgid "Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:38
msgid "``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:42
msgid "``{is_async=...}``. For example, a method whose final argument is ``{is_async=true}`` will not wait for the result of a request. See the :ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:45
msgid "``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See the :ref:`box.session.push <box_session-push>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:60
msgid "``net_box.connect()`` method changes the state to 'connecting' and spawns a worker fiber."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:62
msgid "If authentication and schema upload are required, it's possible later on to re-enter the 'fetch_schema' state from 'active' if a request fails due to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:66
msgid "``conn.close()`` method sets the state to 'closed' and kills the worker. If the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:83
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid "Execute a PING command"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid "Wait for a target state"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid "Close a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid "Select one or more tuples"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid "Select a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid "Insert a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
#: ../doc/reference/reference_lua/net_box.rst:118
msgid "Update a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:118
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid "Delete a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid "Call a stored procedure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid "Set a timeout"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:133
msgid ":ref:`net_box.on_connect() <net_box-on_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:133
msgid "Define a connect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:136
msgid ":ref:`net_box.on_disconnect() <net_box-on_disconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:136
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:139
msgid ":ref:`net_box.on_schema_reload() <net_box-on_schema_reload>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:139
msgid "Define a trigger when schema is modified"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:154
msgid "The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is preferred; ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:157
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:163
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:175
msgid "Possible options:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:177
msgid "`wait_connected`: by default, connection creation is blocked until the connection is established, but passing ``wait_connected=false`` makes it return immediately. Also, passing a timeout makes it wait before returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:183
msgid "In the presence of ``reconnect_after``, ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:186
msgid "`reconnect_after`: a ``net.box`` instance automatically reconnects any time the connection is broken or if a connection attempt fails. This makes transient network failures become transparent to the application. Reconnect happens automatically in the background, so queries/requests that suffered due to connectivity loss are transparently retried. The number of retries is unlimited, connection attempts are done over the specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed, or once the Lua garbage collector removes it, reconnects stop."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:196
msgid "`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new binary protocol command for CALL, which is not backward compatible with previous versions. The new CALL no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:205
msgid "`console`: depending on the option's value, the connection supports different methods (as if instances of different classes were returned). With ``console = true``, you can use ``conn`` methods ``close()``, ``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary and Lua console network protocols are supported). With ``console = false`` (default), you can also use ``conn`` database methods (in this case, only the binary protocol is supported). Deprecation notice: ``console = true`` is deprecated, users should use :ref:`console.connect() <console-connect>` instead."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:213
msgid "`connect_timeout`: number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:215
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:216
msgid "possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:217
msgid "conn object"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:220
#: ../doc/reference/reference_lua/net_box.rst:288
#: ../doc/reference/reference_lua/net_box.rst:425
#: ../doc/reference/reference_lua/net_box.rst:459
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:324
msgid "**Examples:**"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:222
msgid "conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:234
msgid "Execute a PING command."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:236
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:237
msgid "true on success, false on error"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
msgid "net_box.self:ping({timeout = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:250
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:252
#: ../doc/reference/reference_lua/net_box.rst:284
msgid "in seconds"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:253
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:258
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:266
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:268
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:273
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:281
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:283
msgid "target states"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:285
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:290
msgid "-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:305
msgid "Close a connection."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:307
msgid "Connection objects are destroyed by the Lua garbage collector, just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:314
msgid "conn:close()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:322
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:328
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:334
msgid "Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:345
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:350
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:358
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:364
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:372
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:378
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:386
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:392
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:400
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:408
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:416
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:422
msgid "To ensure that the return from ``conn:eval`` is whatever the Lua expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:427
msgid "tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:451
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call. The return from ``conn:call`` is whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:455
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:461
msgid "tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:484
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it. Since version 1.7.4 this method is deprecated -- it is better to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:490
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:494
msgid "Although ``timeout(...)`` is deprecated, all remote calls support its use. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:506
msgid "``{is_async=true|false}`` is an option which is applicable for all ``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn.space.space-name`` requests."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:510
msgid "The default is ``is_async=false``, meaning requests are synchronous for the fiber. The fiber is blocked, waiting until there is a reply to the request or until timeout expires. Before Tarantool version 1.10, the only way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:516
msgid "The non-default is ``is_async=true``, meaning requests are asynchronous for the fiber. The request causes a yield but there is no waiting. The immediate return is not the result of the request, instead it is an object that the calling program can use later to get the result of the request."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:522
msgid "This immediately-returned object, which we'll call \"future\", has its own methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:525
msgid "``future:is_ready()`` which will return true when the result of the request is available,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:527
msgid "``future:result()`` to get the result of the request (returns the response or **nil** in case it's not ready yet or there has been an error),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:529
msgid "``future:wait_result(timeout)`` to wait until the result of the request is available and then get it,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:531
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:533
msgid "Typically a user would say ``future=request-name(...{is_async=true})``, then either loop checking ``future:is_ready()`` until it is true and then say ``request_result=future:result()``, or say ``request_result=future:wait_result(...)``. Alternatively the client could check for \"out-of-band\" messages from the server by calling ``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-push>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:542
msgid "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:564
msgid "Typically ``{is_async=true}`` is used only if the load is large (more than 100,000 requests per second) and latency is large (more than 1 second), or when it is necessary to send multiple requests in parallel then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:572
msgid "Although the final result of an async request is the same as the result of a sync request, it is structured differently: as a table, instead of as the unpacked values."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:580
msgid "Triggers"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:582
msgid "With the ``net.box`` module, you can use the following :ref:`triggers <triggers-box_triggers>`:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:589
msgid "Define a trigger for execution when a new connection is created due to an event such as ``net_box.connect``. The trigger function will be the first thing executed after a new connection is created. If the trigger execution fails and raises an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:594
#: ../doc/reference/reference_lua/net_box.rst:607
#: ../doc/reference/reference_lua/net_box.rst:619
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:595
#: ../doc/reference/reference_lua/net_box.rst:608
#: ../doc/reference/reference_lua/net_box.rst:620
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:596
#: ../doc/reference/reference_lua/net_box.rst:609
#: ../doc/reference/reference_lua/net_box.rst:621
msgid "nil or function pointer"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:602
msgid "Define a trigger for execution after a connection is closed. If the trigger function causes an error, the error is logged but otherwise is ignored. Execution stops after a connection is explicitly closed, or once the Lua garbage collector removes it."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:615
msgid "Define a trigger executed when some operation has been performed on the remote server after schema has been updated. So, if a server request fails due to a schema version mismatch error, schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:625
msgid "If the parameters are ``(nil, old-trigger-function)``, then the old trigger is deleted."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:628
msgid "If both parameters are omitted, then the response is a list of existing trigger functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:631
msgid "Details about trigger characteristics are in the :ref:`triggers <triggers-box_triggers>` section."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:638
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:640
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:642
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:643
msgid "there is a space named ``tester`` with a numeric primary key and with a tuple that contains a key value = 800,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:645
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:647
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:649
msgid "box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:657
msgid "And here starts the example:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:659
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:5
msgid "Module `os`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:13
msgid "The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:30
msgid "Below is a list of all ``os`` functions."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid ":ref:`os.execute() <os-execute>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid "Execute by passing to the shell"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:43
msgid ":ref:`os.rename() <os-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid "Get an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid ":ref:`os.remove() <os-remove>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid "Remove a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid ":ref:`os.date() <os-date>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid "Get a formatted date"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid ":ref:`os.exit() <os-exit>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid "Exit the program"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid ":ref:`os.time() <os-time>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid "Get the number of seconds since the epoch"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid ":ref:`os.clock() <os-clock>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid "Get the number of CPU seconds since the program start"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid "Get the name of a temporary file"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid ":ref:`os.environ() <os-environ>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid "Get a table with all environment variables"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid "Set an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid "Change the locale"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid "Get the number of seconds between two times"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:84
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:86
msgid "what to execute."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:90
msgid "tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:106
msgid "Rename a file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:108
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:109
msgid "changed name of file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:113
msgid "tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:126
msgid "Get environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:128
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:132
msgid "tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:143
msgid "Remove file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:145
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:149
msgid "tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:160
msgid "Return a formatted date."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:167
msgid "tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:178
msgid "Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:182
msgid "tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:191
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:195
msgid "tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:206
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:210
msgid "tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:221
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:225
msgid "tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:236
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:240
msgid "tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:251
msgid "Set an environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:255
msgid "tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:266
msgid "Change the locale. If new-locale-string is not specified, return the current locale."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:271
msgid "tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:282
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:286
msgid "tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:3
msgid "Other package components"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:5
msgid "All the Tarantool modules are, at some level, inside a package which, appropriately, is named ``package``. There are also miscellaneous functions and variables which are outside all modules."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:17
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:17
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:20
msgid ":ref:`dostring() <other-dostring>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:20
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:23
msgid ":ref:`package.path <other-package_path>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:23
msgid "Where Tarantool looks for Lua additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid ":ref:`package.cpath <other-package_cpath>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid "Where Tarantool looks for C additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:29
msgid ":ref:`package.loaded <other-package_loaded>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:29
msgid "What Tarantool has already looked for and found"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid ":ref:`package.setsearchroot <other-package_setsearchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid "Set the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid ":ref:`package.searchroot <other-package_searchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid "Get the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:44
msgid "Convert a string or a Lua number to a 64-bit integer. The input value can be expressed in decimal, binary (for example 0b1010), or hexadecimal (for example -0xffff). The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:54
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:79
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:83
msgid "Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:84
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:87
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:89
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:94
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:127
msgid "This is a string that Tarantool uses to search for Lua modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:135
msgid "This is a string that Tarantool uses to search for C modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:143
msgid "This is a string that shows what Lua or C modules Tarantool has loaded, so that their functions and members are available. Initially it has all the pre-loaded modules, which don't need ``require()``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:152
msgid "Set the search root. The search root is the root directory from which dependencies are loaded."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:155
msgid "the path. Default = current directory."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:157
msgid "The search-root string must contain a relative or absolute path. If it is a relative path, then it will be expanded to an absolute path. If search-root is omitted, or is box.NULL, then the search root is reset to the current directory, which is found with debug.sourcedir()."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:165
msgid "Suppose that a Lua file ``myapp/init.lua`` is the project root. |br| Suppose the current path is ``/home/tara``. |br| Add this as the first line of ``myapp/init.lua``: |br| :code:`package.setsearchroot()` |br| Start the project with |br| :code:`$ tarantool myapp/init.lua` |br| The search root will be the default, made absolute: ``/home/tara/myapp``. Within the Lua application all dependencies will be searched relative to ``/home/tara/myapp``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:179
msgid "Return a string with the current search root. After ``package.setsearchroot('/home')`` the returned string will be ``/home'``."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:3
msgid "Module `pickle`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:9
msgid "Below is a list of all ``pickle`` functions."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid "Convert Lua variables to binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid "Convert Lua variables back from binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:32
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:38
msgid "**Format specifiers**"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "b, B"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "converts Lua scalar value to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "s, S"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "i, I"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "l, L"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "n"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "N"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "q, Q"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "f"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "converts Lua scalar value to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "d"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "converts Lua scalar value to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "a, A"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "converts Lua scalar value to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:79
msgid "string containing format specifiers"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:80
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:81
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:85
msgid "A scalar value can be either a variable or a literal. Remember that large integers should be entered with :ref:`tonumber64() or LL or ULL suffixes <index-box_number>`."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:89
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:93
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:129
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:135
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:140
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:5
msgid "Module `socket`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:11
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:17
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:30
msgid "Below is a list of all ``socket`` functions."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid "Create a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
#: ../doc/reference/reference_lua/socket.rst:51
msgid "Connect a socket to a remote host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid "Get information about a remote site"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid "Make Tarantool act as a TCP server"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:51
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid ":ref:`socket_object:send() <socket-send>` |br| :ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid "Send data over a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid "Write data to the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid "Read from a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid "Read data from the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid "Bind a socket to the given host/port"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid "Start listening for incoming connections"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid "Accept a client connection + create a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid "Send a message on a UDP socket to a specified host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid "Receive a message on a UDP socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid "Shut down a reading end, a writing end, or both"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid "Close a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:error() <socket-error>` |br| :ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid "Get information about the last error on a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid "Set socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid "Get socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid "Set/clear the SO_LINGER flag"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid "Set/get the flag value"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid "Wait until something is readable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid "Wait until something is writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid "Wait until something is either readable or writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid "Get information about the connection's near side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid "Get information about the connection's far side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid "Wait for read/write activity"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:114
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will cause a yield so that other processes may take over, as is the norm for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:123
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:132
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:135
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:140
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:148
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:150
#: ../doc/reference/reference_lua/socket.rst:355
#: ../doc/reference/reference_lua/socket.rst:395
msgid "URL or IP address"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:151
#: ../doc/reference/reference_lua/socket.rst:356
#: ../doc/reference/reference_lua/socket.rst:396
msgid "port number"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:152
msgid "timeout"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:153
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:158
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:166
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:172
#: ../doc/reference/reference_lua/socket.rst:560
#: ../doc/reference/reference_lua/socket.rst:572
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:177
msgid "tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:197
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with :ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:201
msgid "host name or IP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:202
msgid "host port, may be 0"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:203
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:205
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:208
msgid "The handler-function-or-table parameter may be simply a function name / function declaration: :code:`handler_function`. Or it may be a table: :code:`{handler =` :samp:`{handler_function} [, prepare = {prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is mandatory; it may have a single parameter = the socket; it is for continuous operation after the connection is made. ``prepare_function`` is optional; it is executed once before any connection is made. Examples:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:220
msgid "socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:226
msgid "For a fuller example see :ref:`Use tcp_server to accept file contents sent with socat <socket_socat>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:235
msgid "Connect an existing socket to a remote host. The argument values are the same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:252
msgid "Parameters:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:242
msgid "Either:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:241
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:243
msgid "port - a number."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
#: ../doc/reference/reference_lua/socket.rst:252
msgid "Or:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:246
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:248
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:250
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:254
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:259
msgid "socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:270
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:272
#: ../doc/reference/reference_lua/socket.rst:397
msgid "what is to be sent"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:273
#: ../doc/reference/reference_lua/socket.rst:399
msgid "the number of bytes sent."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:276
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:282
msgid "Write as much data as possible to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:289
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:292
#: ../doc/reference/reference_lua/socket.rst:410
msgid "maximum number of bytes to receive. See :ref:`Recommended size <socket-recommended>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:293
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:296
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:307
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired. Unlike ``socket_object:recv`` (which uses an internal read-ahead buffer), ``socket_object:read`` depends on the socket's buffer."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:314
#: ../doc/reference/reference_lua/socket.rst:339
msgid "maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:316
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:318
msgid "maximum number of seconds to wait, for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:320
msgid ":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example :code:`{chunk=5,delimiter='x'}`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:324
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:334
msgid "Return data from the socket buffer if non-blocking. In case the socket is blocking, ``sysread()`` can block the calling process. Rarely used. For details, see also `this description <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:342
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:350
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:358
msgid "true for success, false for error. If return is false, use :ref:`socket_object:errno() <socket-error>` or :ref:`socket_object:error() <socket-error>` to see details."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:367
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:369
msgid "on Linux the listen ``backlog`` backlog may be from ``/proc/sys/net/core/somaxconn``, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:373
msgid "true for success, false for error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:374
msgid "boolean."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:380
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:384
msgid "new socket if success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:387
msgid "Possible errors: nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:393
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:402
msgid "Possible errors: on error, returns nil and may return status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:408
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:411
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:412
msgid "string, table"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:414
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:418
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:422
msgid "message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:432
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:434
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:436
#: ../doc/reference/reference_lua/tap.rst:154
#: ../doc/reference/reference_lua/tap.rst:177
#: ../doc/reference/reference_lua/tap.rst:211
#: ../doc/reference/reference_lua/tap.rst:246
#: ../doc/reference/reference_lua/tap.rst:259
#: ../doc/reference/reference_lua/tap.rst:269
#: ../doc/reference/reference_lua/tap.rst:284
#: ../doc/reference/reference_lua/tap.rst:305
#: ../doc/reference/reference_lua/tap.rst:324
msgid "true or false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:443
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when the Lua garbage collector removes its user data."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:447
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:456
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:459
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:461
msgid "number, string"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:467
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:471
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:472
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:473
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:474
msgid "SO_DEBUG"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:475
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:476
msgid "SO_ERROR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:477
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:478
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:479
msgid "SO_MARK"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:480
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:481
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:482
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:483
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:484
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:485
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:486
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:487
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:488
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:489
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:490
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:491
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:492
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:493
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:494
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:495
msgid "SO_TYPE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:497
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:503
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:509
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:514
msgid "new active and timeout values."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:520
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:521
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:522
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:524
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:531
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:533
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:539
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:541
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:547
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:549
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:555
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:567
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:579
msgid "The ``socket.iowait()`` function is used to wait until read-or-write activity occurs for a file descriptor."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:582
msgid "file descriptor"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:583
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:584
msgid "number of seconds to wait"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:586
msgid "If the fd parameter is nil, then there will be a sleep until the timeout. If the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:589
msgid "Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:593
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:599
msgid "Recommended size"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:601
msgid "For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to limit the number of bytes to receive. A fixed size such as 512 is often reasonable; a pre-calculated size that depends on context -- such as the message format or the state of the network -- is often better. For ``recvfrom``, be aware that a size greater than the `Maximum Transmission Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can cause inefficient transport. For Mac OS X, be aware that the size can be tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:612
msgid "If ``size`` is not stated: Tarantool will make an extra call to calculate how many bytes are necessary. This extra call takes time, therefore not stating ``size`` may be inefficient."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:616
msgid "If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a TCP socket, excess bytes are not discarded and can be received by the next call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:622
msgid "Examples"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:626
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:628
msgid "In this example a connection is made over the internet between a Tarantool instance and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has moved. This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:634
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:665
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:667
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:673
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:712
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:714
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:719
msgid "Start two shells. The first shell will be a server instance. The second shell will be the client."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:722
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:724
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:746
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:753
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:758
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server instance's host and port:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:761
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:765
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:5
msgid "Module `strict`"
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:9
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:14
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:20
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:5
msgid "Module `string`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:13
msgid "The :code:`string` module has everything in the `standard Lua string library <https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:17
msgid "In this section we only discuss the additional functions that the Tarantool developers have added."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:24
msgid "Below is a list of all additional ``string`` functions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:34
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:34
msgid "Left-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:37
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:37
msgid "Right-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:40
msgid ":ref:`string.hex() <string-hex>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:40
msgid "Given a string, return hexadecimal values"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:43
msgid ":ref:`string.fromhex() <string-fromhex>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:43
msgid "Given hexadecimal values, return a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:46
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:46
msgid "Check if a string starts with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:49
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:49
msgid "Check if a string ends with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:52
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:52
msgid "Remove characters from the left of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:55
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:55
msgid "Remove characters from the right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:58
msgid ":ref:`string.split() <string-split>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:58
msgid "Split a string into a table of strings"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:61
msgid ":ref:`string.strip() <string-strip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:61
msgid "Remove spaces on the left and right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:69
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:71
msgid "the string to left-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:72
msgid "the width of the string after left-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:73
#: ../doc/reference/reference_lua/string.rst:98
msgid "a single character, default = 1 space"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:75
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:80
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:94
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:96
msgid "the string to right-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:97
msgid "the width of the string after right-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:100
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:105
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:119
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:121
#: ../doc/reference/reference_lua/string.rst:231
#: ../doc/reference/reference_lua/string.rst:257
#: ../doc/reference/reference_lua/string.rst:315
msgid "the string to process"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:123
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:128
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:142
msgid "Given a string containing pairs of hexadecimal digits, return a string with one byte for each pair. This is the reverse of ``string.hex()``. The hexadecimal-input-string must contain an even number of hexadecimal digits."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:146
msgid "string with pairs of hexadecimal digits"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:148
msgid "string with one byte for each pair of hexadecimal digits"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:153
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.fromhex('41424320')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:167
msgid "Return True if ``input-string`` starts with ``start-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:170
msgid "the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:171
#: ../doc/reference/reference_lua/string.rst:201
msgid "the string to look for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:172
#: ../doc/reference/reference_lua/string.rst:202
msgid "position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:173
#: ../doc/reference/reference_lua/string.rst:203
msgid "position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:175
#: ../doc/reference/reference_lua/string.rst:205
#: ../doc/reference/reference_lua/utf8.rst:146
#: ../doc/reference/reference_lua/utf8.rst:171
#: ../doc/reference/reference_lua/utf8.rst:193
#: ../doc/reference/reference_lua/utf8.rst:215
msgid "true or false"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:178
#: ../doc/reference/reference_lua/string.rst:208
msgid "``start-pos`` and ``end-pos`` may be negative, meaning the position should be calculated from the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:183
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:197
msgid "Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:200
msgid "the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:213
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:227
msgid "Return the value of the input string, after removing characters on the left. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.lstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:232
#: ../doc/reference/reference_lua/string.rst:258
#: ../doc/reference/reference_lua/string.rst:316
msgid "what characters can be stripped. Default = space."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:234
#: ../doc/reference/reference_lua/string.rst:260
#: ../doc/reference/reference_lua/string.rst:318
msgid "result after stripping characters from input string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:239
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:253
msgid "Return the value of the input string, after removing characters on the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.rstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:265
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:279
msgid "Split ``input-string`` into one or more output strings in a table. The places to split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:283
msgid "the string to split"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:284
msgid "the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:286
msgid "maximum number of delimiters to process counting from the beginning of the input string. Result will contain max + 1 parts maximum."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:290
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:295
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A:B C:D\", \":\", 2)\n"
"---\n"
"- - A\n"
"  - B\n"
"  - ' C:D'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:311
msgid "Return the value of the input string, after removing characters on the left and the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.strip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:323
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:5
msgid "Module `swim`"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:11
msgid "The ``swim`` module contains Tarantool's implementation of SWIM -- Scalable Weakly-consistent Infection-style Process Group Membership Protocol. It is recommended for any type of Tarantool cluster where the number of nodes can be large. Its job is to discover and monitor the other members in the cluster and keep their information in a \"member table\". It works by sending and receiving, in a background event loop, periodically, via UDP, messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:19
msgid "Each message has several parts, including:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:21
msgid "the ping such as \"I am checking whether you are alive\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:22
msgid "the event such as \"I am joining\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:23
msgid "the anti-entropy such as \"I know that another member exists\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:24
msgid "the payload such as \"I or another member could have user-generated data\"."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:26
msgid "The maximum message size is about 1500 bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:28
msgid "SWIM sends messages periodically to a random subset of the member table. SWIM processes replies from those members asynchronously."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:31
msgid "Each entry in the member table has:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:33
msgid "a UUID,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:34
msgid "a status (\"alive\", \"suspected\", \"dead\", or \"left\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:36
msgid "When a member fails to acknowledge a certain number of pings, its status is changed from \"alive\" to \"suspected\", that is, suspected of being dead. But SWIM tries to **avoid false positives** (misidentifying members as dead) which could happen when a member is overloaded and responds to pings too slowly, or when there is network trouble and packets can not go through some channels. When a member is suspected, SWIM randomly chooses other members and sends requests to them: \"please ping this suspected member\". This is called an **indirect ping**. Thus via different routes and additional hops the suspected member gets additional chances to reply, and thus \"refute\" the suspicion."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:47
msgid "Because selection is random there is an **even network load** of about one message per member per protocol step, regardless of the cluster size. This is a major feature of SWIM. Because the protocol depends on members passing information on, also known as \"gossiping\", members do not need to broadcast messages to every member, which would cause a network load of N messages per member per protocol step, where N is the number of members in the cluster. However, selection is not entirely random, there is a preference for selecting least-recently-pinged members, like a round-robin."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:56
msgid "Regarding the **anti-entropy** part of a message: this is necessary for maintaining the status in entries of the member table. Consider an example where two members, #1 and #2, are both alive. No events happen so only pings are being sent periodically. Then a third member, #3 appears. It knows about one of the existing members, #2. How can it discover the other member? Certainly #1 could notify #2 and #2 could notify #3, but messages go via UDP, so any notification event can be lost. However, regular messages containing \"ping\" and/or \"event\" also can contain an \"anti-entropy\" section, which is taken from a randomly-chosen part of the member table. So for this example, #2 will eventually randomly add to a regular message the anti-entropy note that #1 is alive, and thus #3 will discover #1 even though it did not receive a direct \"I am alive\" event message from #1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:72
msgid "Regarding the **UUID** part of an entry in the member table: this is necessary for stable identification, because UUID changes more rarely than URI (a combination of IP and port number). But if the UUID does change, SWIM will include both the new and old UUID in messages, so all other members will eventually learn about the new UUID and change the member table accordingly."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:80
msgid "Regarding the **payload** part of a message: this is not always necessary, it is a feature which allows passing user-generated information via SWIM instead of via node-to-node communication. The swim module has methods for specifying a \"payload\", which is arbitrary user data with a maximum size of about 1.2 KB. The payload can be anything, and it will be eventually disseminated over the cluster and available at other members. Each member can have its own payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:90
msgid "Messages can be **encrypted**. Encryption may not be necessary in a closed network but is necessary for safety if the cluster is on the public Internet. Users can specify an encryption algorithm, an encryption mode, and a private key. All parts of all messages (including ping, acknowledgment, event, payload, URI, and UUID) will be encrypted with that private key, as well as a random public key generated for each message to prevent pattern attacks."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:98
msgid "In theory the event dissemination speed (the number of hops to pass information throughout the cluster) is ``O(log(cluster_size))``. For that and other theoretical information see the Cornell University `paper <https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>`_ which originally described SWIM."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:110
msgid "Create a new SWIM instance. A SWIM instance maintains a member table and interacts with other members. Multiple SWIM instances can be created in a single Tarantool process."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
msgid "an optional configuration parameter.  If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-object_cfg>` is called.  If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``, except for generation. For configuration description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
msgid "an optional configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:116
msgid "If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-object_cfg>` is called."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:122
msgid "If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``, except for generation. For configuration description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:128
msgid "The generation part of ``cfg`` can only be specified during ``new()``, it cannot be specified later during ``cfg()``. Generation is part of :ref:`incarnation <swim-incarnation_description>`. Usually generation is not specified because the default value (a timestamp) is sufficient, but if there is reason to mistrust timestamps (because the time is changed or because the instance is started on a different machine), then users may say :samp:`swim.new({generation = {new-value}`. In that case the latest value should be persisted somehow (for example in a file, or in a space, or in a global service), and the new value must be greater than any previous value of generation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:140
msgid "swim-object :ref:`a swim object <swim-object>`"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:144
msgid "swim_object = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:152
msgid "A swim object is an object returned by :ref:`swim.new() <swim-new>`. It has methods: :ref:`cfg() <swim-object_cfg>`, :ref:`delete() <swim-delete>`, :ref:`is_configured() <swim-is_configured>`, :ref:`size() <swim-size>`, :ref:`quit() <swim-quit>`, :ref:`add_member() <swim-add_member>`, :ref:`remove_member() <swim-remove_member>`, :ref:`probe_member() <swim-probe_member>`, :ref:`broadcast() <swim-broadcast>`, :ref:`set_payload() <swim-set_payload>`, :ref:`set_payload_raw() <swim-set_payload_raw>`, :ref:`set_codec() <swim-set_codec>`, :ref:`self() <swim-self>`, :ref:`member_by_uuid() <swim-member_by_uuid>`, :ref:`pairs() <swim-pairs>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:174
msgid "Configure or reconfigure a SWIM instance."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:176
msgid "the options to describe instance behavior"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:178
msgid "The ``cfg`` table may have these components:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:180
msgid "``heartbeat_rate`` (double) -- rate of sending round messages, in seconds. Setting ``heartbeat_rate`` to X does not mean that every member will be checked every X seconds, instead X is the protocol speed. Protocol period depends on member count and heartbeat_rate. Default = 1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:186
msgid "``ack_timeout`` (double) -- time in seconds after which a ping is considered to be unacknowledged. Default = 30."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:189
msgid "``gc_mode`` (enum) -- dead member collection mode."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:191
msgid "If ``gc_mode == 'off'`` then SWIM never removes dead members from the member table (though users may remove them with :ref:`swim_object:remove_member() <swim-remove_member>`), and SWIM will continue to ping them as if they were alive."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:196
msgid "If ``gc_mode == 'on'`` then SWIM removes dead members from the member table after one round."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:199
msgid "Default = ``'on'``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:201
msgid "``uri`` (string or number) -- either an ``'ip:port'`` address, or just a port number (if ip is omitted then 127.0.0.1 is assumed). If ``port == 0``, then the kernel will select any free port for the IP address."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:206
msgid "``uuid`` (string or cdata struct tt_uuid) -- a value which should be unique among SWIM instances. Users may choose any value but the recommendation is: use :ref:`box.cfg.instance_uuid <cfg_replication-instance_uuid>`, the Tarantool instance's UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:212
msgid "All the ``cfg`` components are dynamic -- ``swim_object:cfg()`` may be called more than once. If it is not being called for the first time and a component is not specified, then the component retains its previous value. If it is being called for the first time then uri and uuid are mandatory, since a SWIM instance cannot operate without URI and UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:219
msgid "``swim_object:cfg()`` is atomic -- if there is an error, then nothing changes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:222
msgid "true if configuration succeeds"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:223
#: ../doc/reference/reference_lua/swim.rst:334
#: ../doc/reference/reference_lua/swim.rst:515
#: ../doc/reference/reference_lua/swim.rst:547
msgid "nil, ``err`` if an error occurred. ``err`` is an error object"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:227
msgid "swim_object:cfg({heartbeat_rate = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:231
msgid "After ``swim_object:cfg()``, all other ``swim_object`` methods are callable."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:235
msgid "Expose all non-nil components of the read-only table which was set up or changed by :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:240
msgid "tarantool> swim_object.cfg\n"
"---\n"
"- gc_mode: off\n"
"  uri: 3333\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:253
msgid "Delete a SWIM instance immediately. Its memory is freed, its member table entry is deleted, and it can no longer be used. Other members will treat this member as 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:258
msgid "After ``swim_object:delete()`` any attempt to use the deleted instance will cause an exception to be thrown."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:261
msgid "none, this method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:263
msgid "Example: ``swim_object:delete()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:269
msgid "Return false if a SWIM instance was created via :ref:`swim.new() <swim-new>` without an optional ``cfg`` argument, and was not configured with :ref:`swim_object:cfg() <swim-object_cfg>`. Otherwise return true."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:275
msgid "boolean result, true if configured, otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:277
msgid "Example: ``swim_object:is_configured()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:283
msgid "Return the size of the member table. It will be at least 1 because the \"self\" member is included."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:286
msgid "integer size"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:288
msgid "Example: ``swim_object:size()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:294
msgid "Leave the cluster."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:296
msgid "This is a graceful equivalent of :ref:`swim_object:delete() <swim-delete>` -- the instance is deleted, but before deletion it sends to each member in its member table a message, that this instance has left the cluster, and should not be considered dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:302
msgid "Other instances will mark such a member in their tables as 'left', and drop it after one round of dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:306
msgid "Consequences to the caller are the same as after ``swim_object:delete()`` -- the instance is no longer usable, and an error will be thrown if there is an attempt to use it."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:310
msgid "none, the method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:312
msgid "Example: ``swim_object:quit()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:318
msgid "Explicitly add a member into the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:320
msgid "This method is useful when a new member is joining the cluster and does not yet know what members already exist. In that case it can start interaction explicitly by adding the details about an already-existing member into its member table. Subsequently SWIM will discover other members automatically via messages from the already-existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:328
msgid "description of the member"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:330
msgid "The ``cfg`` table has two mandatory components, ``uuid`` and ``uri``, which have the same format as ``uuid`` and ``uri`` in the table for :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:333
msgid "true if member is added"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:338
msgid "swim_member_object = swim_object:add_member({uuid = ..., uri = ...})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:346
msgid "Explicitly and immediately remove a member from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:349
#: ../doc/reference/reference_lua/swim.rst:707
msgid "UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:351
msgid "true if member is removed"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:352
#: ../doc/reference/reference_lua/swim.rst:374
#: ../doc/reference/reference_lua/swim.rst:394
msgid "nil, ``err`` if an error occurred. ``err`` is an error object."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:354
msgid "Example: ``swim_object:delete('00000000-0000-1000-8000-000000000001')``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:360
msgid "Send a ping request to the specified ``uri`` address. If another member is listening at that address, it will receive the ping, and respond with an ACK (acknowledgment) message containing information such as UUID. That information will be added to the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:366
msgid "``swim_object:probe_member()`` is similar to :ref:`swim_object:add_member() <swim-add_member>`, but it does not require UUID, and it is not reliable because it uses UDP."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:370
msgid "URI. Format is the same as for ``uri`` in :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:373
msgid "true if member is pinged"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:376
msgid "Example: ``swim_object:probe_member(3333)``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:382
msgid "Broadcast a ping request to all the network interfaces in the system."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:385
msgid "``swim_object:broadcast()`` is like :ref:`swim_object:probe_member() <swim-probe_member>` to many members at once."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:389
msgid "All the sent ping requests have this port as destination port in their UDP headers. By default a currently bound port is used."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:393
msgid "true if broadcast is sent"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:398
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 3334, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> s1:probe_member(s2:self():uri())\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:broadcast(3334)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:499
msgid "Set a payload, as formatted data."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:501
msgid "Payload is arbitrary user defined data up to 1200 bytes in size and disseminated over the cluster. So each cluster member will eventually learn what is the payload of other members in the cluster, because it is stored in the member table and can be queried with :ref:`swim_member_object:payload() <swim-payload>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:507
msgid "Different members may have different payloads."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:509
msgid "Arbitrary Lua object to disseminate. Set to nil to remove the payload, in which case it will be eventually removed on other instances. The object is serialized in MessagePack."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:514
#: ../doc/reference/reference_lua/swim.rst:546
msgid "true if payload is set"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:519
msgid "swim_object:set_payload({field1 = 100, field2 = 200})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:527
msgid "Set a payload, as raw data."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:529
msgid "Sometimes a payload does not need to be a Lua object. For example, a user may already have a well formatted MessagePack object and just wants to set it as a payload. Or cdata needs to be exposed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:534
msgid "``set_payload_raw`` allows setting a payload as is, without MessagePack serialization."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:537
msgid "any value"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:539
msgid "Payload size in bytes. If ``payload`` is string then ``size`` is optional, and if specified, then should not be larger than actual ``payload`` size. If ``size`` is less than actual ``payload`` size, then only the first ``size`` bytes of ``payload`` are used. If ``payload`` is cdata then ``size`` is mandatory."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:551
msgid "tarantool> tarantool> ffi = require('ffi')\n"
"---\n"
"...\n"
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:set_payload({a = 100, b = 200})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s2:set_payload('any payload')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1_view = s2:member_by_uuid(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s2_view = s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1_view:payload()\n"
"---\n"
"- {'a': 100, 'b': 200}\n"
"...\n"
"tarantool> s2_view:payload()\n"
"---\n"
"- any payload\n"
"...\n"
"tarantool> cdata = ffi.new('char[?]', 2)\n"
"---\n"
"...\n"
"tarantool> cdata[0] = 1\n"
"---\n"
"...\n"
"tarantool> cdata[1] = 2\n"
"---\n"
"...\n"
"tarantool> s1:set_payload_raw(cdata, 2)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> cdata, size = s1_view:payload_cdata()\n"
"---\n"
"...\n"
"tarantool> cdata[0]\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> cdata[1]\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> size\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:633
msgid "Enable encryption for all following messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:635
msgid "For a brief description of encryption algorithms see \"enum_crypto_algo\" and \"enum crypto_mode\" in the Tarantool source code file `crypto.h <https://github.com/tarantool/tarantool/blob/master/src/lib/crypto/crypto.h>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:640
msgid "When encryption is enabled, all the messages are encrypted with a chosen private key, and a randomly generated and updated public key."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:644
msgid "description of the encryption"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:646
msgid "The components of the ``codec_cfg`` table may be:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:648
msgid "``algo`` (string) -- encryption algorithm name. All the names in :ref:`module crypto <crypto>` are supported: 'aes128', 'aes192', 'aes256', 'des'. Specify 'none' to disable encryption."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:653
msgid "``mode`` (string) -- encryption algorithm mode. All the modes in module ``crypto`` are supported: 'ecb', 'cbc', 'cfb', 'ofb'. Default = 'cbc'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:657
msgid "``key`` (cdata or string) -- a private secret key which is kept secret and should never be stored hard-coded in source code."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:660
msgid "``key_size`` (integer) -- size of the key in bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:662
msgid "``key_size`` is mandatory if key is cdata."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:664
msgid "``key_size`` is optional if key is string, and if ``key_size`` is shorter than than actual key size then the key is truncated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:668
msgid "All of ``algo``, ``mode``, ``key``, and ``key_size`` should be the same for all SWIM instances, so that members can understand each others' messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:672
msgid "Example;"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:674
msgid "tarantool> tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> s1:set_codec({algo = 'aes128', mode = 'cbc', key = '1234567812345678'})\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:691
msgid "Return a :ref:`swim member object <swim-member_object>` (of self) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:695
msgid ":ref:`swim member object <swim-member_object>`, not nil because self() will not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:697
msgid "Example: ``swim_member_object = swim_object:self()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:703
msgid "Return a :ref:`swim member object <swim-member_object>` (given UUID) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:709
msgid ":ref:`swim member object <swim-member_object>`, or nil if not found"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:713
msgid "swim_member_object = swim_object:member_by_uuid('00000000-0000-1000-8000-000000000001')"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:721
msgid "Set up an iterator for returning :ref:`swim member objects <swim-member_object>` from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:726
msgid "``swim_object:pairs()`` should be in a 'for' loop, and there should only be one iterator in operation at one time. (The iterator is implemented in an extra light fashion so only one iterator object is available per SWIM instance.)"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:731
msgid "as for any Lua pairs() iterators. generator function, iterator object (a swim member object), and initial key (a UUID)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:738
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:self()\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s1:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:53666\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431865138ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000002\n"
"  payload_size: 0\n"
"...\n"
"tarantool> t = {}\n"
"---\n"
"...\n"
"tarantool> for k, v in s1:pairs() do table.insert(t, {k, v}) end\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- - - 00000000-0000-1000-8000-000000000002\n"
"    - uri: 127.0.0.1:53666\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431865138ULL, version = 1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000002\n"
"      payload_size: 0\n"
"  - - 00000000-0000-1000-8000-000000000001\n"
"    - uri: 127.0.0.1:55845\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000001\n"
"      payload_size: 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:809
msgid "Methods :ref:`swim_object:member_by_uuid() <swim-member_by_uuid>`, :ref:`swim_object:self() <swim-self>`, and :ref:`swim_object:pairs() <swim-pairs>` return swim member objects."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:815
msgid "A swim member object has methods for reading its attributes: :ref:`status() <swim-status>`, :ref:`uuid <swim-uuid>`, :ref:`uri() <swim-uri>`, :ref:`incarnation() <swim-incarnation>`, :ref:`payload_cdata <swim-payload_cdata>`, :ref:`payload_str() <swim-payload_str>`, :ref:`payload() <swim-payload>`, :ref:`is_dropped() <swim-is_dropped>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:830
msgid "Return the status, which may be 'alive', 'suspected', 'left', or 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:833
msgid "string 'alive' | 'suspected' | 'left' | dead'"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:839
msgid "Return the UUID as cdata struct tt_uuid."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:841
msgid "cdata-struct-tt-uuid UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:847
msgid "Return the URI as a string 'ip:port'. Via this method a user can learn a real assigned port, if port = 0 was specified in :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:852
msgid "string ip:port"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:858
msgid "Return a cdata object with the :ref:`incarnation <swim-incarnation_description>`. The cdata object has two attributes: incarnation().generation and incarnation().version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:862
msgid "Incarnations can be compared to each other with any comparison operator (==, <, >, <=, >=, ~=)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:865
msgid "Incarnations, when printed, will appear as strings with both generation and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:868
msgid "cdata incarnation"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:874
msgid "Return member's payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:876
msgid "pointer-to-cdata payload and size in bytes"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:882
msgid "Return payload as a string object. Payload is not decoded. It is just returned as a string instead of cdata. If payload was not specified by :ref:`swim_object:set_payload() <swim-set_payload>` or by :ref:`swim_object:set_payload_raw() <swim-set_payload_raw>`, then its size is 0 and nil is returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:889
msgid "string-object payload, or nil if there is no payload"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:895
msgid "Since the ``swim`` module is a Lua module, a user is likely to use Lua objects as a payload -- tables, numbers, strings etc. And it is natural to expect that :ref:`swim_member_object:payload() <swim-payload>` should return the same object which was passed into :ref:`swim_object:set_payload() <swim-set_payload>` by another instance. ``swim_member_object:payload()`` tries to interpret payload as MessagePack, and if that fails then it returns the payload as a string."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:906
msgid "``swim_member_object:payload()`` caches its result. Therefore only the first call actually decodes cdata payload. All following calls return a pointer to the same result, unless payload is changed with a new incarnation. If payload was not specified (its size is 0), then nil is returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:916
msgid "Returns true if this member object is a stray reference to a member which has already been dropped from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:919
msgid "boolean true if member is dropped, otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:923
msgid "tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> self = s:self()\n"
"---\n"
"...\n"
"tarantool> self:status()\n"
"---\n"
"- alive\n"
"...\n"
"tarantool> self:uuid()\n"
"---\n"
"- 00000000-0000-1000-8000-000000000001\n"
"...\n"
"tarantool> self:uri()\n"
"---\n"
"- 127.0.0.1:56367\n"
"...\n"
"tarantool> self:incarnation()\n"
"---\n"
"- - cdata {generation = 1569354463981551ULL, version = 1ULL}\n"
"...\n"
"tarantool> self:is_dropped()\n"
"---\n"
"- false\n"
"...\n"
"tarantool> s:set_payload_raw('123')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 3\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> s:set_payload({a = 100})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 4\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- !!binary gaFhZA==\n"
"...\n"
"tarantool> self:payload()\n"
"---\n"
"- {'a': 100}\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:989
msgid "Create an \"on_member :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed when a member in the member table is updated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:992
msgid "this will become the trigger function"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:993
msgid "(optional) this will be passed to trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:995
msgid "nil or function pointer."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:997
msgid "The **trigger-function** should have three parameter declarations (Tarantool will pass values for them when it invokes the function):"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1000
msgid "the member which is having the member event,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1001
msgid "the event object,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1002
msgid "the ``ctx`` which will be the same value as what is passed to ``swim_object:on_member_event``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1005
msgid "A **member event** is any of:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1007
msgid "appearance of a new member,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1008
msgid "drop of an existing member, or"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1009
msgid "update of an existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1011
msgid "An **event object** is an object which the trigger-function can use for determining what type of member event has happened. The object's methods -- such as ``is_new_status()``, ``is_new_uri()``, ``is_new_incarnation()``, ``is_new_payload()``, ``is_drop()`` -- return boolean values."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1017
msgid "A member event may have more than one associated **trigger**. Triggers are executed sequentially. Therefore if a trigger function causes yields or sleeps, other triggers may be forced to wait. However, since trigger execution is done in a separate fiber, SWIM itself is not forced to wait."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1024
msgid "Example of an on-member trigger function:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1026
msgid "tarantool> swim = require('swim')\n"
"\n"
"local function on_event(member, event, ctx)\n"
"    if event:is_new() then\n"
"        ...\n"
"    elseif event:is_drop() then\n"
"        ...\n"
"    end\n"
"\n"
"    if event:is_update() then\n"
"        -- All next conditions can be\n"
"        -- true simultaneously.\n"
"        if event:is_new_status() then\n"
"...\n"
"        end\n"
"        if event:is_new_uri() then\n"
"...\n"
"        end\n"
"        if event:is_new_incarnation() then\n"
"...\n"
"        end\n"
"        if event:is_new_payload() then\n"
"...\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1055
msgid "Notice in the above example that the function is ready for the possibility that multiple events can happen simultaneously for a single trigger activation. ``is_new()`` and ``is_drop()`` can not both be true, but ``is_new()`` and ``is_update()`` can both be true, or ``is_drop()`` and ``is_update()`` can both be true. Multiple simultaneous events are especially likely if there are many events and trigger functions are slow -- in that case, for example, a member might be added and then updated after a while, and then after a while there will be a single trigger activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1067
msgid "Also: ``is_new()`` and ``is_new_payload()`` can both be true. This case is not due to trigger functions that are slow. It occurs because \"omitted payload\" and \"size-zero payload\" are not the same thing. For example: when a ping is received, a new member might be added, but ping messages do not include payload. The payload will appear later in a different message. If that is important for the application, then the function should not assume when ``is_new()`` is true that the member already has a payload, and should not assume that payload size says something about the payload's presence or absence."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1078
msgid "Also: functions should not assume that ``is_new()`` and ``is_drop()`` will always be seen. If a new member appears but then is dropped before its appearance has caused a trigger activation, then there will be no trigger activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1084
msgid "``is_new_generation()`` will be true if the generation part of :ref:`incarnation <swim-incarnation_description>` changes. ``is_new_version()`` will be true if the version part of incarnation changes. ``is_new_incarnation()`` will be true if either the generation part or the version part of incarnation changes. For example a combination of these methods can be used within a user-defined trigger to check whether a process has restarted, or a member has changed ..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1094
msgid "swim = require('swim')\n"
"s = swim.new()\n"
"s:on_member_event(function(m, e)\n"
"...\n"
"    if e:is_new_incarnation() then\n"
"        if e:is_new_generation() then\n"
"            -- Process restart.\n"
"        end\n"
"        if e:is_new_version() then\n"
"            -- Process version update. It means\n"
"            -- the member is somehow changed.\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1113
msgid "Delete an on-member trigger."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1115
msgid "old-trigger"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1117
#: ../doc/reference/reference_lua/swim.rst:1132
msgid "The old-trigger value should be the value returned by ``on_member_event(trigger-function[, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1122
msgid "This is a variation of ``on_member_event(new-trigger, [, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1124
msgid "The additional parameter is ``old-trigger``. Instead of adding the new-trigger at the end of a list of triggers, this function will replace the entry in the list of triggers that matches old-trigger. The position within a list may be important because triggers are activated sequentially starting with the first trigger in the list."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1137
msgid "Return the list of on-member triggers."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1141
msgid "SWIM internals"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1143
msgid "The SWIM internals section is not necessary for programmers who wish to use the SWIM module, it is for programmers who wish to change or replace the SWIM module."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1146
msgid "The SWIM wire protocol is open, will be backward compatible in case of any changes, and can be implemented by users who wish to simulate their own SWIM cluster members because they use another language than Lua, or another environment unrelated to Tarantool. The protocol is encoded as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1153
msgid "SWIM packet structure:\n"
"\n"
"+-----------------Public data, not encrypted------------------+\n"
"|                                                             |\n"
"|      Initial vector, size depends on chosen algorithm.      |\n"
"|                   Next data is encrypted.                   |\n"
"|                                                             |\n"
"+----------Meta section, handled by transport level-----------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_META_TARANTOOL_VERSION: uint, Tarantool        |\n"
"|                                      version ID,            |\n"
"|     1 = SWIM_META_SRC_ADDRESS: uint, ip,                    |\n"
"|     2 = SWIM_META_SRC_PORT: uint, port,                     |\n"
"|     3 = SWIM_META_ROUTING: map {                            |\n"
"|         0 = SWIM_ROUTE_SRC_ADDRESS: uint, ip,               |\n"
"|         1 = SWIM_ROUTE_SRC_PORT: uint, port,                |\n"
"|         2 = SWIM_ROUTE_DST_ADDRESS: uint, ip,               |\n"
"|         3 = SWIM_ROUTE_DST_PORT: uint, port                 |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------Protocol logic section--------------------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_SRC_UUID: 16 byte UUID,                        |\n"
"|                                                             |\n"
"|                 AND                                         |\n"
"|                                                             |\n"
"|     2 = SWIM_FAILURE_DETECTION: map {                       |\n"
"|         0 = SWIM_FD_MSG_TYPE: uint, enum swim_fd_msg_type,  |\n"
"|         1 = SWIM_FD_GENERATION: uint,                       |\n"
"|         2 = SWIM_FD_VERSION: uint                           |\n"
"|     },                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     3 = SWIM_DISSEMINATION: array [                         |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     1 = SWIM_ANTI_ENTROPY: array [                          |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     4 = SWIM_QUIT: map {                                    |\n"
"|         0 = SWIM_QUIT_GENERATION: uint,                     |\n"
"|         1 = SWIM_QUIT_VERSION: uint                         |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------------------------------------------------+"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1228
msgid "The **Initial vector section** appears only when encryption is enabled. This section contains a public key. For example, for AES algorithms it is a 16-byte initial vector stored as is. When no encryption is used, the section size is 0."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1233
msgid "The later sections (Meta and Protocol Logic) are encrypted as one big data chunk if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1236
msgid "The **Meta section** handles routing and protocol versions compatibility. It works at the 'transport' level of the SWIM protocol, and is always present. Keys in the meta section are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1240
msgid "SWIM_META_TARANTOOL_VERSION -- mandatory field. Tarantool sets here its version as a 3 byte integer:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1243
msgid "1 byte for major,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1244
msgid "1 byte for minor,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1245
msgid "1 byte for patch."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1247
msgid "For example, Tarantool version 2.1.3 would be encoded like this: ``(((2 << 8) | 1) << 8) | 3;``. This field will be used to support multiple versions of the protocol."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1251
msgid "SWIM_META_SRC_ADDRESS and SWIM_META_SRC_PORT -- mandatory. source IP address and port. IP is encoded as 4 bytes. \"xxx.xxx.xxx.xxx\" where each 'xxx' is encoding of one byte. Port is encoded as an integer. Example of how to encode \"127.0.0.1:3313\":"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1256
msgid "struct in_addr addr;\n"
"inet_aton(\"127.0.0.1\", &addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_ADDRESS);\n"
"pos = mp_encode_uint(pos, addr->s_addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_PORT);\n"
"pos = mp_encode_uint(pos, 3313);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1265
msgid "SWIM_META_ROUTING subsection -- not mandatory. Responsible for packet forwarding. Used by SWIM suspicion mechanism. Read about suspicion in the SWIM paper."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1269
msgid "If this subsection is present then the following fields are mandatory:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1272
msgid "SWIM_ROUTE_SRC_ADDRESS and SWIM_ROUTE_SRC_PORT (source IP address and port) (should be an address of the message originator (can differ from"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1275
msgid "SWIM_META_SRC_ADDRESS and from SWIM_META_SRC_ADDRESS_PORT);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1276
msgid "SWIM_ROUTE_DST_ADDRESS and SWIM_ROUTE_DST_PORT (destination IP address and port, for the the message's final destination)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1279
msgid "If a message was sent indirectly with the help of SWIM_META_ROUTING, then the reply should be sent back by the same route."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1282
msgid "For an example of how SWIM uses routing for indirect pings ... Assume there are 3 nodes: S1, S2, S3. S1 sends a message to S3 via S2. The following steps are executed in order to deliver the message:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1287
msgid "S1 -> S2\n"
"{ src: S1, routing: {src: S1, dst: S3}, body: ... }"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1292
msgid "S2 receives the message and sees that routing.dst is not equal to S2, so it is a foreign packet. S2 forwards the packet to S3 preserving all the data including body and routing sections."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1296
msgid "S2 -> S3"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1300
msgid "S3 receives the message and sees that routing.dst is equal to S3, so the message is delivered. If S3 wants to answer, it sends a response via the same proxy. It knows that the message was delivered from S2, so it sends an answer via S2."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1305
msgid "The **Protocol logic section** handles SWIM logical protocol steps and actions."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1307
msgid "SWIM_SRC_UUID -- mandatory field. SWIM uses UUID as a unique identifier of a member, not IP/port. This field stores UUID of sender. Its type is MP_BIN. Size is always 16 bytes. UUID is encoded in host byte order, no bswaps are needed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1312
msgid "Following SWIM_SRC_UUID there are four possible subsections: SWIM_FAILURE_DETECTION, SWIM_DISSEMINATION, SWIM_ANTI_ENTROPY, SWIM_QUIT. Any or all of these subsections may be present. A connector should be ready to handle any combination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1317
msgid "SWIM_FAILURE_DETECTION subsection -- describes a ping or ACK. In the SWIM_FAILURE_DETECTION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1320
msgid "SWIM_FD_MSG_TYPE (0 is ping, 1 is ack);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1321
msgid "SWIM_FD_GENERATION + SWIM_FD_VERSION (the :ref:`incarnation <swim-incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1323
msgid "SWIM_DISSEMINATION subsection -- a list of changed cluster members. It may include only a subset of changed cluster members if there are too many changes to fit into one UDP packet."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1327
msgid "In the SWIM_DISSEMINATION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1329
msgid "SWIM_MEMBER_STATUS (mandatory) (0 = alive, 1 = suspected, 2 = dead, 3 = left);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1330
msgid "SWIM_MEMBER_ADDRESS and SWIM_MEMBER_PORT (mandatory) member IP and port;"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1331
msgid "SWIM_MEMBER_UUID (mandatory) (member UUID);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1332
msgid "SWIM_MEMBER_GENERATION + SWIM_MEMBER_VERSION (mandatory) (the member :ref:`incarnation <swim-incarnation_description>`);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1333
msgid "SWIM_MEMBER_PAYLOAD (not mandatory) (member payload) (MessagePack type is MP_BIN)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1336
msgid "Note that absence of SWIM_MEMBER_PAYLOAD means nothing - it is not the same as a payload with zero size."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1339
msgid "SWIM_ANTI_ENTROPY subsection -- a helper for the dissemination. It contains all the same fields as the dissemination sub, but all of them are mandatory, including payload even when payload size is 0. Anti-entropy eventually spreads changes which for any reason are not spread by the dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1345
msgid "SWIM_QUIT subsection -- statement that the sender has left the cluster gracefully, for example via :ref:`swim_object:quit() <swim-quit>`, and should not be considered dead. Sender status should be changed to 'left'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1350
msgid "In the SWIM_QUIT subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1352
msgid "SWIM_QUIT_GEMERATOPM + SWIM_QUIT_VERSION (the sender :ref:`incarnation <swim-incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1356
msgid "The **incarnation** is a 128-bit cdata value which is part of each member's configuration and is present in most messages. It has two parts: generation and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1360
msgid "Generation is persistent. By default it has the number of microseconds since the epoch (compare the value returned by :ref:`clock_realtime64() <clock-time>`). Optionally a user can set generation during :ref:`new() <swim-new>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1365
msgid "Version is volatile. It is initially 0. It is incremented automatically every time that a change occurs."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1368
msgid "The incarnation, or sometimes the version alone, is useful for deciding to ignore obsolete messages, for updating a member's attributes on remote nodes, and for refuting messages that say a member is dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1373
msgid "If the member's incarnation is less than the locally stored incarnation, then the message is obsolete. This can happen because UDP allows reordering and duplication."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1377
msgid "If the member's incarnation in a message is greater than the locally stored incarnation, then most of its attributes  (IP, port, status) should be updated with the values received in the message. However, the payload attribute should not be updated unless it is present in the message. Because of its relatively large size, payload is not always included in every message."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1384
msgid "Refutation usually happens when a false-positive failure detection has happened. In such a case the member thought to be dead receives that information from other members, increases its own incarnation, and spreads a message saying the member is alive (a \"refutation\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1390
msgid "Note: in the original version of Tarantool SWIM, and in the original SWIM specification, there is no generation and the incarnation consists of only the version. Generation was added because it is useful for detecting obsolete messages left over from a previous life of an instance that has restarted."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:5
msgid "Module `table`"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:9
msgid "The :code:`table` module has everything in the `standard Lua table library <https://www.lua.org/pil/19.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:13
msgid "You can see this by saying \"table\": you will see this list of functions: ``clear`` (LuaJIT extension = erase all elements), `concat <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ (concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see description below), ``foreach``, ``foreach1``, `getn <https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-table.insert>`_ (insert an element into an array), `maxn <https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ (move elements between tables), ``new`` (LuaJIT extension = return a new table with pre-allocated elements), `remove <https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove an element from an array), `sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the elements of an array)."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:28
msgid "In this section we only discuss the additional function that the Tarantool developers have added: ``deepcopy``."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:35
msgid "Return a \"deep\" copy of the table -- a copy which follows nested structures to any depth and does not depend on pointers, it copies the contents."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:39
msgid "(table) the table to copy"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:41
msgid "the copy of the table"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:46
msgid "tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:67
msgid "Put the input-table contents in sorted order."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:69
msgid "The `basic Lua table.sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ has a default comparison-function: :code:`function (a, b) return a < b end`."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:72
msgid "That is efficient and standard. However, sometimes Tarantool users will want an equivalent to ``table.sort`` which has any of these features:"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:75
msgid "(1) If the table contains nils, except nils at the end, the results must still be correct. That is not the case with the default tarantool_sort, and it cannot be fixed by making a comparison that checks whether a and b are nil. (Before trying certain Internet suggestions, test with {1, nil, 2, -1, 44, 1e308, nil, 2, nil, nil, 0}."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:81
msgid "(2) If strings are to be sorted in a language-aware way, there must be a parameter for collation."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:84
msgid "(3) If the table has a mix of types, then they must be sorted as booleans, then numbers, then strings, then byte arrays."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:87
msgid "Since all those features are available in Tarantool spaces, the solution for Tarantool is simple: make a temporary Tarantool space, put the table contents into it, retrieve the tuples from it in order, and overwrite the table."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:92
msgid "Here then is ``tarantool_sort()`` which does the same thing as ``table.sort`` but has those extra features. It is not fast and it requires a database privilege, so it should only be used if the extra features are necessary."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:97
msgid "  function tarantool_sort(input_table, collation)\n"
"      local c = collation or 'binary'\n"
"      local tmp_name = 'Temporary_for_tarantool_sort'\n"
"      pcall(function() box.space[tmp_name]:drop() end)\n"
"      box.schema.space.create(tmp_name, {temporary = true})\n"
"      box.space[tmp_name]:create_index('I')\n"
"      box.space[tmp_name]:create_index('I2',\n"
"                                       {unique = false,\n"
"                                        type='tree',\n"
"                                        parts={{2, 'scalar',\n"
"                                                collation = c,\n"
"                                                is_nullable = true}}})\n"
"      for i = 1, table.maxn(input_table) do\n"
"          box.space[tmp_name]:insert{i, input_table[i]}\n"
"      end\n"
"      local t = box.space[tmp_name].index.I2:select()\n"
"      for i = 1, table.maxn(input_table) do\n"
"          input_table[i] = t[i][2]\n"
"      end\n"
"      box.space[tmp_name]:drop()\n"
"    end\n"
"\n"
"For example, suppose table t = {1, 'A', -88.3, nil, true, 'b', 'B', nil, 'À'}.\n"
"After tarantool_sort(t, 'unicode_ci') t contains {nil, nil, true, -88.3, 1, 'A', 'À', 'b', 'B'}."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:3
msgid "Module `tap`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:9
msgid "The ``tap`` module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:27
msgid ":ref:`tap.test() <tap-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:27
msgid "Initialize"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:30
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:30
msgid "Create a subtest and print the results"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:33
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:33
msgid "Indicate how many tests to perform"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:36
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:36
msgid "Check the number of tests performed"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:39
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:39
msgid "Display a diagnostic message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:42
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:42
#: ../doc/reference/reference_lua/tap.rst:45
#: ../doc/reference/reference_lua/tap.rst:48
msgid "Evaluate the condition and display the message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:45
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:48
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:51
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:51
msgid "Check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:54
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:54
msgid "Check if the two arguments are different"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:57
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:57
msgid "Recursively check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:60
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:60
msgid "Check if the argument matches a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:63
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:63
msgid "Check if the argument does not match a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:66
msgid ":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() <taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| :ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() <taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| :ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:72
msgid "Check if a value has a particular type"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:81
msgid ":ref:`taptest.strict <taptest-strict>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:81
msgid "Flag, true if comparisons with nil should be strict"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:91
msgid "Initialize."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:93
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:97
#: ../doc/reference/reference_lua/tap.rst:118
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:98
#: ../doc/reference/reference_lua/tap.rst:120
msgid "taptest"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:101
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:112
msgid "Create a subtest (if no ``func`` argument specified), or (if all arguments are specified) create a subtest, run the test function and print the result."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:116
msgid "See the :ref:`example <tap-example>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:119
msgid "the test logic to run."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:121
msgid "userdata or string"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:127
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:136
msgid "Checks the number of tests performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:138
msgid "The result will be a display saying ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" messages are out of the TAP13 standard.)"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:143
msgid "This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script. However, as a Tarantool extension, ``taptest:check()`` may appear at the end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:148
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:149
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:150
msgid "or by calling taptest:test('...', subtest-function-name) where subtest-function-name does not need to end with ``taptest:check()`` because it can be called after the subtest is complete."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:161
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:163
msgid "the message to be displayed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:170
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:174
msgid "an expression which is true or false"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:175
#: ../doc/reference/reference_lua/tap.rst:209
#: ../doc/reference/reference_lua/tap.rst:222
#: ../doc/reference/reference_lua/tap.rst:245
#: ../doc/reference/reference_lua/tap.rst:257
#: ../doc/reference/reference_lua/tap.rst:274
#: ../doc/reference/reference_lua/tap.rst:289
#: ../doc/reference/reference_lua/tap.rst:303
#: ../doc/reference/reference_lua/tap.rst:322
msgid "name of the test"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:182
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:206
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:218
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:228
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:240
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:243
#: ../doc/reference/reference_lua/tap.rst:255
#: ../doc/reference/reference_lua/tap.rst:272
#: ../doc/reference/reference_lua/tap.rst:287
#: ../doc/reference/reference_lua/tap.rst:301
msgid "actual result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:244
#: ../doc/reference/reference_lua/tap.rst:256
#: ../doc/reference/reference_lua/tap.rst:273
msgid "expected result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:253
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:266
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:280
msgid "Verify a string against a `pattern <http://lua-users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:288
#: ../doc/reference/reference_lua/tap.rst:302
msgid "pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:291
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:299
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:318
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:331
msgid "Set ``taptest.strict=true`` if :ref:`taptest:is() <taptest-is>` and :ref:`taptest:isnt() <taptest-isnt>` and :ref:`taptest:is_deeply() <taptest-is_deeply>` must be compared strictly with ``nil``. Set ``taptest.strict=false`` if ``nil`` and ``box.NULL`` both have the same effect. The default is false. For example, if and only if ``taptest.strict=true`` has happened, then ``taptest:is_deeply({a = box.NULL}, {})`` will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:350
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:354
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:368
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:370
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:5
msgid "Module `tarantool`"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:9
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:15
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info() <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:22
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- version: 2.3.0-3-g302bb3241\n"
"  build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/opt/tarantool-install\n"
"-DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fexceptions -funwind-tables -fno-omit-frame-pointer\n"
"-fno-stack-protector\n"
"      -fno-common -fopenmp -msse2 -std=c11 -Wall -Wextra\n"
"-Wno-strict-aliasing -Wno-char-subscripts\n"
"      -Wno-format-truncation -fno-gnu89-inline -Wno-cast-function-type'\n"
"    compiler: /usr/bin/cc /usr/bin/c++\n"
"  pid: 'function: 0x40016cd0'\n"
"  package: Tarantool\n"
"  uptime: 'function: 0x40016cb0'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:3
msgid "Module `uri`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:9
msgid "A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:13
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:17
msgid "A common type, a hierarchical URI, looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:19
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:23
msgid "For example the string ``'https://tarantool.org/x.html#y'`` has three components:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:26
msgid "``https`` is the scheme,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:27
msgid "``tarantool.org/x.html`` is the path,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:28
msgid "``y`` is the fragment."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:30
msgid "Tarantool's URI module provides routines which convert URI strings into their components, or turn components into URI strings."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:37
msgid "Below is a list of all ``uri`` functions."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid "Get a table of URI components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid ":ref:`uri.format() <uri-format>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid "Construct a URI from components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:60
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:61
msgid "URI-components-table. Possible components are fragment, host, login, password, path, query, scheme, service."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:63
msgid "Table"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:67
msgid "tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:84
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:86
msgid "boolean. If this is supplied and is ``true``, then the password component is rendered in clear text, otherwise it is omitted."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:89
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:94
msgid "tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:5
msgid "Module `utf8`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:11
msgid "``utf8`` is Tarantool's module for handling UTF-8 strings. It includes some functions which are compatible with ones in `Lua 5.3 <https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much more. For example, because internally Tarantool contains a complete copy of the \"International Components For Unicode\" library, there are comparison functions which understand the default ordering for Cyrillic (Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = Katakana A)."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:29
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:29
msgid "Comparisons"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:32
msgid ":ref:`lower <utf8-lower>` and |br| :ref:`upper <utf8-upper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:32
msgid "Case conversions"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:35
msgid ":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| :ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:35
msgid "Determine character types"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:40
msgid ":ref:`sub <utf8-sub>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:40
msgid "Substrings"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid ":ref:`len <utf8-len>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid "Length in characters"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid ":ref:`next <utf8-next>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid "Character-at-a-time iterations"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:53
#: ../doc/reference/reference_lua/utf8.rst:114
#: ../doc/reference/reference_lua/utf8.rst:235
#: ../doc/reference/reference_lua/utf8.rst:272
#: ../doc/reference/reference_lua/utf8.rst:289
#: ../doc/reference/reference_lua/utf8.rst:348
msgid "a string encoded with UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:54
#: ../doc/reference/reference_lua/utf8.rst:115
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:57
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code-point values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:64
msgid "The comparison is done with primary weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are ignored. If asked \"is this like a Microsoft case-insensitive accent-insensitive collation\" we tend to answer \"yes\", though the Unicode Collation Algorithm is far more sophisticated than those terms imply."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:74
msgid "tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:86
msgid "a Unicode code point value, repeatable"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:87
msgid "a UTF-8 string"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:90
msgid "The code-point number is the value that corresponds to a character in the `Unicode Character Database <http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not the same as the byte values of the encoded character, because the UTF-8 encoding scheme is more complex than a simple copy of the code-point number."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:97
msgid "Another way to construct a string with Unicode characters is with the \\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and ``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:103
msgid "tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:118
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:125
msgid "The comparison is done with at least three weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are not ignored. and upper case comes after lower case."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:132
msgid "tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:144
#: ../doc/reference/reference_lua/utf8.rst:169
#: ../doc/reference/reference_lua/utf8.rst:191
#: ../doc/reference/reference_lua/utf8.rst:213
msgid "a single UTF8 character, expressed as a one-byte string or a code point value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:149
msgid "Return true if the input character is an \"alphabetic-like\" character, otherwise return false. Generally speaking a character will be considered alphabetic-like provided it is typically used within a word, as opposed to a digit or punctuation. It does not have to be a character in an alphabet."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:156
msgid "tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:174
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:178
msgid "tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:196
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:200
msgid "tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:218
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:222
msgid "tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:236
msgid "byte position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:237
msgid "byte position where to stop"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:238
msgid "the number of characters in the string, or between start and end"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:241
msgid "Byte positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:244
msgid "If the string contains a byte sequence which is not valid in UTF-8, each byte in the invalid byte sequence will be counted as one character."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:247
msgid "UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese character takes three bytes, and the maximum is four bytes."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:254
msgid "tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:273
msgid "the same string, lower case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:278
msgid "tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:290
msgid "byte position where to start within the string, default is 1"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:291
msgid "byte position of the next character and the code point value of the next character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:294
msgid "The ``next`` function is often used in a loop to get one character at a time from a UTF-8 string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:299
msgid "In the string 'åa' the first character is 'å', it starts at position 1, it takes two bytes to store so the character after it will be at position 3, its Unicode code point value is (decimal) 229."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:304
msgid "tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) end\n"
"229\n"
"97\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:322
msgid "a string encoded as UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:323
msgid "the position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:324
msgid "the position of the last character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:325
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:328
msgid "Character positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:331
msgid "The default value for end-character is the length of the input string. Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as the input string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:337
msgid "tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:349
msgid "the same string, upper case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:354
msgid "In rare cases the upper-case result may be longer than the lower-case input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:359
msgid "tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:3
msgid "Module `uuid`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:9
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:19
msgid "Below is list of all ``uuid`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
#: ../doc/reference/reference_lua/uuid.rst:54
msgid "A nil object"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:31
msgid ":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| :ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:32
msgid "Get a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:35
msgid ":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| :ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:38
msgid "Get a converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid "Check if a UUID is an all-zero value"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:60
#: ../doc/reference/reference_lua/uuid.rst:67
#: ../doc/reference/reference_lua/uuid.rst:74
msgid "a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:68
msgid "16-byte string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:75
msgid "36-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:81
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:82
#: ../doc/reference/reference_lua/uuid.rst:90
msgid "converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:89
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:99
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:101
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:102
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:103
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:104
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:106
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:108
#: ../doc/reference/reference_lua/uuid.rst:115
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:109
msgid "16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:116
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:122
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:127
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:128
msgid "bool"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:134
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:5
msgid "Module `xlog`"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:7
msgid "The xlog module contains one function: ``pairs()``. It can be used to read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-log (WAL) <internals-wal>` files. A description of the file format is in section :ref:`Data persistence and the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:19
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:21
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:22
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:24
msgid "Possible errors: File does not contain properly formatted snapshot or write-ahead-log information."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:29
msgid "This will read the first write-ahead-log (WAL) file that was created in the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" exercises <getting_started>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:33
msgid "Each result from ``pairs()`` is formatted with MsgPack so its structure can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:36
msgid "xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:45
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:47
msgid "(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:5
msgid "Module `yaml`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:11
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:18
msgid "Below is a list of all ``yaml`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid "Convert a Lua object to a YAML string"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid "Convert a YAML string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:34
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:44
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:47
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:54
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:56
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:70
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:93
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:96
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:97
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:104
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:140
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:2
msgid "Cartridge Command Line Interface"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:5
#: ../doc/reference/reference_rock/dbms.rst:53
#: ../doc/reference/reference_rock/dbms.rst:406
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:11
msgid "Installation"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:10
msgid "tarantoolctl rocks install cartridge-cli"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:11
msgid "Optionally you may add ``.rocks/bin`` to executable path:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:16
msgid "export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:18
msgid "Usage"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:20
msgid "For more details, run"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:25
msgid "cartridge --help"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:27
msgid "Applications lifecycle"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:29
msgid "Create an application from template:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:34
msgid "cartridge create --name myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:35
msgid "Pack an application into distributable:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:40
msgid "cartridge pack rpm myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:42
msgid "Managing instances"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:80
msgid "cartridge start [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"Options\n"
"    --script FILE       Application's entry point.\n"
"                        Default to TARANTOOL_SCRIPT,\n"
"                        or ./init.lua when running from app's directory,\n"
"                        or :apps_path/:app_name/init.lua in multi-app env.\n"
"\n"
"    --apps_path PATH    Path to apps direcrory when running in multi-app env.\n"
"                        Default to /usr/share/tarantool\n"
"\n"
"    --run_dir DIR       Directory with pid and sock files\n"
"                        Default to TARANTOOL_RUN_DIR or /var/run/tarantool\n"
"\n"
"    --cfg FILE          Cartridge instances config file.\n"
"                        Default to TARANTOOL_CFG or ./instances.yml\n"
"\n"
"    --foreground        Do not daemonize"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:65
msgid "It starts tarantool instance in background with enforced env-vars and waits until app’s main script is finished."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:104
msgid "TARANTOOL_INSTANCE_NAME\n"
"TARANTOOL_CFG\n"
"TARANTOOL_PID_FILE - %run_dir%/%instance_name%.pid\n"
"TARANTOOL_CONSOLE_SOCK - %run_dir%/%instance_name%.pid"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:75
msgid "``cartridge.cfg()`` uses ``TARANTOOL_INSTANCE_NAME`` to read instance’s config from file provided in ``TARANTOOL_CFG``."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:78
msgid "Default options for ``cartridge`` command can be overriden in ``./.cartridge.yml`` or ``~/.cartridge.yml``:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:86
msgid "run_dir: tmp/run\n"
"cfg: cartrifge.yml\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:87
msgid "When APP_NAME is not provided it is parsed from ``./*.rockspec`` filename. When ``INSTANCE_NAME`` is not provided cartridge reads ``cfg`` file and starts all defined instances:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:127
msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start app_1 # starts all instances of app_1\n"
"cartridge start app_1.router_1 # start single instance"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:101
msgid "To stop one or more running instances use:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:139
msgid "cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"These options from `start` command are supported\n"
"    --run_dir DIR\n"
"    --cfg FILE"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:112
msgid "Misc"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:115
msgid "Running end-to-end tests"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:121
msgid "vagrant up\n"
"vagrant ssh 1_10 < test/end-to-end.sh\n"
"vagrant halt"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:5
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:7
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:11
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:16
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:19
msgid "The Tarantool rocks allow for connecting to SQL servers and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:30
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:38
msgid "MySQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:40
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:47
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server instance. After that, one can pass any MySQL statement to the server instance and receive results, including multiple result sets."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:55
#: ../doc/reference/reference_rock/dbms.rst:408
msgid "Check the instructions for `downloading and installing a binary package <http://tarantool.org/download.html>`_ that apply for the environment where Tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:61
#: ../doc/reference/reference_rock/dbms.rst:414
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:65
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:69
#: ../doc/reference/reference_rock/dbms.rst:422
msgid "With LuaRocks"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:71
#: ../doc/reference/reference_rock/dbms.rst:424
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:84
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:90
#: ../doc/reference/reference_rock/dbms.rst:443
msgid "With GitHub"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:92
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:94
msgid "$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:101
#: ../doc/reference/reference_rock/dbms.rst:454
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:107
#: ../doc/reference/reference_rock/dbms.rst:460
msgid "Connecting"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:109
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:116
#: ../doc/reference/reference_rock/dbms.rst:469
msgid "Now, say:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:123
#: ../doc/reference/reference_rock/dbms.rst:476
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:125
#: ../doc/reference/reference_rock/dbms.rst:478
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:126
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:127
#: ../doc/reference/reference_rock/dbms.rst:480
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:128
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:129
#: ../doc/reference/reference_rock/dbms.rst:482
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:130
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:132
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:139
#: ../doc/reference/reference_rock/dbms.rst:486
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:141
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:157
#: ../doc/reference/reference_rock/dbms.rst:498
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:159
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:175
#: ../doc/reference/reference_rock/dbms.rst:517
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:179
#: ../doc/reference/reference_rock/dbms.rst:521
msgid "How to ping"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:181
#: ../doc/reference/reference_rock/dbms.rst:523
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:220
#: ../doc/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:190
#: ../doc/reference/reference_rock/dbms.rst:532
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:199
#: ../doc/reference/reference_rock/dbms.rst:541
msgid "Executing a statement"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:201
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:240
#: ../doc/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:208
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:214
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:227
#: ../doc/reference/reference_rock/dbms.rst:568
msgid "Closing connection"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:229
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:268
#: ../doc/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:238
#: ../doc/reference/reference_rock/dbms.rst:579
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:244
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:251
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:255
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.1\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.1.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.1.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:336
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:339
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:347
msgid "Create a Lua function that will connect to the MySQL server instance, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:352
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:376
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:383
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:385
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:390
msgid "$ sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:394
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:400
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server instance. After that, one can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:418
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:437
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:445
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:447
msgid "$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:462
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "pg = require('pg')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:479
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:481
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:484
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:488
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:500
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:543
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:550
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any placeholders ($1 $2 $3 etc.) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:556
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:570
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:585
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:592
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:596
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.0\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.0.4.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.0.4-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:670
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:673
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:681
msgid "Create a Lua function that will connect to a PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:686
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:711
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:5
msgid "Module `expirationd`"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:7
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at the source code of ``expirationd``, which Tarantool supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:13
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:21
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:26
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:37
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:42
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:56
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:66
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:71
msgid "At this point, if the above explanation is worthwhile, it is clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and -- whenever it finds a tuple that has expired -- deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:80
msgid "For those who like to see things run, here are the exact steps to get ``expirationd`` through the test."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:83
msgid "Get ``expirationd.lua``. There are standard ways -- it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ -- but for this purpose just copy the contents of ``expirationd.lua`` to a directory on the Lua path (type ``print(package.path)`` to see the Lua path)."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:88
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:89
msgid "Execute these requests:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:91
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:114
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:119
msgid "The function which will be supplied to ``expirationd`` is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:124
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The require_ function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel, but is on the Lua path (``package.path``) or the C path (``package.cpath``). After the Lua variable expd has been assigned the value of the ``expirationd`` module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:133
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:138
msgid "After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the ``is_tuple_expired()`` function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:145
msgid "Of course, ``expirationd`` can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code. Particularly important are ``{options}`` which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:150
msgid "``force`` (boolean) -- run task even on replica. Default: ``force=false`` so ordinarily ``expirationd`` ignores replicas."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:152
msgid "``tuples_per_iteration`` (integer) -- number of tuples that will be checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:155
msgid "``full_scan_time`` (number) -- number of seconds required for full index scan Default: ``full_scan_time=3600``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:157
msgid "``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:160
msgid "``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. (The size of a vinyl space cannot be easily calculated, so on the first iteration it will be the \"assumed\" size, on the second iteration it will be \"assumed\" times \"factor\", on the third iteration it will be \"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:3
msgid "Rocks reference"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:5
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:5
msgid "Module `membership`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:7
msgid "This module is a ``membership`` library for Tarantool based on a gossip protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:9
msgid "This library builds a mesh from multiple Tarantool instances. The mesh monitors itself, helps members discover everyone else in the group and get notified about their status changes with low latency. It is built upon the ideas from Consul or, more precisely, the SWIM algorithm."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:14
msgid "The ``membership`` module works over UDP protocol and can operate even before the ``box.cfg`` initialization."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:21
msgid "Member data structure"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:23
msgid "A member is represented by the table with the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:25
msgid "``uri`` (string) is a Uniform Resource Identifier."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:26
msgid "``status`` (string) is a string that takes one of the values below."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:28
msgid "``alive``: a member that replies to ping-messages is ``alive`` and well."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:29
msgid "``suspect``: if any member in the group cannot get a reply from any other member, the first member asks three other ``alive`` members to send a ping-message to the member in question. If there is no response, the latter becomes a ``suspect``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:33
msgid "``dead``: a ``suspect`` becomes ``dead`` after a timeout."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:34
msgid "``left``: a member gets the ``left`` status after executing the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:37
msgid "The gossip protocol guarantees that every member in the group becomes aware of any status change in two communication cycles."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:40
msgid "``incarnation`` (number) is a value incremented every time the instance is becomes a ``suspect``, ``dead``, or updates its payload."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:42
msgid "``payload`` (table) is auxiliary data that can be used by various modules."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:43
msgid "``timestamp`` (number) is a value of ``fiber.time64()`` which:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:45
msgid "corresponds to the last update of ``status`` or ``incarnation``;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:46
msgid "is always local;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:47
msgid "does not depend on other members' clock setting."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:49
msgid "Below is an example of the table:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:51
msgid "tarantool> membership.myself()\n"
"---\n"
"uri: localhost:33001\n"
"status: alive\n"
"incarnation: 1\n"
"payload:\n"
"    uuid: 2d00c500-2570-4019-bfcc-ab25e5096b73\n"
"timestamp: 1522427330993752\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:67
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:196
msgid "API reference"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:69
msgid "Below is a list of ``membership``'s common, encryption, subscription functions, and options."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:80
msgid "Common functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid ":ref:`init(advertise_host, port) <membership-init>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid "Initialize the ``membership`` module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid ":ref:`myself() <membership-myself>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid "Get the member data structure of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid ":ref:`get_member(uri) <membership-get-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid "Get the member data structure for a given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid ":ref:`members() <membership-members>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid "Obtain a table with all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid ":ref:`pairs() <membership-pairs>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid "Shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid ":ref:`add_member(uri) <membership-add-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid "Add a member to the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid ":ref:`probe_uri(uri) <membership-probe-uri>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid "Check if the member is in the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid ":ref:`broadcast() <membership-broadcast>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid "Discover members in LAN by sending a UDP broadcast message."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid ":ref:`set_payload(key, value) <membership-set-payload>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid "Update ``myself().payload`` and disseminate it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid ":ref:`leave() <membership-leave>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid "Gracefully leave the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid ":ref:`is_encrypted() <membership-is-encrypted>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid "Check if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:115
msgid "Encryption functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid ":ref:`set_encryption_key(key) <membership-set-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid "Set the key for low-level message encryption."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid ":ref:`get_encryption_key() <membership-get-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid "Retrieve the encryption key in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:123
msgid "Subscription functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid ":ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid "Subscribe for the members table updates."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid ":ref:`unsubscribe() <membership-unsubscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid "Remove the subscription."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:131
msgid "Options"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid ":ref:`PROTOCOL_PERIOD_SECONDS <membership-protocol_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid "Direct ping period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid ":ref:`ACK_TIMEOUT_SECONDS <membership-ack_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid "ACK message wait time."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid ":ref:`ANTI_ENTROPY_PERIOD_SECONDS <member-anti_entropy_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid "Anti-entropy synchronization period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid ":ref:`SUSPECT_TIMEOUT_SECONDS <membership-suspect_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid "Timeout to mark a ``suspect`` ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid ":ref:`NUM_FAILURE_DETECTION_SUBGROUPS <membership-num_fail_detect_subgr>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid "Number of members to ping a ``suspect`` indirectly."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:152
msgid "Common functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:158
msgid "Initialize the ``membership`` module. This binds a UDP socket to ``0.0.0.0:<port>``, sets the ``advertise_uri`` parameter to ``<advertise_host>:<port>``, and ``incarnation`` to ``1``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:162
msgid "The ``init()`` function can be called several times, the old socket will be closed and a new one opened."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:165
msgid "If the ``advertise_uri`` changes during the next ``init()``, the old URI is considered ``DEAD``. In order to leave the group gracefully, use the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:169
msgid "a hostname or IP address to advertise to other members"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:170
msgid "a UDP port to bind"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:171
#: ../doc/reference/reference_rock/membership.rst:267
#: ../doc/reference/reference_rock/membership.rst:277
msgid "``true``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "raises"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:173
msgid "socket bind error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:179
msgid "the :ref:`member data structure <membership-datastruct>` of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:187
msgid "the given member's ``advertise_uri``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:188
msgid "the :ref:`member data structure <membership-datastruct>` of the instance with the given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:196
msgid "Obtain all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:198
msgid "Editing this table has no effect."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:200
msgid "a table with URIs as keys and corresponding :ref:`member data structures <membership-datastruct>` as values."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:209
msgid "A shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:211
msgid "Lua iterator"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:213
msgid "It can be used in the following way:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:215
msgid "for uri, member in memberhip.pairs()\n"
"  -- do something\n"
"end"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:225
msgid "Add a member with the given URI to the group and propagate this event to other members. Adding a member to a single instance is enough as everybody else in the group will receive the update with time. It does not matter who adds whom."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:230
msgid "the ``advertise_uri`` of the member to add"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:231
msgid "``true`` or ``nil`` in case of an error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:233
msgid "parse error if the URI cannot be parsed"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:239
msgid "Send a message to a member to make sure it is in the group. If the member is ``alive`` but not in the group, it is added. If it already is in the group, nothing happens."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:242
msgid "the ``advertise_uri`` of the member to ping"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:243
msgid "``true`` if the member responds within 0.2 seconds, otherwise ``no response``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:245
msgid "``ping was not sent`` if the hostname could not be resolved"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:251
msgid "Discover members in local network by sending a UDP broadcast message to all networks discovered by a ``getifaddrs()`` C call."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:254
msgid "``true`` if broadcast was sent, ``false`` if ``getaddrinfo()`` fails."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:261
msgid "Update ``myself().payload`` and disseminate it along with the member status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:263
msgid "Increments ``incarnation``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:265
msgid "a key to set in payload table"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:266
msgid "auxiliary data"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:274
msgid "Gracefully leave the ``membership`` group. The node will be marked with the ``left`` status and no other members will ever try to reconnect it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:284
msgid "``true`` if encryption is enabled, ``false`` otherwise."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:287
msgid "Encryption functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:293
msgid "Set the key used for low-level message encryption. The key is either trimmed or padded automatically to be exactly 32 bytes. If the ``key`` value is ``nil``, the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:297
msgid "The encryption is handled by the ``crypto.cipher.aes256.cbc`` Tarantool module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:300
msgid "For proper communication, all members must be configured to use the same encryption key. Otherwise, members report either ``dead`` or ``non-decryptable`` in their status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:304
msgid "encryption key"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:305
#: ../doc/reference/reference_rock/membership.rst:336
msgid "``nil``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:311
msgid "Retrieve the encryption key that is currently in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:313
msgid "encryption key or ``nil`` if the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:316
msgid "Subscription functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:322
msgid "Subscribe for updates in the members table."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:324
msgid "a ``fiber.cond`` object broadcasted whenever the members table changes."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:325
msgid "object"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:331
msgid "Remove subscription on ``cond`` obtained by the :ref:`subscribe() function <membership-subscribe>`."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:333
msgid "The ``cond``'s validity is not checked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:335
msgid "the ``fiber.cond`` object obtained from :ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:338
msgid "Below is a list of ``membership`` options. They can be set as follows:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:340
msgid "options = require('membership.options')\n"
"options.<option> = <value>"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:349
msgid "Period of sending direct pings. Denoted as ``T'`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:355
msgid "Time to wait for ACK message after a ping. If a member is late to reply, the indirect ping algorithm is invoked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:362
msgid "Period to perform the anti-entropy synchronization algorithm of the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:369
msgid "Timeout to mark ``suspect`` members as ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:375
msgid "Number of members to try pinging a ``suspect`` indirectly. Denoted as ``k`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:5
msgid "Module `shard`"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:9
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server instance on each node. With this arrangement, each instance is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:14
msgid "The Tarantool `shard` module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:18
msgid "First some terminology:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:21
msgid "**Consistent hash**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:23
msgid "The `shard` module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the `shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:30
msgid "**Instance**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:32
msgid "A currently-running in-memory copy of the Tarantool server, sometimes called a \"server instance\". Usually each shard is associated with one instance, or, if both sharding and replicating are going on, each shard is associated with one replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:36
msgid "**Queue**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:38
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on every node. The `shard` module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:44
msgid "**Redundancy**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:46
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:47
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:401
msgid "**Replica**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:49
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:50
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:390
msgid "**Replica set**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:52
msgid "Often a single shard is associated with a single instance; however, often the shard is replicated. When a shard is replicated, the multiple instances (\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:56
msgid "**Replicated data**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:58
msgid "A complete copy of the data. The `shard` module handles both sharding and replication. One shard can contain one or more replicated data copies. When a write occurs, the write is attempted on every replicated data copy in turn. The `shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:62
msgid "**Shard**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:64
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:68
msgid "**Zone**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:70
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single Tarantool-server instance. A shard's replicated data copies should be in different zones."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:75
msgid "The `shard` package is distributed separately from the main `tarantool` package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:78
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:80
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:84
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:86
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:90
msgid "or download from GitHub `tarantool/shard` and use the Lua files as described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:93
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:95
msgid "The most important function is:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:102
msgid "This must be called for every shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:104
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:106
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:107
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:108
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:109
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:110
msgid "`binary` (a port number that this host is listening on, on the current host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:113
msgid "Possible errors:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:115
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:116
msgid "the servers must be alive;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:117
msgid "two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:121
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:123
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:124
msgid "The number of instances is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:125
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:127
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:148
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:150
msgid "This describes three shards. Each shard has two replicated data copies. Since the number of servers is 7, and the number of replicated data copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:155
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:178
msgid "Every data-access function in the `box` module has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:218
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:191
msgid "For example, to insert in table T in a sharded database you simply say ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:194
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:196
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:235
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:208
msgid "The user must add an `operation_id`. For details of queued data-access functions, and of maintenance-related functions, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:214
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:216
msgid "There is only one shard, and that shard contains only one replicated data copy. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:222
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:249
msgid "If you cut and paste the above, then the result, showing only the requests and responses for `shard.init` and `shard.tester`, should look approximately like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:253
msgid "<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:278
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:280
msgid "There are two shards, and each shard contains one replicated data copy. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:285
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:287
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:316
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:318
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:347
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:351
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:353
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:360
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the `shard` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:363
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:3
msgid "Module `tdb`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:5
msgid "The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:11
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:14
msgid "$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:21
msgid "To initiate ``tdb`` within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:24
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:29
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:34
msgid "Debugger Commands"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:38
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:37
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid ":codebold:`c`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:48
msgid ":codebold:`e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:44
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:55
msgid ":codebold:`f`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:54
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid ":codebold:`n`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid ":codebold:`h`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:68
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:67
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid ":codebold:`q`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid "Quit immediately."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:75
msgid "Example Session"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:77
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:79
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:87
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:89
msgid "$ tarantool example.lua"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:93
#: ../doc/reference/reference_rock/tdb.rst:118
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:132
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:105
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:109
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:157
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:140
msgid "Another debugger example can be found `here <https://github.com/sulverus/tdb>`_."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:5
msgid "Module `vshard`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:7
msgid "The ``vshard`` module introduces an advanced sharding feature based on the concept of :ref:`virtual buckets <vshard-vbuckets>` and enables horizontal scaling in Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:11
msgid "Check out the :ref:`Quick start guide <vshard-quick-start>` -- or dive into the complete ``vshard`` documentation:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:5
msgid "Administration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:13
msgid "The ``vshard`` module is distributed separately from the main Tarantool package. To install it, say this:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:16
msgid "$ tarantoolctl rocks install vshard"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:22
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:28
msgid "Configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:30
msgid "Any viable sharded cluster consists of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:32
msgid "one or more replica sets, each containing two or more :ref:`storage <vshard-storage>` instances,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:34
msgid "one or more :ref:`router <vshard-router>` instances."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:36
msgid "The number of ``storage`` instances in a replica set defines the redundancy factor of the data. The recommended value is 3 or more. The number of ``router`` instances is not limited, because routers are completely stateless. We recommend increasing the number of routers when an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:41
msgid "``vshard`` supports multiple ``router`` instances on a single Tarantool instance. Each ``router`` can be connected to any ``vshard`` cluster. Multiple ``router`` instances can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:45
msgid "As the ``router`` and ``storage`` applications perform completely different sets of functions, they should be deployed to different Tarantool instances. Although it is technically possible to place the router application on every ``storage`` node, this approach is highly discouraged and should be avoided on production deployments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:50
msgid "All ``storage`` instances can be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:53
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:55
msgid "$ tarantoolctl instance_name"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:59
msgid "All ``router`` instances can also be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:62
msgid "All cluster nodes must share a common topology. An administrator must ensure that the configurations are identical. We suggest using a configuration management tool like Ansible or Puppet to deploy the cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:66
msgid "Sharding is not integrated into any system for centralized configuration management. It is expected that the application itself is responsible for interacting with such a system and passing the sharding parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:70
msgid "The configuration example of a simple sharded cluster is available :ref:`here <vshard-config-cluster-example>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:77
msgid "Replica weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:79
msgid "The ``router`` sends all read-write requests to the master instance only. Setting replica weights allows sending read-only requests not only to the master instance, but to any available replica that is the 'nearest' to the ``router``. Weights are used to define distances between replicas within a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:84
msgid "Weights can be used, for example, to define the physical distance between the ``router`` and each replica in each replica set. In such a case read requests are sent to the nearest replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:88
msgid "Setting weights can also help to define the most powerful replicas: the ones that can process the largest number of requests per second."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:91
msgid "The idea is to specify the zone for every ``router`` and every replica, therefore filling a matrix of relative zone weights. This approach allows setting different weights in different zones for the same replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:95
msgid "To set weights, use the zone attribute for each replica during configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:97
msgid "local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:112
msgid "Then, specify relative weights for each zone pair in the ``weights`` parameter of ``vshard.router.cfg``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:115
msgid "weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- Routers of the 1st zone see the weight of the 2nd zone as 1.\n"
"        [3] = 2, -- Routers of the 1st zone see the weight of the 3rd zone as 2.\n"
"        [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- Routers of the 3rd zone see the weight of the 2nd zone as 200.\n"
"                   -- Mind that it is not equal to the weight of the 2nd zone visible\n"
"                   -- from the 1st zone (= 1).\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:144
msgid "Replica set weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:146
msgid "A replica set weight is not the same as the replica weight. The weight of a replica set defines the capacity of the replica set: the larger the weight, the more buckets the replica set can store. The total size of all sharded spaces in the replica set is also its capacity metric."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:151
msgid "You can consider replica set weights as the relative amount of data within a replica set. For example, if ``replicaset_1 = 100``, and ``replicaset_2 = 200``, the second replica set stores twice as many buckets as the first one. By default, all weights of all replica sets are equal."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:156
msgid "You can use weights, for example, to store the prevailing amount of data on a replica set with more memory space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:163
msgid "Rebalancing process"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:165
msgid "There is an **etalon number** of buckets for a replica set. (Etalon in this context means \"ideal\".) If there is no deviation from this number in the whole replica set, then the buckets are distributed evenly."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:170
msgid "The etalon number is calculated automatically considering the number of buckets in the cluster and weights of the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:173
msgid "Rebalancing starts if the **disbalance threshold of a replica set** exceeds the disbalance threshold :ref:`specified in the configuration <cfg_basic-rebalancer_disbalance_threshold>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:177
msgid "The disbalance threshold of a replica set is calculated as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:179
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:214
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:183
msgid "For example: The user specified the number of buckets is 3000, and weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd replica set – 500, 3rd replica set – 1500."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:188
msgid "This approach allows assigning a zero weight to a replica set, which initiates migration of its buckets to the remaining cluster nodes. It also allows adding a new zero-load replica set, which initiates migration of the buckets from the loaded replica sets to the zero-load replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:195
msgid "A new zero-load replica set should be assigned a weight for rebalancing to start."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:197
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:199
msgid "The configuration should be updated on all the ``routers`` first, and then on all the ``storages``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:201
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:202
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:203
msgid "If a migrated bucket is requested, ``router`` receives an error code containing information about the new location of the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:206
msgid "At this time, the new shard is already present in the ``router``'s pool of connections, so redirection is transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:213
msgid "Parallel rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:215
msgid "Originally, ``vshard`` had quite a simple ``rebalancer`` – one process on one node that calculated *routes* which should send buckets, how many, and to whom. The nodes applied these routes one by one sequentially."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:220
msgid "Unfortunately, such a simple schema worked not fast enough, especially for Vinyl, where costs of reading disk were comparable with network costs. In fact, with Vinyl the ``rebalancer`` routes applier was sleeping most of the time."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:225
msgid "Now each node can send multiple buckets in parallel in a round-robin manner to multiple destinations, or to just one."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:228
msgid "To set the degree of parallelism, a new option was added -- :ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`. You can specify it in a storage configuration in the root table:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:232
msgid "cfg.rebalancer_max_sending = 5\n"
"vshard.storage.cfg(cfg, box.info.uuid)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:237
msgid "In routers, this option is ignored."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:241
msgid "Specifying ``cfg.rebalancer_max_sending = N`` probably won't give N times speed up. It depends on network, disk, number of other fibers in the system."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:246
msgid "You have 10 replica sets and a new one is added. Now all the 10 replica sets will try to send buckets to the new one."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:249
msgid "Assume that each replica set can send up to 5 buckets at once. In that case, the new replica set will experience a rather big load of 50 buckets being downloaded at once. If the node needs to do some other work, perhaps such a big load is undesirable. Also too many parallel buckets can cause timeouts in the rebalancing process itself."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:256
msgid "To fix the problem, you can set a lower value for ``rebalancer_max_sending`` for old replica sets, or decrease ``rebalancer_max_receiving`` for the new one. In the latter case some workers on old nodes will be throttled, and you will see that in the logs."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:261
msgid "``rebalancer_max_sending`` is important, if you have restrictions for the maximal number of buckets that can be read-only at once in the cluster. As you remember, when a bucket is being sent, it does not accept new write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:266
msgid "**Example #2:**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:268
msgid "You have 100000 buckets and each bucket stores ~0.001% of your data. The cluster has 10 replica sets. And you never can afford > 0.1% of data locked on write. Then you should not set ``rebalancer_max_sending`` > 10 on these nodes. It guarantees that the rebalancer won't send more than 100 buckets at once in the whole cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:275
msgid "If ``max_sending`` is too high and ``max_receiving`` is too low, then some buckets will try to get relocated – and will fail with that. This problem will consume network resources and time. It is important to configure these parameters to not conflict with each other."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:284
msgid "Replica set lock and bucket pin"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:286
msgid "A replica set lock makes a replica set invisible to the ``rebalancer``: a locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:289
msgid "A bucket pin blocks a specific bucket from migrating: a pinned bucket stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:292
msgid "Pinning all replica set buckets is not equivalent to locking a replica set. Even if you pin all buckets, a non-locked replica set can still receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:295
msgid "Replica set lock is helpful, for example, to separate a replica set from production replica sets for testing, or to preserve some application metadata that must not be sharded for a while. A bucket pin is used for similar cases but in a smaller scope."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:300
msgid "By both locking a replica set and pinning all buckets, one can isolate an entire replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:303
msgid "Locked replica sets and pinned buckets affect the rebalancing algorithm as the ``rebalancer`` must ignore locked replica sets and consider pinned buckets when attempting to reach the best possible balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:307
msgid "The issue is not trivial as a user can pin too many buckets to a replica set, so a perfect balance becomes unreachable. For example, consider the following cluster (assume all replica set weights are equal to 1)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:311
msgid "The initial configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:313
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:318
msgid "Adding a new replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:320
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:326
msgid "The perfect balance would be ``100 - 100 - 100``, which is impossible since the ``rs2`` replica set has 120 pinned buckets. The best possible balance here is the following:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:330
msgid "rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:336
msgid "The ``rebalancer`` moved as many buckets as possible from ``rs2`` to decrease the disbalance. At the same time it respected equal weights of ``rs1`` and ``rs3``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:339
msgid "The algorithms for implementing locks and pins are completely different, although they look similar in terms of functionality."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:346
msgid "Replica set lock and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:348
msgid "Locked replica sets simply do not participate in rebalancing. This means that even if the actual total number of buckets is not equal to the etalon number, the disbalance cannot be fixed due to the lock. When the rebalancer detects that one of the replica sets is locked, it recalculates the etalon number of buckets of the non-locked replica sets as if the locked replica set and its buckets did not exist at all."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:359
msgid "Bucket pin and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:361
msgid "Rebalancing replica sets with pinned buckets requires a more complex algorithm. Here ``pinned_count[o]`` is the number of pinned buckets, and ``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:365
msgid "The ``rebalancer`` calculates the etalon number of buckets as if all buckets were not pinned. Then the rebalancer checks each replica set and compares the etalon number of buckets with the number of pinned buckets in a replica set. If ``pinned_count < etalon_count``, non-locked replica sets (at this point all locked replica sets already are filtered out) with pinned buckets can receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:371
msgid "If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as the ``rebalancer`` cannot move pinned buckets out of this replica set. In such a case the etalon number is updated and set equal to the number of pinned buckets. The replica sets with ``pinned_count > etalon_count`` are not processed by the ``rebalancer``, and the number of pinned buckets is subtracted from the total number of buckets. The rebalancer tries to move out as many buckets as possible from such replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:378
msgid "This procedure is restarted from step 1 for replica sets with ``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` on all replica sets. The procedure is also restarted when the total number of buckets is changed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:383
msgid "Here is the pseudocode for the algorithm:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:385
msgid "function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:409
msgid "The complexity of the algorithm is ``O(N^2)``, where N is the number of replica sets. On each step, the algorithm either finishes the calculation, or ignores at least one new replica set overloaded with the pinned buckets, and updates the etalon number of buckets on other replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:418
msgid "Bucket ref"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:420
msgid "Bucket ref is an in-memory counter that is similar to the :ref:`bucket pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:423
msgid "Bucket ref is not persistent. Refs are intended for forbidding bucket transfer during request execution, but on restart all requests are dropped."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:426
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:428
msgid "If a bucket has RW refs, it cannot be moved. However, when the rebalancer needs it to be sent, it locks the bucket for new write requests, waits until all current requests are finished, and then sends the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:432
msgid "If a bucket has RO refs, it can be sent, but cannot be dropped. Such a bucket can even enter GARBAGE or SENT state, but its data is kept until the last reader is gone."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:436
msgid "A single bucket can have both RO and RW refs."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:438
msgid "Bucket ref is countable."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:440
msgid "The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` methods are called automatically when :ref:`vshard.router.call() <router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you should explicitly call the ``bucket_ref()`` method inside the function. Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, otherwise the bucket cannot be moved from the storage until the instance restart."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:448
msgid "To see how many refs there are for a bucket, use :ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:454
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:888
msgid "vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:470
msgid "Defining spaces"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:472
msgid "Database Schema is stored on ``storages``, while ``routers`` know nothing about spaces and tuples."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:475
msgid "Spaces should be defined within a storage application using ``box.once()``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:478
msgid "box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:508
msgid "Every space you plan to shard must have ``bucket_id`` unsigned field indexed by ``bucket_id`` TREE index. Spaces without ``bucket_id`` index don't participate in a sharded Tarantool cluster and can be used as regular spaces if needed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:517
msgid "Adding data"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:519
msgid "All DML operations with data should be performed via ``router``. The only operation supported by ``router`` is `CALL` via ``bucket_id``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:522
msgid "result = vshard.router.call(bucket_id, mode, func, args)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:526
msgid "``vshard.router.call()`` routes ``result = func(unpack(args))`` call to a shard which serves ``bucket_id``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:529
msgid "``bucket_id`` is just a regular number in the range ``1..``:ref:`bucket_count<cfg_basic-bucket_count>`. This number can be assigned in an arbitrary way by the client application. A sharded Tarantool cluster uses this number as an opaque unique identifier to distribute data across replica sets. It is guaranteed that all records with the same ``bucket_id`` will be stored on the same replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:540
msgid "Bootstrapping and restarting a storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:542
msgid "If a replica set master fails, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:544
msgid "Switch one of the replicas into the master mode. This allows the new master to process all the incoming requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:546
msgid "Update the configuration of all the cluster members. This forwards all the requests to the new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:549
msgid "Monitoring the master and switching the instance modes can be handled by any external utility."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:552
msgid "To perform a scheduled downtime of a replica set master, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:554
msgid "Update the configuration of the master and wait for the replicas to get into sync. All the requests then are forwarded to a new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:556
msgid "Switch another instance into the master mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:557
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:563
msgid "Update the configuration of all the nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:558
msgid "Shut down the old master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:560
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:562
msgid "Migrate all the buckets to the other cluster storages."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:564
msgid "Shut down the replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:566
msgid "In case a whole replica set fails, some part of the dataset becomes inaccessible. Meanwhile, the ``router`` tries to reconnect to the master of the failed replica set. This way, once the replica set is up and running again, the cluster is automatically restored."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:577
msgid "Searches for buckets, buckets recovery, and buckets rebalancing are performed automatically and do not require manual intervention."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:580
msgid "Technically, there are multiple fibers responsible for different types of operations:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:583
msgid "a **discovery** fiber on the ``router`` searches for buckets in the background"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:584
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:585
msgid "a **garbage collector** fiber on each master ``storage`` removes the contents of buckets that were moved"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:587
msgid "a **bucket recovery** fiber on each master ``storage`` recovers buckets in the SENDING and RECEIVING states in case of reboot"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:589
msgid "a **rebalancer** on a single master ``storage`` among all replica sets executes the rebalancing process."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:592
msgid "See the :ref:`Rebalancing process <vshard-rebalancing>` and :ref:`Migration of buckets <vshard-migrate-buckets>` sections for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:599
msgid "Garbage collector"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:601
msgid "A **garbage collector** fiber runs in the background on the master storages of each replica set. It starts deleting the contents of the bucket in the GARBAGE state part by part. Once the bucket is empty, its record is deleted from the ``_bucket`` system space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:610
msgid "Bucket recovery"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:612
msgid "A **bucket recovery** fiber runs on the master storages. It helps to recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:615
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:617
msgid "The system first searches for buckets in the SENDING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:618
msgid "If such a bucket is found, the system sends a request to the destination replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:620
msgid "If the bucket on the destination replica set is ACTIVE, the original bucket is deleted from the source node."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:623
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:629
msgid "Failover"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:631
msgid "A **failover** fiber runs on every ``router``. If a master of a replica set becomes unavailable, the failover fiber redirects read requests to the replicas. Write requests are rejected with an error until the master becomes available."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:5
msgid "Architecture"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:13
msgid "Consider a distributed Tarantool cluster that consists of subclusters called **shards**, each storing some part of data. Each shard, in its turn, constitutes a **replica set** consisting of several **replicas**, one of which serves as a master node that processes all read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:18
msgid "The whole dataset is logically partitioned into a predefined number of :ref:`virtual buckets <vshard-vbuckets>` (further just **buckets**), each assigned a unique number ranging from 1 to N, where N is the total number of buckets. The number of buckets is specifically chosen to be several orders of magnitude larger than the potential number of cluster nodes, even given future cluster scaling. For example, with M projected nodes the dataset may be split into 100 * M or even 1,000 * M buckets. Care should be taken when picking the number of buckets: if too large, it may require extra memory for storing the routing information; if too small, it may decrease the granularity of rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:29
msgid "Each shard stores a unique subset of buckets, which means that a bucket cannot belong to several shards at once, as illustrated below:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:35
msgid "This shard-to-bucket mapping is stored in a table in one of Tarantool’s system spaces, with each shard holding only a specific part of the mapping that covers those buckets that were assigned to this shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:39
msgid "Apart from the mapping table, the **bucket id** is also stored in a special field of every tuple of every table participating in sharding."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:42
msgid "Once a shard receives any request (except for SELECT) from an application, this shard checks the bucket id specified in the request against the table of bucket ids that belong to a given node. If the specified bucket id is invalid, the request gets terminated with the following error: “wrong bucket”. Otherwise the request is executed, and all the data created in the process is assigned the bucket id specified in the request. Note that the request should only modify the data that has the same bucket id as the request itself."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:51
msgid "Storing bucket ids both in the data itself and the mapping table ensures data consistency regardless of the application logic and makes rebalancing transparent for the application. Storing the mapping table in a system space ensures sharding is performed consistently in case of a failover, as all the replicas in a shard share a common table state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:61
msgid "Virtual buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:63
msgid "The sharded dataset is partitioned into a large number of abstract nodes called **virtual buckets** (further just **buckets**)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:66
msgid "The dataset is partitioned using the sharding key (or **bucket id**, in Tarantool terminology). Bucket id is a number from 1 to N, where N is the total number of buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:73
msgid "Each replica set stores a unique subset of buckets. One bucket cannot belong to multiple replica sets at a time."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:76
msgid "The total number of buckets is determined by the administrator who sets up the initial cluster configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:79
msgid "Every Tarantool space you plan to shard must have a bucket id field indexed by the bucket id index. Spaces without bucket id indexes do not participate in sharding but can be used as regular spaces. By default, the name of the index coincides with the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:88
msgid "Structure"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:90
msgid "A sharded cluster in Tarantool consists of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:92
msgid "storages,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:93
msgid "routers,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:94
msgid "and a rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:103
msgid "Storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:105
msgid "**Storage** is a node storing a subset of the dataset. Multiple replicated (for redundancy) storages comprise a **replica set** (also called **shard**)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:108
msgid "Each storage in a replica set has a role, **master** or **replica**. A master processes read and write requests. A replica processes read requests but cannot process write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:119
msgid "Router"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:121
msgid "**Router** is a standalone software component that routes read and write requests from the client application to shards."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:124
msgid "All requests from the application come to the sharded cluster through a ``router``. The ``router`` keeps the topology of a sharded cluster transparent for the application, thus keeping the application unaware of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:128
msgid "the number and location of shards,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:129
msgid "data rebalancing process,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:130
msgid "the fact and the process of a failover that occurred after a replica's failure."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:132
msgid "A router can also calculate a bucket id on its own provided that the application clearly defines rules for calculating a bucket id based on the request data. To do it, a router needs to be aware of the data schema."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:136
msgid "The ``router`` does not have a persistent state, nor does it store the cluster topology or balance the data. The ``router`` is a standalone software component that can run in the storage layer or application layer depending on the application features."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:140
msgid "A router maintains a constant pool of connections to all the storages that is created at startup. Creating it this way helps avoid configuration errors. Once a pool is created, a router caches the current state of the ``_vbucket`` table to speed up the routing. In case a bucket id is moved to another storage as a result of data rebalancing, or one of the shards fails over to a replica, a router updates the routing table in a way that's transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:147
msgid "Sharding is not integrated into any centralized configuration storage system. It is assumed that the application itself handles all the interactions with such systems and passes sharding parameters. That said, the configuration can be changed dynamically - for example, when adding or deleting one or several shards:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:152
msgid "To add a new shard to the cluster, a system administrator first changes the configuration of all the routers and then the configuration of all the storages."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:154
msgid "The new shard becomes available to the storage layer for rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:155
msgid "As a result of rebalancing, one of the vbuckets is moved to the new shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:156
msgid "When trying to access the vbucket, a router receives a special error code that specifies the new vbucket location."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:161
msgid "CRUD (create, replace, update, delete) operations"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:163
msgid "CRUD operations can be:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:165
msgid "executed in a stored procedure inside a storage, or"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:166
msgid "initialized by the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:168
msgid "In any case, the application must include the operation bucket id in a request. When executing an INSERT request, the operation bucket id is stored in a newly created tuple. In other cases, it is checked if the specified operation bucket id matches the bucket id of a tuple being modified."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:175
msgid "SELECT requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:177
msgid "Since a storage is not aware of the mapping between a bucket id and a primary key, all the SELECT requests executed in stored procedures inside a storage are only executed locally. Those SELECT requests that were initialized by the application are forwarded to a router. Then, if the application has passed a bucket id, a router uses it for shard calculation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:185
msgid "Calling stored procedures"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:187
msgid "There are several ways of calling stored procedures in cluster replica sets. Stored procedures can be called:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:190
msgid "on a specific vbucket located in a replica set (in this case, it is necessary to differentiate between read and write procedures, as write procedures are not applicable to vbuckets that are being migrated), or"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:193
msgid "without specifying any particular vbucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:195
msgid "All the routing validity checks performed for sharded DML operations hold true for vbucket-bound stored procedures as well."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:202
msgid "Rebalancer"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:204
msgid "**Rebalancer** is a background rebalancing process that ensures an even distribution of buckets across the shards. During rebalancing, buckets are being migrated among replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:208
msgid "The rebalancer \"wakes up\" periodically and redistributes data from the most loaded nodes to less loaded nodes. Rebalancing starts if the **disbalance threshold** of a replica set exceeds a disbalance threshold specified in the configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:212
msgid "The disbalance threshold is calculated as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:222
msgid "Migration of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:224
msgid "A replica set from which the bucket is being migrated is called a **source** ; a target replica set to which the bucket is being migrated is called a **destination**."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:227
msgid "A **replica set lock** makes a replica set invisible to the rebalancer. A locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:230
msgid "While a bucket is being migrated, it can have different states:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:232
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:233
msgid "PINNED – the bucket is locked for migrating to another replica set. Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:235
msgid "SENDING – the bucket is currently being copied to the destination replica set; read requests to the source replica set are still processed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:237
msgid "RECEIVING – the bucket is currently being filled; all requests to it are rejected."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:238
msgid "SENT – the bucket was migrated to the destination replica set. The `router` uses the SENT state to calculate the new location of the bucket. A bucket in the SENT state goes to the GARBAGE state automatically after BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:242
msgid "GARBAGE – the bucket was already migrated to the destination replica set during rebalancing; or the bucket was initially in the RECEIVING state, but some error occurred during the migration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:246
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:251
msgid "Migration is performed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:253
msgid "At the destination replica set, a new bucket is created and assigned the RECEIVING state, the data copying starts, and the bucket rejects all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:255
msgid "The source bucket in the source replica set is assigned the SENDING state, and the bucket continues to process read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:257
msgid "Once the data is copied, the bucket on the source replica set is assigned the SENT and it starts rejecting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:259
msgid "The bucket on the destination replica set is assigned the ACTIVE state and starts accepting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:264
msgid "There is a specific error ``vshard.error.code.TRANSFER_IS_IN_PROGRESS`` that returns in case a request tries to perform an action not applicable to a bucket which is being relocated. You need to retry the request in this case."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:272
msgid "The `_bucket` system space"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:274
msgid "The ``_bucket`` system space of each replica set stores the ids of buckets present in the replica set. The space contains the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:277
msgid "``bucket`` – bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:278
msgid "``status`` – state of the bucket"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:279
msgid "``destination`` – UUID of the destination replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:281
msgid "An example of ``_bucket.select{}``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:283
msgid "---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:290
msgid "Once the bucket is migrated, the destination replica set identified by UUID is filled in the table. While the bucket is still located on the source replica set, the value of the destination replica set UUID is equal to ``NULL``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:298
msgid "The routing table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:300
msgid "А routing table on the ``router`` stores the map of all bucket ids to replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:303
msgid "The ``router`` keeps a persistent pool of connections to all the storages that are created at startup. This helps prevent configuration errors. Once the connection pool is created, the ``router`` caches the current state of the routing table in order to speed up routing. If a bucket migrated to another ``storage`` after rebalancing, or a failover occurred and caused one of the shards switching to another replica, the ``discovery fiber`` on the ``router`` updates the routing table automatically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:310
msgid "As the bucket id is explicitly indicated both in the data and in the mapping table on the ``router``, the data is consistent regardless of the application logic. It also makes rebalancing transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:318
msgid "Processing requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:320
msgid "Requests to the database can be performed by the application or using stored procedures. Either way, the bucket id should be explicitly specified in the request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:323
msgid "All requests are forwarded to the ``router`` first. The only operation supported by the ``router`` is ``call``. The operation is performed via the ``vshard.router.call()`` function:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:327
msgid "result = vshard.router.call(<bucket_id>, <mode>, <function_name>, {<argument_list>}, {<opts>})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:331
msgid "Requests are processed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:333
msgid "The ``router`` uses the bucket id to search for a replica set with the corresponding bucket in the routing table."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:336
msgid "If the map of the bucket id to the replica set is not known to the ``router`` (the discovery fiber hasn’t filled the table yet), the ``router`` makes requests to all ``storages`` to find out where the bucket is located."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:339
msgid "Once the bucket is located, the shard checks:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:341
msgid "whether the bucket is stored in the ``_bucket`` system space of the replica set;"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:342
msgid "whether the bucket is ACTIVE or PINNED (for a read request, it can also be SENDING)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:344
msgid "If all the checks succeed, the request is executed. Otherwise, it is terminated with the error: ``“wrong bucket”``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:351
msgid "Glossary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:356
msgid "**Vertical scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:358
msgid "Adding more power to a single server: using a more powerful CPU, adding more capacity to RAM, adding more storage space, etc."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:362
msgid "**Horizontal scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:364
msgid "Adding more servers to the pool of resources, then partitioning and distributing a dataset across the servers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:368
msgid "**Sharding**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:370
msgid "A database architecture that allows partitioning a dataset using a sharding key and distributing a dataset across multiple servers. Sharding is a special case of horizontal scaling."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:375
msgid "**Node**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:377
msgid "A virtual or physical server instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:380
msgid "**Cluster**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:382
msgid "A set of nodes that make up a single group."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:385
msgid "**Storage**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:387
msgid "A node storing a subset of a dataset."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:392
msgid "A set of storage nodes storing copies of a dataset. Each storage in a replica set has a role, master or replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:396
msgid "**Master**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:398
msgid "A storage in a replica set processing read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:403
msgid "A storage in a replica set processing only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:406
msgid "**Read requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:408
msgid "Read-only requests, that is, select requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:411
msgid "**Write requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:413
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:416
msgid "**Buckets (virtual buckets)**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:418
msgid "The abstract virtual nodes into which the dataset is partitioned by the sharding key (bucket id)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:422
msgid "**Bucket id**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:424
msgid "A sharding key defining which bucket belongs to which replica set. A bucket id may be calculated from a :ref:`hash key <router_api-bucket_id>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:428
msgid "**Router**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:430
msgid "A proxy server responsible for routing requests from an application to nodes in a cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:5
msgid "Quick start guide"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:7
msgid "For installation instructions, check out the :ref:`vshard installation manual <vshard-install>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:9
msgid "For a pre-configured development cluster, check out the ``example/`` directory in the `vshard repository <https://github.com/tarantool/vshard/>`_. This example includes 5 Tarantool instances and 2 replica sets:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:13
msgid "``router_1`` – a ``router`` instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:14
msgid "``storage_1_a`` – a ``storage`` instance, the **master** of the **first** replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:15
msgid "``storage_1_b`` – a ``storage`` instance, the **replica** of the **first** replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:16
msgid "``storage_2_a`` – a ``storage`` instance, the **master** of the **second** replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:17
msgid "``storage_2_b`` – a ``storage`` instance, the **replica** of the **second** replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:19
msgid "All instances are managed using the ``tarantoolctl`` utility which comes with Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:21
msgid "Change the directory to ``example/`` and use ``make`` to run the development cluster:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:23
msgid "$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:61
msgid "Some ``tarantoolctl`` commands:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:63
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:64
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:66
msgid "The full list of ``tarantoolctl`` commands for managing Tarantool instances is available in the :ref:`tarantoolctl reference <tarantoolctl>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:69
msgid "Essential ``make`` commands you need to know:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:71
msgid "``make start`` – start all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:72
msgid "``make stop`` – stop all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:73
msgid "``make logcat`` – show logs from all instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:74
msgid "``make enter`` – enter the admin console on ``router_1``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:75
msgid "``make clean`` – clean up all persistent data"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:76
msgid "``make test`` – run the test suite (you can also run ``test-run.py`` in the ``test`` directory)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:77
msgid "``make`` – execute ``make stop``, ``make clean``, ``make start`` and ``make enter``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:79
msgid "For example, to start all instances, use ``make start``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:81
msgid "$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:91
msgid "To perform commands in the admin console, use the router's :ref:`public API <vshard_api_reference-router_public_api>`:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:94
msgid "unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:128
msgid "Sample configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:130
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:132
msgid "local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:170
msgid "This cluster includes one ``router`` instance and two ``storage`` instances. Each ``storage`` instance includes one master and one replica. The ``sharding`` field defines the logical topology of a sharded Tarantool cluster. All the other fields are passed to ``box.cfg()`` as they are, without modifications. See the :ref:`Configuration reference <vshard-config-reference>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:176
msgid "On routers, call ``vshard.router.cfg(cfg)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:178
msgid "cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:186
msgid "On storages, call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:188
msgid "-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:200
msgid "``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures the listen port and replication parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:203
msgid "For a sample configuration, see ``router.lua`` and ``storage.lua`` in the ``example/`` directory of the `vshard repository <https://github.com/tarantool/vshard>`_."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:13
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:14
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:15
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:16
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:17
msgid ":ref:`collect_bucket_garbage_interval <cfg_basic-collect_bucket_garbage_interval>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:18
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:19
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:20
msgid ":ref:`rebalancer_disbalance_threshold <cfg_basic-rebalancer_disbalance_threshold>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:21
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:22
msgid ":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:28
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:30
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:41
msgid "Type: table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:38
msgid "A field defining the configuration of relative weights for each zone pair in a replica set. See the :ref:`Replica weights <vshard-replica-weights>` section."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:49
msgid "An index over the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:51
msgid "Type: non-empty string or non-negative integer"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:52
msgid "Default: coincides with the bucket id number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:59
msgid "The total number of buckets in a cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:61
msgid "This number should be several orders of magnitude larger than the potential number of cluster nodes, considering potential scaling out in the foreseeable future."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:66
msgid "If the estimated number of nodes is M, then the data set should be divided into 100M or even 1000M buckets, depending on the planned scaling out. This number is certainly greater than the potential number of cluster nodes in the system being designed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:71
msgid "Keep in mind that too many buckets can cause a need to allocate more memory to store routing information. On the other hand, an insufficient number of buckets can lead to decreased granularity when rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:75
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:85
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:107
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:122
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:143
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:158
msgid "Type: number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:76
msgid "Default: 3000"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:83
msgid "The interval between garbage collector actions, in seconds."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:93
msgid "If set to true, the Lua ``collectgarbage()`` function is called periodically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:96
msgid "Default: no"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:103
msgid "Timeout to wait for synchronization of the old master with replicas before demotion. Used when switching a master or when manually calling the ``sync()`` function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:115
msgid "A maximum bucket disbalance threshold, in percent. The threshold is calculated for each replica set using the following formula:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:118
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:130
msgid "The maximum number of buckets that can be received in parallel by a single replica set. This number must be limited, because when a new replica set is added to a cluster, the rebalancer sends a very large amount of buckets from the existing replica sets to the new replica set. This produces a heavy load on the new replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:137
msgid "Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on each respectively. When a new replica set is added, each replica set’s ``etalon_bucket_count`` becomes equal to 250. Rather than receiving all 250 buckets at once, the new replica set receives 100, 100 and 50 buckets sequentially."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:144
msgid "Default: 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:151
msgid "The degree of parallelism for :ref:`parallel rebalancing <vshard-parallel-rebalancing>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:154
msgid "Works for storages only, ignored for routers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:156
msgid "The maximum value is ``15``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:166
msgid "Replica set functions"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:168
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:169
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:175
msgid "A unique identifier of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:177
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:188
msgid "Type:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:178
msgid "Default:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:179
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:190
msgid "Dynamic:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:185
msgid "A weight of a replica set. See the :ref:`Replica set weights <vshard-replica-set-weights>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:202
msgid "Router public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:204
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:205
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:206
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:207
msgid ":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, {options}) <router_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:208
msgid ":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, {options}) <router_api-callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:209
msgid ":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, {options}) <router_api-callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:210
msgid ":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, {options}) <router_api-callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:211
msgid ":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, {options}) <router_api-callbro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:212
msgid ":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, {options}) <router_api-callbre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:213
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:214
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:215
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:216
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:217
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:218
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:219
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:220
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:221
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:222
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:223
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:224
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:230
msgid "Perform the initial cluster bootstrap and distribute all buckets across the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:233
msgid "a number of seconds before ending a bootstrap attempt as unsuccessful. Recreate the cluster in case of bootstrap timeout."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:241
msgid "Configure the database and start sharding for the specified ``router`` instance. See the :ref:`sample configuration <vshard-config-cluster-example>` above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:245
msgid "a configuration table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:251
msgid "Create a new router instance. ``vshard`` supports multiple routers in a single Tarantool instance. Each router can be connected to any ``vshard`` cluster, and multiple routers can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:255
msgid "A router created via ``vshard.router.new()`` works in the same way as a static router, but the method name is preceded by a colon (``vshard.router:method_name(...)``), while for a static router the method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:260
msgid "A static router can be obtained via the ``vshard.router.static()`` method and then used like a router created via the ``vshard.router.new()`` method."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:266
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:268
msgid "a router instance name. This name is used as a prefix in logs of the router and must be unique within the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:270
msgid "a configuration table. The :ref:`sample configuration <vshard-config-cluster-example>` is described above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:274
msgid "a router instance, if created successfully; otherwise, nil and an error object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:281
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id. See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:286
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:344
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:375
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:408
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:452
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:485
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:692
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:772
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:800
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:811
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:822
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:848
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:967
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:987
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:996
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1021
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1039
msgid "a bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:287
msgid "either a string = 'read'|'write', or a map with mode='read'|'write' and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:288
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:345
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:376
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:409
msgid "a function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:289
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:346
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:377
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:410
msgid "an array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:290
msgid "* ``timeout`` – a request timeout, in seconds. If the router cannot identify a   shard with the specified ``bucket_id``, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:292
msgid "``timeout`` – a request timeout, in seconds. If the router cannot identify a shard with the specified ``bucket_id``, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:296
msgid "The mode parameter has two possible forms: a string or a map. Examples of the string form are: ``'read'``, ``'write'``. Examples of the map form are: ``{mode='read'}``, ``{mode='write'}``, ``{mode='read', prefer_replica=true}``, ``{mode='read', balance=true}``, ``{mode='read', prefer_replica=true, balance=true}``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:301
msgid "If ``'write'`` is specified then the target is the master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:303
msgid "If ``prefer_replica=true`` is specified then the preferred target is one of the replicas, but the target is the master if there is no conveniently available replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:306
msgid "It may be good to specify prefer_replica=true for functions which are expensive in terms of resource use, to avoid slowing down the master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:309
msgid "If ``balance=true`` then there is load balancing -- reads are distributed over all the nodes in the replica set in round-robin fashion, with a preference for replicas if prefer_replica=true is also set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:313
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:355
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:386
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:419
msgid "The original return value of the executed function, or ``nil`` and error object. The error object has a type attribute equal to ``ShardingError`` or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, ``SocketError``, etc.)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:318
msgid "``ShardingError`` is returned on errors specific for sharding: the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for the error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:326
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:328
msgid "vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:338
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:347
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:378
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:411
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:608
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:629
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:648
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:670
msgid "* ``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a   shard with the bucket id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:349
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:380
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:413
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:610
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:631
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:650
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:672
msgid "``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a shard with the bucket id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:360
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:391
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:424
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for this error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:370
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-write mode (similar to calling vshard.router.call with mode='write'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:401
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling ``vshard.router.call`` with ``mode='read'``), with preference for a replica rather than a master (similar to calling ``vshard.router.call`` with ``prefer_replica = true``). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:434
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true}."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:442
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode ``parameter = {mode='read', balance=true, prefer_replica=true}``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:450
msgid "Return the replica set object for the bucket with the specified bucket id value."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:454
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:469
msgid "a replica set object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:458
msgid "replicaset = vshard.router.route(123)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:466
msgid "Return all available replica set objects."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:468
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:473
msgid "replicaset = vshard.router.routeall()"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:481
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:483
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:490
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:498
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:500
msgid "the total number of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:507
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:786
msgid "Wait until the dataset is synchronized on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:509
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:788
msgid "a timeout, in seconds"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:511
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:790
msgid "``true`` if the dataset was synchronized successfully; or ``nil`` and ``err`` explaining why the dataset cannot be synchronized."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:518
msgid "Force wakeup of the bucket discovery fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:524
msgid "Return information about each instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:528
msgid "Replica set parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:530
msgid "replica set uuid"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:531
msgid "master instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:532
msgid "replica instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:534
msgid "Instance parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:536
msgid "``uri`` — URI of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:537
msgid "``uuid`` — UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:538
msgid "``status`` – status of the instance (``available``, ``unreachable``, ``missing``)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:539
msgid "``network_timeout`` – a timeout for the request. The value is updated automatically on each 10th successful request and each 2nd failed request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:542
msgid "Bucket parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:544
msgid "``available_ro`` – the number of buckets known to the ``router`` and available for read requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:545
msgid "``available_rw`` – the number of buckets known to the router and available for read and write requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:546
msgid "``unavailable`` – the number of buckets known to the ``router`` but unavailable for any requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:547
msgid "``unreachable`` – the number of buckets whose replica sets are not known to the ``router``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:551
msgid "tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:585
msgid "Return information about each bucket. Since a bucket map can be huge, only the required range of buckets can be specified."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:588
msgid "the offset in a bucket map of the first bucket to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:589
msgid "the maximum number of buckets to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:591
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:597
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:603
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:605
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:626
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:645
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:667
msgid "UUID of a replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:606
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:627
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:646
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:668
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:774
msgid "function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:607
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:628
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:647
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:669
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:775
msgid "array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:618
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:624
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:639
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments. It is recommended to call only read-only functions using ``replicaset.callro()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:658
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments, with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). It is recommended to call only read-only functions using ``replicaset.callre()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:680
msgid "Router internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:682
msgid ":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-bucket_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:688
msgid "Search for the bucket in the whole cluster. If the bucket is not found, it is likely that it does not exist. The bucket might also be moved during rebalancing and currently is in the RECEIVING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:698
msgid "Storage public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:700
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:701
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:702
msgid ":ref:`vshard.storage.call(bucket_id, mode, function_name, {argument_list}) <storage_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:703
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:704
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:705
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:706
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:707
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:708
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:709
msgid ":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-bucket_unref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:710
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:711
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:712
msgid ":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) <storage_api-find_garbage_bucket>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:713
msgid ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:714
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:715
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:716
msgid ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-rebalancing_is_in_progress>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:717
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:718
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:719
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:725
msgid "Configure the database and start sharding for the specified ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:728
msgid "a ``storage`` configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:729
msgid "UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:735
msgid "Return information about the storage instance in the following format:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:737
msgid "tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:770
msgid "Call the specified function on the current ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:773
msgid "a type of the function: 'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:779
msgid "The original return value of the executed function, or ``nil`` and error object."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:797
msgid "Pin a bucket to a replica set. A pinned bucket cannot be moved even if it breaks the cluster balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:802
msgid "``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be pinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:809
msgid "Return a pinned bucket back into the active state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:813
msgid "``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be unpinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:820
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:823
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:849
msgid "'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:825
msgid "``true`` if the bucket ref is created successfully; or ``nil`` and ``err`` explaining why the ref cannot be created"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:832
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:839
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:846
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:851
msgid "``true`` if the bucket ref is removed successfully; or ``nil`` and ``err`` explaining why the ref cannot be removed"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:858
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:865
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:872
msgid "Find a bucket which has data in a space but is not stored in a ``_bucket`` space; or is in a GARBAGE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:875
msgid "index of a space with the part of a bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:876
msgid "a garbage collector controller. If there is an increased buckets generation, then the search should be interrupted."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:879
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:886
msgid "Return information about each bucket located in storage. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:904
msgid "Return the number of buckets located in storage."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:910
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:916
msgid "Return a flag indicating whether rebalancing is in progress. The result is true if the node is currently applying routes received from a rebalancer node in the special fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:924
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:930
msgid "Disable rebalancing. A disabled rebalancer sleeps until it is enabled again with vshard.storage.rebalancer_enable()."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:937
msgid "Enable rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:943
msgid "Show the spaces that are visible to rebalancer and garbage collector fibers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:949
msgid "Storage internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:951
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:952
msgid ":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-bucket_recv>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:953
msgid ":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-bucket_delete_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:954
msgid ":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-bucket_collect>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:955
msgid ":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) <storage_api-bucket_force_create>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:956
msgid ":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-bucket_force_drop>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:957
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:958
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:959
msgid ":ref:`vshard.storage.rebalancer_request_state() <storage_api-rebalancer_request_state>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:965
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:968
msgid "UUID of source replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:969
msgid "data logically stored in a bucket identified by bucket_id, in the same format as the return value from ``bucket_collect() <storage_api-bucket_collect>``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:976
msgid "Return information about the bucket id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:978
msgid "tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:993
msgid "Force garbage collection for the bucket identified by bucket_id in case the bucket was transferred to a different replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1002
msgid "Collect all the data that is logically stored in the bucket identified by bucket_id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1004
msgid "tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1027
msgid "Force creation of the buckets (single or multiple) on the current replica set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1030
msgid "an identifier of the first bucket in a range"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1031
msgid "the number of buckets to insert (default = 1)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1037
msgid "Drop a bucket manually for tests or emergency cases."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1045
msgid "Send a specified bucket from the current replica set to a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1047
msgid "bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1048
msgid "UUID of a remote replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1054
msgid "Check all buckets of the host storage that have the SENT or ACTIVE state, return the number of active buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1057
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1063
msgid "Collect an array of active bucket identifiers for discovery."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:5
msgid "Summary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:7
msgid "Scaling databases in a growing project is often considered one of the most challenging issues. Once a single server cannot withstand the load, scaling methods should be applied."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:11
msgid "**Sharding** is a database architecture that allows for `horizontal scaling <https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_, which implies that a dataset is partitioned and distributed over multiple servers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:15
msgid "With ``vshard``, the tuples of a dataset are distributed across multiple nodes, with a Tarantool database server instance on each node. Each instance handles only a subset of the total data, so larger loads can be handled by simply adding more servers. The initial dataset is partitioned into multiple parts, so each part is stored on a separate server."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:21
msgid "The ``vshard`` module is based on the concept of :ref:`virtual buckets <vshard-vbuckets>`, where a tuple set is partitioned into a large number of abstract virtual nodes (**virtual buckets**, further just **buckets**) rather than into a smaller number of physical nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:26
msgid "The dataset is partitioned using **sharding keys** (bucket id numbers). Hashing a sharding key into a large number of buckets allows seamlessly changing the number of servers in the cluster. The **rebalancing mechanism** distributes buckets evenly among all shards in case some servers were added or removed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:31
msgid "The buckets have **states**, so it is easy to monitor the server states. For example, a server instance is active and available for all types of requests, or a failover occurred and the instance accepts only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:35
msgid "The ``vshard`` module provides analogs of the **data-manipulation functions** of the Tarantool ``box`` library (select, insert, replace, update, delete) for sharding-aware applications."
msgstr ""

#: ../doc/reference/reference_sql/index.rst:5
msgid "SQL reference"
msgstr ""

#: ../doc/reference/reference_sql/index.rst:7
msgid "This reference covers all the SQL statements and clauses supported by Tarantool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3
msgid "SQL statements and clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:9
msgid "ALTER TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:11
#: ../doc/reference/reference_sql/sql.rst:96
#: ../doc/reference/reference_sql/sql.rst:178
#: ../doc/reference/reference_sql/sql.rst:510
#: ../doc/reference/reference_sql/sql.rst:559
#: ../doc/reference/reference_sql/sql.rst:614
#: ../doc/reference/reference_sql/sql.rst:656
#: ../doc/reference/reference_sql/sql.rst:732
#: ../doc/reference/reference_sql/sql.rst:771
#: ../doc/reference/reference_sql/sql.rst:843
#: ../doc/reference/reference_sql/sql.rst:921
#: ../doc/reference/reference_sql/sql.rst:971
#: ../doc/reference/reference_sql/sql.rst:1015
#: ../doc/reference/reference_sql/sql.rst:1350
#: ../doc/reference/reference_sql/sql.rst:1389
#: ../doc/reference/reference_sql/sql.rst:1435
#: ../doc/reference/reference_sql/sql.rst:1461
#: ../doc/reference/reference_sql/sql.rst:1524
#: ../doc/reference/reference_sql/sql.rst:1579
#: ../doc/reference/reference_sql/sql.rst:1619
#: ../doc/reference/reference_sql/sql.rst:1704
#: ../doc/reference/reference_sql/sql.rst:1787
#: ../doc/reference/reference_sql/sql.rst:1840
#: ../doc/reference/reference_sql/sql.rst:1938
#: ../doc/reference/reference_sql/sql.rst:1989
#: ../doc/reference/reference_sql/sql.rst:2024
#: ../doc/reference/reference_sql/sql.rst:2084
#: ../doc/reference/reference_sql/sql.rst:2229
#: ../doc/reference/reference_sql/sql.rst:2314
#: ../doc/reference/reference_sql/sql.rst:2379
#: ../doc/reference/reference_sql/sql.rst:2448
#: ../doc/reference/reference_sql/sql.rst:2477
#: ../doc/reference/reference_sql/sql.rst:2507
#: ../doc/reference/reference_sql/sql.rst:2536
#: ../doc/reference/reference_sql/sql.rst:2590
#: ../doc/reference/reference_sql/sql.rst:2604
#: ../doc/reference/reference_sql/sql.rst:2637
#: ../doc/reference/reference_sql/sql.rst:2653
#: ../doc/reference/reference_sql/sql.rst:2677
#: ../doc/reference/reference_sql/sql.rst:2695
#: ../doc/reference/reference_sql/sql.rst:2721
#: ../doc/reference/reference_sql/sql.rst:2736
#: ../doc/reference/reference_sql/sql.rst:2754
#: ../doc/reference/reference_sql/sql.rst:2776
#: ../doc/reference/reference_sql/sql.rst:2795
#: ../doc/reference/reference_sql/sql.rst:2815
#: ../doc/reference/reference_sql/sql.rst:2831
#: ../doc/reference/reference_sql/sql.rst:2846
msgid "Syntax:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:13
msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:14
msgid ":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} {constraint-definition};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:15
msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:17
#: ../doc/reference/reference_sql/sql.rst:22
#: ../doc/reference/reference_sql/sql.rst:100
#: ../doc/reference/reference_sql/sql.rst:105
#: ../doc/reference/reference_sql/sql.rst:198
#: ../doc/reference/reference_sql/sql.rst:514
#: ../doc/reference/reference_sql/sql.rst:519
#: ../doc/reference/reference_sql/sql.rst:563
#: ../doc/reference/reference_sql/sql.rst:568
#: ../doc/reference/reference_sql/sql.rst:618
#: ../doc/reference/reference_sql/sql.rst:623
#: ../doc/reference/reference_sql/sql.rst:660
#: ../doc/reference/reference_sql/sql.rst:665
#: ../doc/reference/reference_sql/sql.rst:736
#: ../doc/reference/reference_sql/sql.rst:741
#: ../doc/reference/reference_sql/sql.rst:777
#: ../doc/reference/reference_sql/sql.rst:782
#: ../doc/reference/reference_sql/sql.rst:849
#: ../doc/reference/reference_sql/sql.rst:854
#: ../doc/reference/reference_sql/sql.rst:925
#: ../doc/reference/reference_sql/sql.rst:930
#: ../doc/reference/reference_sql/sql.rst:977
#: ../doc/reference/reference_sql/sql.rst:982
#: ../doc/reference/reference_sql/sql.rst:1027
#: ../doc/reference/reference_sql/sql.rst:1032
#: ../doc/reference/reference_sql/sql.rst:1354
#: ../doc/reference/reference_sql/sql.rst:1359
#: ../doc/reference/reference_sql/sql.rst:1393
#: ../doc/reference/reference_sql/sql.rst:1398
#: ../doc/reference/reference_sql/sql.rst:1444
#: ../doc/reference/reference_sql/sql.rst:1449
#: ../doc/reference/reference_sql/sql.rst:1466
#: ../doc/reference/reference_sql/sql.rst:1471
#: ../doc/reference/reference_sql/sql.rst:1528
#: ../doc/reference/reference_sql/sql.rst:1533
#: ../doc/reference/reference_sql/sql.rst:1583
#: ../doc/reference/reference_sql/sql.rst:1588
#: ../doc/reference/reference_sql/sql.rst:1623
#: ../doc/reference/reference_sql/sql.rst:1628
#: ../doc/reference/reference_sql/sql.rst:1791
#: ../doc/reference/reference_sql/sql.rst:1796
#: ../doc/reference/reference_sql/sql.rst:1844
#: ../doc/reference/reference_sql/sql.rst:1849
#: ../doc/reference/reference_sql/sql.rst:1948
#: ../doc/reference/reference_sql/sql.rst:1953
#: ../doc/reference/reference_sql/sql.rst:1993
#: ../doc/reference/reference_sql/sql.rst:1998
#: ../doc/reference/reference_sql/sql.rst:2090
#: ../doc/reference/reference_sql/sql.rst:2095
#: ../doc/reference/reference_sql/sql.rst:2160
#: ../doc/reference/reference_sql/sql.rst:2165
#: ../doc/reference/reference_sql/sql.rst:2235
#: ../doc/reference/reference_sql/sql.rst:2240
#: ../doc/reference/reference_sql/sql.rst:2245
#: ../doc/reference/reference_sql/sql.rst:2250
#: ../doc/reference/reference_sql/sql.rst:2318
#: ../doc/reference/reference_sql/sql.rst:2323
#: ../doc/reference/reference_sql/sql.rst:2383
#: ../doc/reference/reference_sql/sql.rst:2388
#: ../doc/reference/reference_sql/sql.rst:2452
#: ../doc/reference/reference_sql/sql.rst:2457
#: ../doc/reference/reference_sql/sql.rst:2481
#: ../doc/reference/reference_sql/sql.rst:2486
#: ../doc/reference/reference_sql/sql.rst:2511
#: ../doc/reference/reference_sql/sql.rst:2516
#: ../doc/reference/reference_sql/sql.rst:2540
#: ../doc/reference/reference_sql/sql.rst:2545
msgid "|br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:24
msgid "ALTER is used to change a table's name or to add new constraints or to drop old constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:27
#: ../doc/reference/reference_sql/sql.rst:144
#: ../doc/reference/reference_sql/sql.rst:542
#: ../doc/reference/reference_sql/sql.rst:594
#: ../doc/reference/reference_sql/sql.rst:639
#: ../doc/reference/reference_sql/sql.rst:712
#: ../doc/reference/reference_sql/sql.rst:821
#: ../doc/reference/reference_sql/sql.rst:885
#: ../doc/reference/reference_sql/sql.rst:956
#: ../doc/reference/reference_sql/sql.rst:992
#: ../doc/reference/reference_sql/sql.rst:1065
#: ../doc/reference/reference_sql/sql.rst:1374
#: ../doc/reference/reference_sql/sql.rst:1503
#: ../doc/reference/reference_sql/sql.rst:1560
#: ../doc/reference/reference_sql/sql.rst:1604
#: ../doc/reference/reference_sql/sql.rst:1681
#: ../doc/reference/reference_sql/sql.rst:1817
#: ../doc/reference/reference_sql/sql.rst:1901
#: ../doc/reference/reference_sql/sql.rst:1965
#: ../doc/reference/reference_sql/sql.rst:2007
#: ../doc/reference/reference_sql/sql.rst:2126
#: ../doc/reference/reference_sql/sql.rst:2559
#: ../doc/reference/reference_sql/sql.rst:2666
#: ../doc/reference/reference_sql/sql.rst:2708
#: ../doc/reference/reference_sql/sql.rst:2743
msgid "Examples:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:29
msgid "-- renaming a table:\n"
"ALTER TABLE t1 RENAME TO t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:34
msgid "For ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* must not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:37
msgid "-- adding a foreign-key constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT c FOREIGN KEY (s1) REFERENCES t1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:42
msgid "For ``ALTER ... ADD CONSTRAINT``, the table must exist, table must be empty, the constraint name must not already exist for the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:45
msgid "It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b ...`` if table ``b`` does not exist yet. This is a situation where ``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... REFERENCES table_b ...``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:50
msgid "-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT primary_key PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT unique_key UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT check_ CHECK (s1 > 0);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:68
msgid "For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named constraint, and Tarantool only looks for names of foreign-key constraints. (Tarantool generates the constraint names automatically if the user does not provide them.)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:72
msgid "To remove a unique constraint, use DROP INDEX, which will drop the constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:75
msgid "-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT c;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:81
#: ../doc/reference/reference_sql/sql.rst:164
#: ../doc/reference/reference_sql/sql.rst:603
#: ../doc/reference/reference_sql/sql.rst:1330
#: ../doc/reference/reference_sql/sql.rst:1690
#: ../doc/reference/reference_sql/sql.rst:1830
#: ../doc/reference/reference_sql/sql.rst:1926
#: ../doc/reference/reference_sql/sql.rst:1976
#: ../doc/reference/reference_sql/sql.rst:2289
msgid "Limitations:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:83
msgid "It is not possible to add or drop a column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:84
msgid "It is not possible to modify NOT NULL constraints or column properties DEFAULT and data type. However, it is possible to modify them with Tarantool/NOSQL, for example by calling :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:94
msgid "CREATE TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:98
msgid ":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} ((column-definition or table-constraint list);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:107
msgid "Create a new base table, usually called a \"table\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:111
msgid "A table is a *base table* if it is created with CREATE TABLE and contains data in persistent storage."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:114
msgid "A table is a *viewed table*, or just \"view\", if it is created with CREATE VIEW and gets its data from other views or from base tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:117
msgid "The *table-name* must be an identifier which is valid according to the rules for identifiers, and must not be the name of an already existing base table or view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:120
msgid "The *column-definition* or *table-constraint* list is a comma-separated list of column definitions or table constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:123
msgid "A *table-element-list* must be a comma-separated list of table elements; each table element may be either a column definition or a table constraint definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:127
#: ../doc/reference/reference_sql/sql.rst:526
#: ../doc/reference/reference_sql/sql.rst:580
#: ../doc/reference/reference_sql/sql.rst:676
#: ../doc/reference/reference_sql/sql.rst:794
#: ../doc/reference/reference_sql/sql.rst:866
#: ../doc/reference/reference_sql/sql.rst:940
#: ../doc/reference/reference_sql/sql.rst:1042
#: ../doc/reference/reference_sql/sql.rst:1405
msgid "Rules:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:129
msgid "A primary key is necessary; it can be specified with a table constraint ``PRIMARY KEY``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:131
msgid "There must be at least one column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:132
msgid "When ``IF NOT EXISTS`` is specified, and there is already a table with the same name, the statement is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:135
#: ../doc/reference/reference_sql/sql.rst:534
#: ../doc/reference/reference_sql/sql.rst:587
#: ../doc/reference/reference_sql/sql.rst:632
#: ../doc/reference/reference_sql/sql.rst:683
#: ../doc/reference/reference_sql/sql.rst:751
#: ../doc/reference/reference_sql/sql.rst:809
#: ../doc/reference/reference_sql/sql.rst:875
#: ../doc/reference/reference_sql/sql.rst:946
#: ../doc/reference/reference_sql/sql.rst:1059
#: ../doc/reference/reference_sql/sql.rst:1368
#: ../doc/reference/reference_sql/sql.rst:1412
msgid "Actions:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:137
msgid "Tarantool evaluates each column definition and *table-constraint*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:139
msgid "Tarantool makes a new definition in the schema."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:140
msgid "Tarantool makes new indexes for ``PRIMARY KEY`` or ``UNIQUE`` constraints. A unique index name is created automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:142
msgid "Tarantool effectively executes a ``COMMIT`` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:146
msgid "-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and an inline comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT c1 PRIMARY KEY (s1, s2));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:166
msgid "The maximum number of columns is 2000."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:167
msgid "The maximum length of a row depends on the :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  <cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:176
msgid "Column definition"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:180
msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:182
msgid "Define a column, which is a table-element used in a CREATE TABLE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:184
msgid "The ``column-name`` must be an identifier which is valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:187
msgid "Each ``column-name`` must be unique within a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:193
msgid "Column definition -- data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:200
msgid "Every operand has a data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:202
msgid "For literals, the data type is usually determined by the format."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:204
msgid "For identifiers, the data type is usually determined by the definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:206
msgid "The usual determination may change because of context or because of explicit casting."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:208
msgid "For some SQL data type names there are *aliases*. An alias may be used for data definition. For example VARCHAR(5) and TEXT are aliases of STRING and may appear in `CREATE TABLE table_name (column_name VARCHAR(5) PRIMARY KEY);` but Tarantool, if asked, will report that the data type of `column_name` is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:214
msgid "For every SQL data type there is a corresponding NoSQL type, for example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:217
msgid "To avoid confusion in this manual, all references to SQL data type names are in upper case and all similar words which refer to NoSQL types or to other kinds of object are in lower case, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:221
msgid "STRING is a data type name, but string is a general term;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:222
msgid "NUMBER is a data type name, but number is a general term."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:224
msgid "Although it is common to say that a VARBINARY value is a \"binary string\", this manual will not use that term and will instead say \"byte sequence\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:227
msgid "Here are all the SQL data types, their corresponding NoSQL types, their aliases, and minimum / maximum literal examples."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:232
#: ../doc/reference/reference_sql/sql.rst:420
msgid "**Data types**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
msgid "SQL type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
msgid "NoSQL type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
msgid "Aliases"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
msgid "Minimum"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
msgid "Maximum"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:242
msgid "BOOLEAN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:242
msgid "BOOL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:242
#: ../doc/reference/reference_sql/sql.rst:255
msgid "FALSE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:242
msgid "TRUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:244
msgid "INTEGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:244
msgid "INT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:244
msgid "-9223372036854775808"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:244
#: ../doc/reference/reference_sql/sql.rst:246
msgid "18446744073709551615"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "UNSIGNED"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "unsigned"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
#: ../doc/reference/reference_sql/sql.rst:248
#: ../doc/reference/reference_sql/sql.rst:253
#: ../doc/reference/reference_sql/sql.rst:255
msgid "(none)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "0"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:248
msgid "NUMBER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:248
msgid "-1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:248
msgid "1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
msgid "STRING"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
msgid "TEXT, VARCHAR(n)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
msgid "''"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
msgid "'many-characters'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
msgid "VARBINARY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
msgid "varbinary"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
msgid "X''"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
msgid "'X'many-hex-digits'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:255
msgid "SCALAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:255
msgid "X'many-hex-digits'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:258
msgid "BOOLEAN values are FALSE, TRUE, and UNKNOWN (which is the same as NULL). FALSE is less than TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:261
msgid "INTEGER values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between -2^63 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:265
msgid "UNSIGNED values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between 0 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:269
msgid "NUMBER values are numbers that do contain decimal points (for example 0.5) or are expressed with exponential notation (for example 5E-1). The range of possible values is the same as for the IEEE 754 floating-point standard, or NULL. Numbers outside the range of NUMBER literals may be displayed as -inf or inf."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:275
msgid "STRING values are any sequence of zero or more characters encoded with UTF-8, or NULL. The possible character values are the same as for the Unicode standard. Byte sequences which are not valid UTF-8 characters are allowed but not recommended. STRING literal values are enclosed within single quotes, for example 'literal'. If the VARCHAR alias is used for column definition, it must include a maximum length, for example column_1 VARCHAR(40). However, the maximum length is ignored. The data-type may be followed by ``[COLLATE collation-name]``. .. // see section COLLATE clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:284
msgid "VARBINARY values are any sequence of zero or more octets (bytes), or NULL. VARBINARY literal values are expressed as X followed by pairs of hexadecimal digits enclosed within single quotes, for example X'0044'. VARBINARYs NoSQL equivalent is 'varbinary' but not character string -- the MessagePack storage is MP_BIN (MsgPack binary)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:290
msgid "SCALAR can be used for column definitions but the individual column values have one of the preceding types -- BOOLEAN, INTEGER, UNSIGNED, NUMBER, STRING, or VARBINARY. See more about SCALAR in the next section. The data-type may be followed by ``[COLLATE collation-name]``. .. // see section COLLATE clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:296
msgid "Any value of any data type may be NULL. Ordinarily NULL will be cast to the data type of any operand it is being compared to or to the data type of the column it is in. If the data type of NULL cannot be determined from context, it is BOOLEAN."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:303
msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:305
msgid "SCALAR is a \"complex\" data type, unlike all the other data types which are \"primitive\". Two column values in a SCALAR column can have two different primitive data types."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:308
msgid "Any item defined as SCALAR has an underlying primitive type. For example, here:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:310
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55),('41');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:315
msgid "the underlying primitive type of the item in the first row is INTEGER because literal 55 has data type INTEGER, and the underlying primitive type in the second row is STRING (the data type of a literal is always clear from its format)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:320
msgid "An item's primitive type is far more important than its defined type. Incidentally Tarantool might find the primitive type by looking at the way MsgPack stores it, but that is an implementation detail."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:324
msgid "A SCALAR definition may not include a maximum length, as there is no suggested restriction."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:326
msgid "A SCALAR definition may include a COLLATE clause, which affects any items whose primitive data type is STRING. The default collation is \"binary\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:328
msgid "Some assignments are illegal when data types differ, but legal when the target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is defined as SCALAR -- values which happen to be INTEGER will be changed so their data type is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:333
msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:334
msgid "TYPEOF(x) is never SCALAR, it is always the underlying data type. This is true even if ``x`` is null (in that case the data type is BOOLEAN). In fact there is no function that is guaranteed to return the defined data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:338
msgid "For any operation that requires implicit casting from an item defined as SCALAR, the syntax is legal but the operation may fail at runtime. At runtime, Tarantool detects the underlying primitive data type and applies the rules for that. For example, if a definition is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:343
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:347
msgid "and within any row ``s1 = 'a'``, that is, its underlying primitive type is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` is illegal. Tarantool usually does not know that in advance."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:350
msgid "For any dyadic operation that requires implicit casting for comparison, the syntax is legal and the operation will not fail at runtime. Take this situation: comparison with a primitive type VARBINARY and a primitive type STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:355
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:361
msgid "The comparison is valid, because Tarantool knows the ordering of X'41' and 'a' in Tarantool/NoSQL 'scalar'. This would be true even if ``s1`` was not defined as SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:364
msgid "The result data type of min/max operation on a column defined as SCALAR is the data type of the minimum/maximum operand, unless the result value is NULL. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:368
msgid "CREATE TABLE t (s1 INT, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1,X'44'),(2,11),(3,1E4),(4,'a');\n"
"SELECT MIN(s2), HEX(MAX(s2)) FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:374
msgid "The result is: ``- - [11, '44',]``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:376
msgid "That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT SUM(s2)`` would not be legal because addition would in this case require implicit casting from VARBINARY to integer, which is not sensible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:379
msgid "The result data type of a primitive combination is never SCALAR because we in effect use TYPEOF(item) not the defined data type. (Here we use the word \"combination\" in the way that the standard document uses it for section \"Result of data type combinations\".) Therefore for ``MAX(1E308, 'a', 0, X'00')`` the result is X'00'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:387
msgid "Column definition -- relation to NoSQL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:389
msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the same name <box_space-index_field_types>`. For example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:393
msgid "Therefore specifying an SQL data type X determines that the storage will be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:396
msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:398
msgid "If two items have SQL data types that have the same underlying type, then they are compatible for all assignment or comparison purposes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:401
msgid "If two items have SQL data types that have different underlying types, then the rules for explicit casts, or implicit (assignment) casts, or implicit (comparison) casts, apply."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:405
msgid "There is one floating-point value which is not handled by SQL: -nan is seen as NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:407
msgid "There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is 'map'. Such columns can only be manipulated in SQL by invoking Lua functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:414
msgid "Column definition -- column-constraint or default clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:416
msgid "The column-constraint or default clause may be as follows:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:426
msgid "Comment"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:428
msgid "NOT NULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:428
msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:431
msgid "PRIMARY KEY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:431
#: ../doc/reference/reference_sql/sql.rst:434
#: ../doc/reference/reference_sql/sql.rst:437
msgid "explained in the later section \"Constraint definition\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:434
msgid "UNIQUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:437
msgid "CHECK (expression)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:440
msgid "DEFAULT expression"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:440
msgid "means \"if INSERT does not assign to this column then assign expression result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL is assumed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:447
msgid "If column-constraint is PRIMARY KEY, this is a shorthand for a separate table-constraint definition: \"PRIMARY KEY (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:450
msgid "If column-constraint is UNIQUE, this is a shorthand for a separate table-constraint definition: \"UNIQUE (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:453
msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:455
msgid "To enforce some restrictions that Tarantool does not enforce automatically, add CHECK clauses, like these:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:458
msgid "CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY, CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" CHAR(10) PRIMARY KEY, CHECK (length(\"shorttext\") <= 10));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:463
msgid "but this may cause inserts or updates to be slow."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:467
msgid "Column definition -- examples"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:469
msgid "These are shown within CREATE TABLE statements. Data types may also appear in CAST functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:472
msgid "-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause and two column-constraints\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:481
msgid "-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column4 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:494
msgid "-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INT PRIMARY KEY,\n"
" column2 INT UNIQUE,\n"
" column3 INT CHECK (column3 > column2),\n"
" column4 INT REFERENCES t,\n"
" column6 INT DEFAULT NULL);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:508
msgid "DROP TABLE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:512
msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:521
msgid "Drop a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:523
msgid "The *table-name* must identify a table that was created earlier with the :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:528
msgid "If there is a view that references the table, the drop will fail. Please drop the referencing view with DROP VIEW first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:530
msgid "If there is a foreign key that references the table, the drop will fail. Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP <sql_alter_table_drop_constraint>` first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:536
msgid "Tarantool returns an error if the table does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:537
msgid "The table and all its data are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:538
msgid "All indexes for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:539
msgid "All triggers for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:540
#: ../doc/reference/reference_sql/sql.rst:592
#: ../doc/reference/reference_sql/sql.rst:637
#: ../doc/reference/reference_sql/sql.rst:689
#: ../doc/reference/reference_sql/sql.rst:756
#: ../doc/reference/reference_sql/sql.rst:1063
#: ../doc/reference/reference_sql/sql.rst:1372
msgid "Tarantool effectively executes a COMMIT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:544
msgid "-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:551
msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:557
msgid "CREATE VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:561
msgid ":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:570
msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:572
msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:574
msgid "The optional *column-list* must be a comma-separated list of names of columns in the view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:577
msgid "The syntax of the subquery must be the same as the syntax of a SELECT statement, or of a VALUES clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:582
msgid "There must not already be a base table or view with the same name as *view-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:584
msgid "If *column-list* is specified, the number of columns in *column-list* must be the same as the number of columns in the *select-list* of the subquery."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:589
#: ../doc/reference/reference_sql/sql.rst:685
#: ../doc/reference/reference_sql/sql.rst:1061
msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:590
msgid "Tarantool will create a new persistent object with *column-names* equal to the names in the *column-list* or the names in the subquery's *select-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:596
msgid "-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:605
msgid "It is not possible to insert or update or delete from a view, although sometimes a possible substitution is to create an INSTEAD OF trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:612
msgid "DROP VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:616
msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:625
msgid "Drop a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:627
msgid "The *view-name* must identify a view that was created earlier with the :ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:630
#: ../doc/reference/reference_sql/sql.rst:749
#: ../doc/reference/reference_sql/sql.rst:1366
msgid "Rules: none"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:634
msgid "Tarantool returns an error if the view does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:635
msgid "The view is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:636
msgid "All triggers for the view are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:641
msgid "-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:648
msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:654
msgid "CREATE INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:658
msgid ":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} (column-list);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:667
msgid "Create an index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:669
msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:671
msgid "The *table-name* must refer to an existing table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:673
msgid "The *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:678
msgid "There must not already be, for the same table, an index with the same name as *index-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:680
msgid "An index name is local to the table the index is defined on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:681
msgid "The maximum number of indexes per table is 128."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:686
msgid "If the new index is UNIQUE, Tarantool will throw an error if any row exists with columns that have duplicate values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:688
msgid "Tarantool will create a new index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:691
msgid "Automatic indexes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:693
msgid "Indexes may be created automatically for columns mentioned in the PRIMARY KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created automatically, then the *index-name* is based on four items:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:698
msgid "``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a UNIQUE clause;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:700
msgid "``_unnamed_``;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:701
msgid "the name of the table;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:702
msgid "``_`` and an ordinal number; the first index is 1, the second index is 2, and so on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:705
msgid "For example, after ``CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT, UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and ``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM \"_index\";`` which will list all indexes on all tables. There is no need to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:714
msgid "-- the simple case\n"
"CREATE INDEX i ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS i ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX i ON t (column1, column2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:723
msgid "Dropping an automatic index created for a unique constraint will drop the unique constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:730
msgid "DROP INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:734
msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:743
msgid "The *index-name* must be the name of an existing index, which was created with CREATE INDEX. Or, the *index-name* must be the name of an index that was created automatically due to a PRIMARY KEY or UNIQUE clause in the CREATE TABLE statement. To see what a table's indexes are, use ``PRAGMA index_list (table-name)``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:753
msgid "Tarantool throws an error if the index does not exist, or is an automatically created index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:755
msgid "Tarantool will drop the index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:760
msgid "-- the simplest form:\n"
"DROP INDEX i ON t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:769
msgid "INSERT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:773
msgid ":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:774
msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:775
msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:784
msgid "Insert one or more new rows into a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:786
msgid "The *table-name* must be a name of a table defined earlier with CREATE TABLE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:788
msgid "The optional *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:791
msgid "The *expression-list* must be a comma-separated list of expressions; each expression may contain literals and operators and subqueries and function invocations."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:796
msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:797
msgid "The order of the values in the *expression-list* must correspond to the order of the columns in the table, or (if a *column-list* is specified) to the order of the columns in the *column-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:800
#: ../doc/reference/reference_sql/sql.rst:869
msgid "The data type of the value should correspond to the data type of the column, that is, the data type that was specified with CREATE TABLE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:802
msgid "If a *column-list* is not specified, then the number of expressions must be the same as the number of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:804
msgid "If a *column-list* is specified, then some columns may be omitted; omitted columns will get default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:806
msgid "The parenthesized *expression-list* may be repeated -- ``(expression-list),(expression-list),...`` -- for multiple rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:811
msgid "Tarantool evaluates each expression in *expression-list*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:813
msgid "Tarantool creates zero or more new rows containing values based on the values in the VALUES list or based on the results of the *select-expression* or based on the default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:816
msgid "Tarantool executes constraint checks and trigger actions and the actual insertion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:817
msgid "Tarantool inserts values into the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:823
msgid "-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:835
msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:841
msgid "UPDATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:845
msgid ":samp:`UPDATE {table-name} SET column-name = expression [, column-name = expression ...] [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:856
msgid "Update zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:858
#: ../doc/reference/reference_sql/sql.rst:934
msgid "The *table-name* must be a name of a table defined earlier with CREATE TABLE or CREATE VIEW."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:861
msgid "The *column-name* must be an updatable column in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:863
msgid "The *expression* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:868
msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:871
msgid "If a *search-condition* is not specified, then all rows in the table will be updated; otherwise only those rows which match the *search-condition* will be updated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:877
msgid "Tarantool evaluates each expression in the SET clause, and returns an error if any of the rules is violated. For each row that is found by the WHERE clause, a temporary new row is formed based on the original contents and the modifications caused by the SET clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:881
msgid "Tarantool executes constraint checks and trigger actions and the actual update."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:887
msgid "-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:896
msgid "Special cases:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:898
msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:900
msgid "UPDATE t SET (column1, column2, column3) = (1,2,3);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:904
msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:906
msgid "INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:911
msgid "The result is an error: \"duplicate column name\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:913
msgid "It is not legal to assign to a primary-key column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:919
msgid "DELETE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:923
msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:932
msgid "Delete zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:937
msgid "The *search-condition* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:942
msgid "If a search-condition is not specified, then all rows in the table will be deleted; otherwise only those rows which match the *search-condition* will be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:948
msgid "Tarantool evaluates each expression in the *search-condition*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:950
msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:951
msgid "Tarantool executes constraint checks and trigger actions and the actual deletion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:952
msgid "Tarantool deletes the set of matching rows from the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:958
msgid "-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:969
msgid "REPLACE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:973
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:974
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:975
msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:984
msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:986
msgid "If a row already exists (as determined by the primary key or any unique key), then the action is delete + insert, and the rules are the same as for a DELETE statement followed by an INSERT statement. Otherwise the action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:994
msgid "-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1005
msgid "See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1013
msgid "CREATE TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1017
msgid ":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`INSERT|UPDATE|DELETE ON {table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN (search-condition)]` |br| :samp:`BEGIN` |br| :samp:`update-statement | insert-statement | delete-statement | select-statement;` |br| :samp:`[update-statement | insert-statement | delete-statement | select-statement; ...]` |br| :samp:`END;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1034
msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1036
msgid "If the trigger action time is BEFORE or AFTER, then the *table-name* must refer to an existing base table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1039
msgid "If the trigger action time is INSTEAD OF, then the *table-name* must refer to an existing view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1044
msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1045
msgid "Triggers on different tables or views share the same namespace."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1046
msgid "The statements between BEGIN and END should not refer to the *table-name* mentioned in the ON clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1048
msgid "The statements between BEGIN and END should not contain an INDEXED BY clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1050
msgid "SQL triggers are not fired upon Tarantool/NoSQL requests. This will change in version 2.2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1053
msgid "On a replica, effects of trigger execution are applied, and the SQL triggers themselves are not fired upon replication events."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1056
msgid "NoSQL triggers are fired both on replica and master, thus if you have a NoSQL trigger on replica, it is fired when applying effects of an SQL trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1062
msgid "Tarantool will create a new trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1067
msgid "-- the simple case:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1086
msgid "Trigger extra clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1088
msgid ":samp:`UPDATE OF column-list`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1090
msgid "After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any of the columns in *column-list* is affected at the time the row is processed, then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1094
msgid "CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1103
msgid ":samp:`WHEN`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1105
msgid "After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]. If the expression is true at the time the row is processed, only then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1109
msgid "CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1115
msgid "This trigger will not be activated unless there is more than one row in ``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1118
msgid ":samp:`OLD and NEW`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1120
msgid "The keywords OLD and NEW have special meaning in the context of trigger action:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1122
msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1123
msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1127
msgid "CREATE TABLE table1 (column1 VARCHAR(15), column2 INT PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 VARCHAR(15), column2 VARCHAR(15), column3 INT PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1138
msgid "At the beginning of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1141
msgid "At the end of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'new value' -- so that is what is seen as ``new.column1``. (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1145
msgid "Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1147
msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1149
msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1151
msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1153
msgid "Deprecated or illegal statements:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1155
msgid "It is legal for the trigger action to include a SELECT statement or a REPLACE statement, but not recommended."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1158
msgid "It is illegal for the trigger action to include a qualified column reference other than ``OLD.column-name`` or ``NEW.column-name``. For example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1=5; END;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1163
msgid "It is illegal for the trigger action to include statements that include a WITH clause, a DEFAULT VALUES clause, or an INDEXED BY clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1166
msgid "It is usually not a good idea to have a trigger on ``table1`` which causes a change on ``table2``, and at the same time have a trigger on ``table2`` which causes a change on ``table1``. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1170
msgid "CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER trigger_on_table2\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1181
msgid "Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because Tarantool recognizes when it has already updated so it will stop. However, not every DBMS acts this way."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1189
msgid "Trigger activation"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1191
msgid "These are remarks concerning trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1193
msgid "Standard terminology:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1195
msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1196
msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1197
msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1198
msgid "\"triggered when clause\" = WHEN (search condition)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1199
msgid "\"activate\" = execute a triggered statement"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1200
msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1202
msgid "If there is more than one trigger for the same trigger event, Tarantool may execute the triggers in any order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1205
msgid "It is possible for a triggered statement to cause activation of another triggered statement. For example, this is legal:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1208
msgid "CREATE TRIGGER on_t1 BEFORE DELETE ON t1 BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER on_t2 BEFORE DELETE ON t2 BEGIN DELETE FROM t3; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1213
msgid "Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no rows are candidates for insert or update or delete, then no triggers are activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1216
msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1218
msgid "If an UPDATE trigger event does not make a change, the trigger is activated anyway. For example, if row 1 ``column1`` contains 'a', and the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1222
msgid "The triggered statement may refer to a function: ``RAISE(FAIL, error-message)``. If a triggered statement invokes a ``RAISE(FAIL, error-message)`` function, or if a triggered statement causes an error, then statement execution stops immediately."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1228
msgid "The triggered statement may refer to column values within the rows being changed. in this case:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1231
msgid "The row \"as of before\" the change is called the \"old\" row (which makes sense only for UPDATE and DELETE statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1233
msgid "The row \"as of after\" the change is called the \"new\" row (which makes sense only for UPDATE and INSERT statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1236
msgid "This example shows how an INSERT can be done to a view by referring to the \"new\" row:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1239
msgid "CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER tv INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1,2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1248
msgid "Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so this is a workaround."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1251
msgid "It is possible to generalize this so that all data-change statements on views will change the base tables, provided that the view contains all the columns of the base table, and provided that the triggers refer to those columns when necessary, as in this example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1256
msgid "CREATE TABLE base_table (primary_key_column INT PRIMARY KEY, value_column INT);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column);\n"
"  END;\n"
"CREATE TRIGGER viewed_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column;\n"
"  END;\n"
"CREATE TRIGGER viewed_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column;\n"
"  END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1275
msgid "When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually operates in this order (a basic scheme):"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1278
msgid "For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
msgid "However, Tarantool does not guarantee execution order when there are multiple constraints, or multiple triggers for the same event (including NoSQL ``on_replace`` triggers or SQL INSTEAD OF triggers that affect a view of table ``X``)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1298
msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
msgid "INSTEAD OF triggers"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1306
msgid "A trigger which is created with the clause |br| :samp:`INSTEAD OF {INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For each affected row, the trigger action is performed \"instead of\" the INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1312
msgid "For example, ordinarily it is illegal to INSERT rows in a view, but it is legal to create a trigger which intercepts attempts to INSERT, and puts rows in the underlying base table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1316
msgid "CREATE TABLE t1 (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER t1 INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1325
msgid "INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers are not legal for views."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1328
msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1332
msgid "It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* clauses, but they are not standard SQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1337
msgid "CREATE TRIGGER et1\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1348
msgid "DROP TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1352
msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1361
msgid "Drop a trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1363
msgid "The *trigger-name* must identify a trigger that was created earlier with the CREATE TRIGGER statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1370
msgid "Tarantool returns an error if the trigger does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1371
msgid "The trigger is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1376
msgid "-- the simple case:\n"
"DROP TRIGGER tr;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS tr;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1387
msgid "TRUNCATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1391
msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1400
msgid "Remove all rows in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1402
msgid "TRUNCATE is considered to be a schema-change rather than a data-change statement, so it does not work within transactions (it cannot be rolled back)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1407
msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1408
msgid "It is illegal to truncate a table which is also a system space, such as ``_space``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1410
msgid "The table must be a base table rather than a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1414
msgid "All rows in the table are removed. Usually this is faster than ``DELETE FROM table-name;``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1416
msgid "If the table has an autoincrement primary key, its sequence is reset to zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1417
msgid "There is no effect for any triggers associated with the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1418
msgid "There is no effect on the counts for the ``row_count()`` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1419
msgid "Only one action is written to the write-ahead log (with ``DELETE FROM table-name;`` there would be one action for each deleted row)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1425
msgid "TRUNCATE TABLE t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1433
msgid "SELECT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1437
msgid ":samp:`SELECT [ALL|DISTINCT] select-list [from clause] [where clause] [group-by clause] [having clause] [order-by clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1451
msgid "Select zero or more rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1453
msgid "The clauses of the SELECT statement are discussed in the following five sections."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1459
msgid "Select-list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1463
msgid ":samp:`select-list-column [, select-list-column ...] select-list-column:`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1473
msgid "Define what will be in a result set; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1475
msgid "The *select-list* is a comma-delimited list of expressions, or ``*`` (asterisk). An expression can have an alias provided with ``[AS [column-name]]`` clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1478
msgid "The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT statement also contains a FROM clause which specifies the table or tables (details about the FROM clause are in the next section). The simple form is ``*`` which means \"all columns\" -- for example, if the select is done for a table which contains three columns ``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all columns in the specified table\", which again must be a result of the FROM clause -- for example, if the table is named ``table1``, then ``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1490
msgid "The ``[AS [column-name]]`` clause determines the column name. The column name is useful for two reasons:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1493
msgid "in a tabular display, the column names are the headings"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1494
msgid "if the results of the SELECT are used in ``CREATE TABLE new-table-name ... AS SELECT select-list ...``, then the column names in the new table will be the column names in the *select-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1498
msgid "If ``[AS [column-name]]`` is missing, Tarantool makes a name equal to the expression, for example ``SELECT 5*88`` will cause the column name to be ``5*88``, but such names may be ambiguous or illegal in other contexts, so it is better to say, for example, ``SELECT 5 * 88 AS column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1505
msgid "-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1522
msgid "FROM clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1526
msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1535
msgid "Specify the table or tables for the source of a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1537
msgid "The *table-reference* must be a name of an existing table, or a subquery, or a joined table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1540
msgid "A joined table looks like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1542
msgid ":samp:`table-reference-or-joined-table join-operator table-reference-or-joined-table [join-specification]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1544
msgid "A *join-operator* must be any of `the standard types <https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1547
msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1548
msgid "[NATURAL] INNER JOIN, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1549
msgid "CROSS JOIN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1551
msgid "A *join-specification* must be any of:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1553
msgid "ON expression, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1554
msgid "USING (column-name [, column-name ...])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1556
msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1558
msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1562
msgid "-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1577
msgid "WHERE clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1581
msgid ":samp:`WHERE condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1590
msgid "Specify the condition for filtering rows from a table; this is a clause in a SELECT or UPDATE or DELETE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1593
msgid "The condition may contain any expression that returns a BOOLEAN (TRUE or FALSE or UNKNOWN) value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1596
#: ../doc/reference/reference_sql/sql.rst:1809
msgid "For each row in the table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1598
#: ../doc/reference/reference_sql/sql.rst:1811
msgid "if the condition is true, then the row is kept;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1599
#: ../doc/reference/reference_sql/sql.rst:1812
msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1601
msgid "In effect, WHERE condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1606
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1617
msgid "GROUP BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1621
msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1630
msgid "Make a grouped table; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1632
msgid "The expressions should be column names in the table, and each column should be specified only once."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1635
msgid "In effect, GROUP BY clause takes a table with rows that may have matching values, combines rows that have matching values into single rows, and returns a table which, because it is the result of GROUP BY, is called a grouped table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1640
msgid "Thus, if the input is a table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1642
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1652
msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1654
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1663
msgid "The rows where column ``a`` and column ``b`` have the same value have been merged; column ``c`` has been preserved but its value should not be depended on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1667
msgid "It is useful to envisage a grouped table as having hidden extra columns for the aggregation of the values, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1670
msgid "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'  'b'         2      2    'b'\n"
"1    'b'  'b'         1      1    'b'\n"
"2    'a'  'b'         1      2    'b'\n"
"     'a'  'b'         1      3    'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1679
msgid "These extra columns are what :ref:`aggregate functions <sql_aggregate>` are for."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1683
msgid "-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1692
msgid "``SELECT s1,s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1693
msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1694
msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1702
msgid "Aggregate functions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1706
#: ../doc/reference/reference_sql/sql.rst:2592
msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1708
msgid "Apply a built-in aggregate function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1711
msgid "Aggregate functions are only legal in certain clauses of SELECT for grouped tables. (A table is a grouped table if a GROUP BY clause is present.) Also, if an aggregate function is used in a select-list and GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1718
msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1725
msgid "``AVG([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1723
msgid "Return the average value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1725
msgid "Example: :samp:`AVG({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1732
msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1730
msgid "Return the number of occurrences of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1732
msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1739
msgid "``COUNT(*)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1737
msgid "Return the number of occurrences of a row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1739
msgid "Example: :samp:`COUNT(*)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1749
msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1744
msgid "Return a list of *expression-1* values, separated by commas if *expression-2* is omitted, or separated by the *expression-2* value if *expression-2* is not omitted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1749
msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1756
msgid "``MAX([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1754
msgid "Return the maximum value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1756
msgid "Example: :samp:`MAX({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1763
msgid "``MIN([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1761
msgid "Return the minimum value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1763
msgid "Example: :samp:`MIN({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1770
msgid "``SUM([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1768
#: ../doc/reference/reference_sql/sql.rst:1775
msgid "Return the sum of values of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1770
msgid "Example: :samp:`SUM({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1777
msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1777
msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1785
msgid "HAVING clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1789
msgid ":samp:`HAVING condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1798
msgid "Specify the condition for filtering rows from a grouped table; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1801
msgid "The clause preceding the HAVING clause may be a GROUP BY clause. HAVING operates on the table that the GROUP BY produces, which may contain grouped columns and aggregates."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1805
msgid "If the preceding clause is not a GROUP BY clause, then there is only one group and the HAVING clause may only contain aggregate functions or literals."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1814
msgid "In effect, HAVING condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1819
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1832
msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1838
msgid "ORDER BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1842
msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1851
msgid "Put rows in order; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1853
msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1855
msgid "Expression is a positive integer, representing the ordinal position of the column in the select list. For example, in the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order by the second column in the select list\", which is ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1860
msgid "Expression is a name of a column in the select list, which is determined by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1865
msgid "Expression contains a name of a column in a table of the FROM clause. For example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1871
msgid "If both tables contain a column named ``z``, then Tarantool will choose the first column that it finds."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1874
msgid "The expression may also contain operators and function names and literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column ``t.z``\", which may be similar to doing ordering in a case-insensitive manner."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1880
msgid "Type 3 is illegal if the SELECT statement contains UNION or EXCEPT or INTERSECT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1882
msgid "If an ORDER BY clause contains multiple expressions, then expressions on the left are processed first and expressions on the right are processed only if necessary for tie-breaking. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both have the same values for column ``x``, then an additional check is made to see which row has a greater value for column ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1891
msgid "In effect, ORDER BY clause takes a table with rows that may be out of order, and returns a table with rows in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1894
msgid "Sorting order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1896
msgid "The default order is ASC (ascending), the optional order is DESC (descending)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1897
msgid "NULLs come first, then numbers (INTEGER or NUMBER), then STRINGs, then VARBINARYs."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1898
msgid "Within STRINGs, ordering is according to collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1899
msgid "Collation may be specified within the ORDER BY column-list, or may be default."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1903
msgid "-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO h VALUES (7,'A'),(4,'A '),(-4,'AZ'),(17,17),(23,NULL);\n"
"INSERT INTO h VALUES (17.5,'Д'),(1e+300,'a'),(0,''),(-1,'');\n"
"SELECT * FROM h ORDER BY s2, s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [7, 'A']\n"
"  - [4, 'A ']\n"
"  - [-4, 'AZ']\n"
"  - [1e+300, 'a']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1928
msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1936
msgid "LIMIT clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1940
msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1941
msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1945
msgid "The above is not a typo: *offset-expression* and *limit-expression* are in reverse order if a comma is used."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1955
msgid "Specify a maximum number of rows and a start row; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1958
msgid "Expressions may contain integers and arithmetic operators or functions, for example ``ABS(-3/1)``. However, the result must be an integer value greater than or equal to zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1962
msgid "Usually the LIMIT clause follows an ORDER BY clause, because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1967
msgid "-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1978
msgid "If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all must be DESC."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1987
msgid "VALUES"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1991
msgid ":samp:`VALUES (expression [, expression ...]) [, (expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2000
msgid "Select one or more rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2002
msgid "VALUES has the same effect as SELECT, that is, it returns a result set, but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2005
msgid "VALUES may be used wherever SELECT may be used, for example in subqueries."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2009
msgid "-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2022
msgid "Subquery"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2026
msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2027
msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2029
msgid "A subquery has the same syntax as a SELECT statement or VALUES statement embedded inside a main statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2034
msgid "The SELECT and VALUES statements are called \"queries\" because they return answers, in the form of result sets."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2037
msgid "Subqueries may be the second part of INSERT statements. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2039
msgid "INSERT INTO t2 SELECT a,b,c FROM t1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2043
msgid "Subqueries may be in the FROM clause of SELECT statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2045
msgid "Subqueries may be expressions, or be inside expressions. In this case they must be parenthesized, and usually the number of rows must be 1. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2049
msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2053
msgid "Subqueries may be expressions on the right side of certain comparison operators, and in this unusual case the number of rows may be greater than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2057
msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2061
msgid "Subqueries may refer to values in the outer query. In this case, the subquery is called a \"correlated subquery\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2064
msgid "Subqueries may refer to rows which are being updated or deleted by the main query. In that case, the subquery finds the matching rows first, before starting to update or delete. For example, after:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2068
msgid "CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO t VALUES (1,3),(2,1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2074
msgid "only one of the rows is deleted, not both rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2080
msgid "WITH clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2082
msgid "**WITH clause (common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2086
msgid ":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement | DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2097
msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2101
msgid "is equivalent to creating a view and selecting from it:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2103
msgid "CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2108
msgid "The difference is that a WITH-clause \"view\" is temporary and only useful within the same statement. No CREATE privilege is required."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2111
msgid "The WITH-clause can also be thought of as a subquery that has a name. This is useful when the same subquery is being repeated. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2114
msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2118
msgid "can be replaced with:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2120
msgid "WITH S AS (SELECT s1 FROM x) SELECT * FROM t,S WHERE a < S.s1 AND b < S.s1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2124
msgid "This \"factoring out\" of a repeated expression is regarded as good practice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2128
msgid "WITH cte AS (VALUES (7,'') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2136
msgid "WITH can only be used at the beginning of a statement, therefore it cannot be used at the beginning of a subquery or after a set operator or inside a CREATE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2140
msgid "A WITH-clause \"view\" is read-only because Tarantool does not support updatable views."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2147
msgid "WITH RECURSIVE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2149
msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2151
msgid "The real power of WITH lies in the WITH RECURSIVE clause, which is useful when it is combined with UNION or UNION ALL:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2154
msgid ":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-recursive-table-name;` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2167
msgid "In non-SQL this can be read as: starting with a seed value from a non-recursive table, produce a recursive viewed table, UNION that with itself, UNION that with itself, UNION that with itself ... forever, or until a condition in the WHERE clause says \"stop\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2174
msgid "CREATE TABLE ts (s1 INT PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1+1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2184
msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2186
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [1] -- adds 1 because the select list says \"s1+1\", and so it has one row: [2]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2190
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [2] -- adds 1 because the select list says \"s1+1\", and so it has one row: [3]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2194
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [3] -- adds 1 because the select list says \"s1+1\", and so it has one row: [4]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2198
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [4] -- and now the importance of the WHERE clause becomes evident, because \"s1 < 4\" is false for this row, and therefore we have reached the \"stop\" condition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2203
msgid "So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and the result of the statement looks like:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2206
msgid "tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1+1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2220
msgid "In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-incrementing values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2227
msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2231
msgid ":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2232
msgid ":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2233
msgid ":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2252
msgid "UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or \"table operators\". In particular:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2255
msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2256
msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2257
msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2259
msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2261
msgid "The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT ...;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2263
msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2265
msgid "The *select-statements* may be replaced with VALUES statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2267
msgid "The maximum number of set operations is 50."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2271
msgid "CREATE TABLE t1 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t2 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t1 VALUES (1,'A'),(2,'B'),(3,NULL);\n"
"INSERT INTO t2 VALUES (1,'A'),(2,'C'),(3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2284
msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2285
msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2286
msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2287
msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2291
msgid "Parentheses are not allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2292
msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2296
msgid "CREATE TABLE t01 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t02 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t03 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t01 VALUES (1,'A');\n"
"INSERT INTO t02 VALUES (1,'B');\n"
"INSERT INTO t03 VALUES (1,'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2312
msgid "INDEXED BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2316
msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2325
msgid "The INDEXED BY clause may be used in a SELECT, DELETE, or UPDATE statement, immediately after the *table-name*. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2328
msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2332
msgid "In this case the search for 'a' will take place within ``index7``. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2334
msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2338
msgid "In this case the search for 'a' will be done via a search of the whole table, what is sometimes called a \"full table scan\", even if there is an index for ``column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2342
msgid "Ordinarily Tarantool chooses the appropriate index or lookup method depending on a complex set of \"optimizer\" rules; the INDEXED BY clause overrides the optimizer choice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2348
msgid "Suppose a table has two columns:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2350
msgid "The first column is the primary key and therefore it has an automatic index named ``pk_unnamed_T_1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2352
msgid "The second column has an index created by the user."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2354
msgid "The user selects with ``INDEXED BY the-index-on-column1``, then selects with ``INDEXED BY the-index-on-column-2``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2357
msgid "CREATE TABLE t (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE INDEX i ON t (column2);\n"
"INSERT INTO t VALUES (1,2),(2,1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY i;\n"
"-- Result for the first select: (1,2),(2,1)\n"
"-- Result for the second select: (2,1),(1,2)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2371
msgid "Transactions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2377
msgid "START TRANSACTION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2381
msgid ":samp:`START TRANSACTION;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2390
msgid "Start a transaction. After ``START TRANSACTION;``, a transaction is \"active\". If a transaction is already active, then ``START TRANSACTION;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2393
msgid "Transactions should be active for fairly short periods of time, to avoid concurrency issues. To end a transaction, say ``COMMIT;`` or ``ROLLBACK;``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2396
msgid "Just like in NoSQL, transaction control statements are subject to limitations set by the storage engine involved:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2399
msgid "For memtx storage engine, if a yield happens within an active transaction, the transaction is rolled back."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2401
msgid "For vinyl engine, yields are allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2403
msgid "However,transaction control statements still may not work as you expect when run over a network connection: a transaction is associated with a fiber, not a network connection, and different transaction control statements sent via the same network connection may be executed by different fibers from the fiber pool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2409
msgid "In order to ensure that all statements are part of the intended transaction, put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2413
msgid "Enclose each separate SQL statement in a :ref:`box.execute() <box-sql_box_execute>` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2415
msgid "Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2417
msgid "If you are using a console, you can do this by writing everything on a single line."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2420
msgid "If you are using :ref:`net.box <net_box-module>`, you can do this by putting all the function calls in a single string and calling :ref:`eval(string) <net_box-eval>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2426
msgid "START TRANSACTION;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2430
msgid "Example of a whole transaction sent to a server on ``localhost:3301`` with ``eval(string)``:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2433
msgid "net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION; ]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1); ]]) '\n"
"s = s .. 'box.execute([[ROLLBACK; ]]) '\n"
"conn:eval(s)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2446
msgid "COMMIT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2450
msgid ":samp:`COMMIT;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2459
msgid "Commit an active transaction, so all changes are made permanent and the transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2462
msgid "COMMIT is illegal unless a transaction is active. If a transaction is not active then SQL statements are committed automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2467
msgid "COMMIT;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2475
msgid "SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2479
msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2488
msgid "Set a savepoint, so that ROLLBACK TO *savepoint-name* is possible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2490
msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2492
msgid "If a savepoint with the same name already exists, it is released before the new savepoint is set."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2497
msgid "SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2505
msgid "RELEASE SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2509
msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2518
msgid "Release (destroy) a savepoint created by SAVEPOINT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2520
msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2522
msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2526
msgid "RELEASE SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2534
msgid "ROLLBACK"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2538
msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2547
msgid "If ROLLBACK does not specify a *savepoint-name*, rollback an active transaction, so all changes since START TRANSACTION are cancelled, and the transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2552
msgid "If ROLLBACK does specify a *savepoint-name*, rollback an active transaction, so all changes since *savepoint-name* are cancelled, and the transaction does not end."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2557
msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2561
msgid "-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2568
msgid "-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 VARCHAR(20) PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2588
msgid "Functions"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2594
msgid "Apply a built-in function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2596
msgid "Tarantool supports 32 built-in functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2602
msgid "CHAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2606
msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2608
msgid "Return the characters whose Unicode code point values are equal to the numeric expressions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2611
msgid "Short example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2613
msgid "The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65,66,67) is 'ABC'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2616
msgid "Long example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2618
msgid "For the current list of Unicode characters, in order by code point, see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt <http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that list, there is a line for a Linear B ideogram"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2624
msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2626
msgid "Therefore, for a string with a chariot in the middle, use the concatenation operator ``||`` and the CHAR function"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2629
msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2635
msgid "COALESCE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2639
msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2641
msgid "Return the value of the first non-NULL expression, or, if all expression values are NULL, return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2645
msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2651
msgid "HEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2655
msgid ":samp:`HEX(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2657
msgid "Return the hexadecimal code for each byte in **expression**, which may be either a string or a byte sequence. For ASCII characters, this is straightforward because the encoding is the same as the code point value. For non-ASCII characters, since character strings are usually encoded in UTF-8, each character will require two or more bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2668
msgid "``HEX('A')`` will return ``41``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2669
msgid "``HEX('Д')`` will return ``D094``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2675
msgid "IFNULL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2679
msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2681
msgid "Return the value of the first non-NULL expression, or, if both expression values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the same as :ref:`COALESCE(expression, expression) <sql_function_coalesce>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2687
msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2693
msgid "LENGTH"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2697
msgid ":samp:`LENGTH(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2699
msgid "Return the number of characters in the **expression**, or the number of bytes in the **expression**. It depends on the data type: strings with data type STRING are counted in characters, byte sequences with data type VARBINARY are counted in bytes and are not ended by the nul character. There are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2710
msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2711
msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2712
msgid "``LENGTH(CHAR(0,65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2713
msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2719
msgid "LOWER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2723
msgid ":samp:`LOWER(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2725
msgid "Return the expression, with upper-case characters converted to lower case. This is the reverse of :ref:`UPPER(string-expression) <sql_function_upper>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2728
msgid "Example: ``LOWER('-4ЩL')`` is '-4щl'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2734
msgid "NULLIF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2738
msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2740
msgid "Return *expression-1* if *expression-1* <> *expression-2*, otherwise return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2745
msgid "``NULLIF('a','A')`` is 'a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2746
msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2752
msgid "PRINTF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2756
msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2758
msgid "Return a string formatted according to the rules of the C ``sprintf()`` function, where ``%d%s`` means the next two arguments are a number and a string, etc."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2762
msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2764
msgid "'0' if the format requires an integer,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2765
msgid "'0.0' if the format requires a decimal number,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2766
msgid "'' if the format requires a string."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2768
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2774
msgid "QUOTE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2778
msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2780
msgid "Return a string with enclosing quotes if necessary, and with quotes inside the enclosing quotes if necessary. This function is useful for creating strings which are part of SQL statements, because of SQL's rules that string literals are enclosed by single quotes, and single quotes inside such strings are shown as two single quotes in a row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2787
msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2793
msgid "SOUNDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2797
msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2799
msgid "Return a four-character string which represents the sound of ``string-expression``. Often words and names which have different spellings will have the same Soundex representation if they are pronounced similarly, so it is possible to search by what they sound like. The algorithm works with characters in the Latin alphabet and works best with English words."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2807
msgid "Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return ``C636``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2813
msgid "UNICODE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2817
msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2819
msgid "Return the Unicode code point value of the first character of **string-expression**. If *string-expression* is empty, the return is NULL. This is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2823
msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2829
msgid "UPPER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2833
msgid ":samp:`UPPER(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2835
msgid "Return the expression, with lower-case characters converted to upper case. This is the reverse of :ref:`LOWER(string-expression)<sql_function_lower>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2838
msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2844
msgid "VERSION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2848
msgid ":samp:`VERSION()`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2850
msgid "Return the Tarantool version."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2852
msgid "Example: for a March 2019 build VERSION() is ``2.1.1-374-g27283debc``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:5
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:7
msgid "``tarantoolctl`` is a utility for administering Tarantool :ref:`instances <tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:13
msgid "See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:20
msgid "Command format"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:22
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:24
msgid "where:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:26
msgid "``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, ``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:30
msgid "``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:`module <app_server-modules>`."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:33
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:35
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:37
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:43
msgid "Commands for managing Tarantool instances"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:61
msgid "``tarantoolctl start NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:46
msgid "Start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:48
msgid "Additionally, this command sets the TARANTOOLCTL environment variable to 'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:53
msgid "``tarantoolctl`` works for instances without ``box.cfg{}`` called or with delayed ``box.cfg{}`` call."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:56
msgid "For example, this can be used to manage instances which receive configuration from an external server. For such instances, ``tarantoolctl start`` goes to background when ``box.cfg{}`` is called, so it will wait until options for ``box.cfg`` are received. However this is not the case for daemon management systems like ``systemd``, as they handle backgrounding on their side."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:64
msgid "``tarantoolctl stop NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:64
msgid "Stop a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:72
msgid "``tarantoolctl status NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:67
msgid "Show an instance's status (started/stopped). If pid file exists and an alive control socket exists, the return code is ``0``. Otherwise, the return code is not ``0``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:71
msgid "Reports typical problems to stderr (e.g. pid file exists and control socket doesn't)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:79
msgid "``tarantoolctl restart NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:75
msgid "Stop and start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:77
msgid "Additionally, this command sets the TARANTOOL_RESTARTED environment variable to 'true', to mark that the instance was restarted by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:84
msgid "``tarantoolctl logrotate NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:82
msgid "Rotate logs of a started Tarantool instance. Works only if logging-into-file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:87
msgid "``tarantoolctl check NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:87
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:95
msgid "``tarantoolctl enter NAME [--language=language]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:90
msgid "Enter an instance's interactive Lua or SQL console."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:92
msgid "Supported option:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:94
msgid "``--language=language`` to set :ref:`interactive console <interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:98
msgid "``tarantoolctl eval NAME FILE``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:98
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:102
msgid "``tarantoolctl connect URI``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:101
msgid "Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix sockets."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:108
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:111
msgid "``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:111
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:114
msgid "``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:114
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:116
#: ../doc/reference/tarantoolctl.rst:167
msgid "Supported options:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:118
msgid "``--space=space_no`` to filter the output by space number. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:120
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:121
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:122
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:123
msgid "``--replica=replica_id`` to filter the output by replica id. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:130
msgid "Commands for managing Tarantool modules"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:133
msgid "``tarantoolctl rocks install NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:133
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:136
msgid "``tarantoolctl rocks remove NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:136
msgid "Remove a module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:139
msgid "``tarantoolctl rocks show NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:139
msgid "Show information about an installed module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:142
msgid "``tarantoolctl rocks search NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:142
msgid "Search the repository for modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:145
msgid "``tarantoolctl rocks list``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:145
msgid "List all installed modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:155
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:148
msgid "Create a rock by packing sources or binaries."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:150
#: ../doc/reference/tarantoolctl.rst:160
msgid "As an argument, you can specify:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:152
msgid "a ``.rockspec`` file to create a source rock containing the module's sources, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:154
msgid "the name of an installed module (and its version if there are more than one) to create a binary rock containing the compiled module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:165
msgid "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> [version]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:158
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:162
msgid "source or binary rock files,"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:163
msgid "``.rockspec`` files, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:164
msgid "names of rocks or ``.rockspec`` files in remote repositories (and the rock version if there are more than one)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:169
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:170
msgid "``--only-server=server_name`` check this server only, ignore the usual list."
msgstr ""

