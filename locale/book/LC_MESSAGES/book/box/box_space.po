# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../doc/book/box/box_space.rst:5
msgid "Submodule `box.space`"
msgstr ""

#: ../doc/book/box/box_space.rst:9
msgid "Overview"
msgstr ""

#: ../doc/book/box/box_space.rst:11
msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:19
msgid "Index"
msgstr ""

#: ../doc/book/box/box_space.rst:21
msgid "Below is a list of all ``box.space`` functions and members."
msgstr ""

#: ../doc/book/box/box_space.rst:29 ../doc/book/box/box_space.rst:282
#: ../doc/book/box/box_space.rst:2000
msgid "Name"
msgstr ""

#: ../doc/book/box/box_space.rst:29
msgid "Use"
msgstr ""

#: ../doc/book/box/box_space.rst:31
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/book/box/box_space.rst:31
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:34
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/book/box/box_space.rst:34
msgid "Get count of bytes"
msgstr ""

#: ../doc/book/box/box_space.rst:37
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:37 ../doc/book/box/box_space.rst:61
msgid "Get count of tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:40
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:40
msgid "Create an index"
msgstr ""

#: ../doc/book/box/box_space.rst:43
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/book/box/box_space.rst:43
msgid "Delete a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:46
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/book/box/box_space.rst:46
msgid "Destroy a space"
msgstr ""

#: ../doc/book/box/box_space.rst:49
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ""

#: ../doc/book/box/box_space.rst:49
msgid "Declare field names and types"
msgstr ""

#: ../doc/book/box/box_space.rst:52
msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ""

#: ../doc/book/box/box_space.rst:52
msgid "Convert from map to tuple or table"
msgstr ""

#: ../doc/book/box/box_space.rst:55
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/book/box/box_space.rst:55
msgid "Select a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:58
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:58
msgid "Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:61
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/book/box/box_space.rst:64
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:64
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:68
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:68
msgid "Create a replace trigger with a function that can change the tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:72
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:72
msgid "Prepare for iterating"
msgstr ""

#: ../doc/book/box/box_space.rst:75
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:75 ../doc/book/box/box_space.rst:81
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:78
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/book/box/box_space.rst:78
msgid "Rename a space"
msgstr ""

#: ../doc/book/box/box_space.rst:81
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/book/box/box_space.rst:87
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/book/box/box_space.rst:87
msgid "Select one or more tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:93
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/book/box/box_space.rst:93 ../doc/book/box/box_space.rst:96
msgid "Update a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:96
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:99
msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ""

#: ../doc/book/box/box_space.rst:99
msgid "Any function / method that any user wants to add"
msgstr ""

#: ../doc/book/box/box_space.rst:102
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/book/box/box_space.rst:102
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/book/box/box_space.rst:105
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:105
msgid "Required number of fields"
msgstr ""

#: ../doc/book/box/box_space.rst:108
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/book/box/box_space.rst:108
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/book/box/box_space.rst:111
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:111
msgid "Container of space's indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:114
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/book/box/box_space.rst:114
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/book/box/box_space.rst:117
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/book/box/box_space.rst:117
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:120
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:120
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:123
msgid ":ref:`box.space._vindex <box_space-vindex>`"
msgstr ""

#: ../doc/book/box/box_space.rst:123
msgid "(Metadata) List of indexes accessible for the current user"
msgstr ""

#: ../doc/book/box/box_space.rst:126
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/book/box/box_space.rst:126
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/book/box/box_space.rst:129
msgid ":ref:`box.space._vpriv <box_space-vpriv>`"
msgstr ""

#: ../doc/book/box/box_space.rst:129
msgid "(Metadata) List of privileges accessible for the current user"
msgstr ""

#: ../doc/book/box/box_space.rst:132
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/book/box/box_space.rst:132
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/book/box/box_space.rst:135
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ""

#: ../doc/book/box/box_space.rst:135 ../doc/book/box/box_space.rst:138
msgid "(Metadata) List of sequences"
msgstr ""

#: ../doc/book/box/box_space.rst:138
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ""

#: ../doc/book/box/box_space.rst:141
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/book/box/box_space.rst:141
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/book/box/box_space.rst:144
msgid ":ref:`box.space._vspace <box_space-vspace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:144
msgid "(Metadata) List of spaces accessible for the current user"
msgstr ""

#: ../doc/book/box/box_space.rst:147
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/book/box/box_space.rst:147
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/book/box/box_space.rst:150
msgid ":ref:`box.space._vuser <box_space-vuser>`"
msgstr ""

#: ../doc/book/box/box_space.rst:150
msgid "(Metadata) List of users accessible for the current user"
msgstr ""

#: ../doc/book/box/box_space.rst:162
msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have an :ref:`'unsigned' or 'integer' or "
"'number' <index-box_indexed-field-types>` primary key index of type "
"``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../doc/book/box/box_space.rst:168
msgid ""
"Since version 1.7.5 this method is deprecated â€“ it is better to use a "
":ref:`sequence <index-box_sequence>`."
msgstr ""

#: ../doc/book/box/box_space.rst
msgid "Parameters"
msgstr ""

#: ../doc/book/box/box_space.rst:171 ../doc/book/box/box_space.rst:204
#: ../doc/book/box/box_space.rst:231 ../doc/book/box/box_space.rst:258
#: ../doc/book/box/box_space.rst:497 ../doc/book/box/box_space.rst:537
#: ../doc/book/box/box_space.rst:559 ../doc/book/box/box_space.rst:708
#: ../doc/book/box/box_space.rst:751 ../doc/book/box/box_space.rst:802
#: ../doc/book/box/box_space.rst:834 ../doc/book/box/box_space.rst:1036
#: ../doc/book/box/box_space.rst:1098 ../doc/book/box/box_space.rst:1128
#: ../doc/book/box/box_space.rst:1184 ../doc/book/box/box_space.rst:1286
#: ../doc/book/box/box_space.rst:1347 ../doc/book/box/box_space.rst:1468
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/book/box/box_space.rst:173
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/book/box/box_space.rst
msgid "return"
msgstr ""

#: ../doc/book/box/box_space.rst:176 ../doc/book/box/box_space.rst:1132
msgid "the inserted tuple."
msgstr ""

#: ../doc/book/box/box_space.rst
msgid "rtype"
msgstr ""

#: ../doc/book/box/box_space.rst:177 ../doc/book/box/box_space.rst:503
#: ../doc/book/box/box_space.rst:757 ../doc/book/box/box_space.rst:807
#: ../doc/book/box/box_space.rst:1133 ../doc/book/box/box_space.rst:1359
msgid "tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:179
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-"
"rows_per_wal>`."
msgstr ""

#: ../doc/book/box/box_space.rst:182 ../doc/book/box/box_space.rst:336
#: ../doc/book/box/box_space.rst:565 ../doc/book/box/box_space.rst:1047
#: ../doc/book/box/box_space.rst:1206 ../doc/book/box/box_space.rst:1481
msgid "**Possible errors:**"
msgstr ""

#: ../doc/book/box/box_space.rst:184
msgid "index has wrong type;"
msgstr ""

#: ../doc/book/box/box_space.rst:185
msgid "primary-key indexed field is not a number."
msgstr ""

#: ../doc/book/box/box_space.rst:187 ../doc/book/box/box_space.rst:213
#: ../doc/book/box/box_space.rst:239 ../doc/book/box/box_space.rst:510
#: ../doc/book/box/box_space.rst:547 ../doc/book/box/box_space.rst:622
#: ../doc/book/box/box_space.rst:721 ../doc/book/box/box_space.rst:770
#: ../doc/book/box/box_space.rst:812 ../doc/book/box/box_space.rst:839
#: ../doc/book/box/box_space.rst:1015 ../doc/book/box/box_space.rst:1063
#: ../doc/book/box/box_space.rst:1106 ../doc/book/box/box_space.rst:1142
#: ../doc/book/box/box_space.rst:1163 ../doc/book/box/box_space.rst:1213
#: ../doc/book/box/box_space.rst:1301 ../doc/book/box/box_space.rst:1378
#: ../doc/book/box/box_space.rst:1490 ../doc/book/box/box_space.rst:1526
#: ../doc/book/box/box_space.rst:1564 ../doc/book/box/box_space.rst:1582
#: ../doc/book/box/box_space.rst:1603 ../doc/book/box/box_space.rst:1658
#: ../doc/book/box/box_space.rst:1818 ../doc/book/box/box_space.rst:2094
msgid "**Example:**"
msgstr ""

#: ../doc/book/box/box_space.rst:189
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:207
msgid ""
"Number of bytes in the space. This number, which is stored in Tarantool's"
" internal memory, represents the total number of bytes in all tuples, not"
" including index keys. For a measure of index size, see "
":ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""

#: ../doc/book/box/box_space.rst:215
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:226
msgid ""
"Return the number of tuples. If compared with :ref:`len() <box_space-"
"len>`, this method works slower because ``count()`` scans the entire "
"space to count the tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:233 ../doc/book/box/box_space.rst:499
#: ../doc/book/box/box_space.rst:1349
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""

#: ../doc/book/box/box_space.rst:235
msgid "comparison method"
msgstr ""

#: ../doc/book/box/box_space.rst:237
msgid "Number of tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:241
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:252
msgid ""
"Create an :ref:`index <index-box_index>`. It is mandatory to create an "
"index for a space before trying to insert tuples into it, or select "
"tuples from it. The first created index, which will be used as the "
"primary-key index, must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:260
msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""

#: ../doc/book/box/box_space.rst:262
msgid "see \"Options for space_object:create_index()\", below"
msgstr ""

#: ../doc/book/box/box_space.rst:265
msgid "index object"
msgstr ""

#: ../doc/book/box/box_space.rst:266
msgid "index_object"
msgstr ""

#: ../doc/book/box/box_space.rst:270
msgid "**Options for space_object:create_index()**"
msgstr ""

#: ../doc/book/box/box_space.rst:282
msgid "Effect"
msgstr ""

#: ../doc/book/box/box_space.rst:282 ../doc/book/box/box_space.rst:2000
msgid "Type"
msgstr ""

#: ../doc/book/box/box_space.rst:282
msgid "Default"
msgstr ""

#: ../doc/book/box/box_space.rst:284
msgid "type"
msgstr ""

#: ../doc/book/box/box_space.rst:284
msgid "type of index"
msgstr ""

#: ../doc/book/box/box_space.rst:284
msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""

#: ../doc/book/box/box_space.rst:284
msgid "'TREE'"
msgstr ""

#: ../doc/book/box/box_space.rst:290
msgid "id"
msgstr ""

#: ../doc/book/box/box_space.rst:290
msgid "unique identifier"
msgstr ""

#: ../doc/book/box/box_space.rst:290 ../doc/book/box/box_space.rst:303
#: ../doc/book/box/box_space.rst:308 ../doc/book/box/box_space.rst:310
#: ../doc/book/box/box_space.rst:312 ../doc/book/box/box_space.rst:314
#: ../doc/book/box/box_space.rst:316
msgid "number"
msgstr ""

#: ../doc/book/box/box_space.rst:290
msgid "last index's id, +1"
msgstr ""

#: ../doc/book/box/box_space.rst:292
msgid "unique"
msgstr ""

#: ../doc/book/box/box_space.rst:292
msgid "index is unique"
msgstr ""

#: ../doc/book/box/box_space.rst:292 ../doc/book/box/box_space.rst:294
msgid "boolean"
msgstr ""

#: ../doc/book/box/box_space.rst:292
msgid "``true``"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "if_not_exists"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "no error if duplicate name"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "``false``"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid "parts"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid "field-numbers  + types"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'boolean' "
"or 'array' or 'scalar', and optional collation, and optional is_nullable "
"value}"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/book/box/box_space.rst:303
msgid "dimension"
msgstr ""

#: ../doc/book/box/box_space.rst:303
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr ""

#: ../doc/book/box/box_space.rst:303 ../doc/book/box/box_space.rst:2010
msgid "2"
msgstr ""

#: ../doc/book/box/box_space.rst:305
msgid "distance"
msgstr ""

#: ../doc/book/box/box_space.rst:305
msgid "affects RTREE only"
msgstr ""

#: ../doc/book/box/box_space.rst:305
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/book/box/box_space.rst:305
msgid "'euclid'"
msgstr ""

#: ../doc/book/box/box_space.rst:308
msgid "bloom_fpr"
msgstr ""

#: ../doc/book/box/box_space.rst:308 ../doc/book/box/box_space.rst:310
#: ../doc/book/box/box_space.rst:312 ../doc/book/box/box_space.rst:314
#: ../doc/book/box/box_space.rst:316
msgid "affects vinyl only"
msgstr ""

#: ../doc/book/box/box_space.rst:308
msgid "``vinyl_bloom_fpr``"
msgstr ""

#: ../doc/book/box/box_space.rst:310
msgid "page_size"
msgstr ""

#: ../doc/book/box/box_space.rst:310
msgid "``vinyl_page_size``"
msgstr ""

#: ../doc/book/box/box_space.rst:312
msgid "range_size"
msgstr ""

#: ../doc/book/box/box_space.rst:312
msgid "``vinyl_range_size``"
msgstr ""

#: ../doc/book/box/box_space.rst:314
msgid "run_count_per_level"
msgstr ""

#: ../doc/book/box/box_space.rst:314
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/book/box/box_space.rst:316
msgid "run_size_ratio"
msgstr ""

#: ../doc/book/box/box_space.rst:316
msgid "``vinyl_run_size_ratio``"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid "sequence"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid "string or number"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid "not present"
msgstr ""

#: ../doc/book/box/box_space.rst:323
msgid ""
"The options in the above chart are also applicable for "
":ref:`index_object:alter() <box_index-alter>`."
msgstr ""

#: ../doc/book/box/box_space.rst:325
msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/book/box/box_space.rst:338
msgid "too many parts;"
msgstr ""

#: ../doc/book/box/box_space.rst:339
msgid "index '...' already exists;"
msgstr ""

#: ../doc/book/box/box_space.rst:340
msgid "primary key must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:342
msgid ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = { {field = "
"1, type = 'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:353
msgid "**Details about index field types:**"
msgstr ""

#: ../doc/book/box/box_space.rst:355
msgid ""
"The seven index field types (unsigned | string | integer | number | "
"boolean | array | scalar) differ depending on what values are allowed, "
"and what index types are allowed."
msgstr ""

#: ../doc/book/box/box_space.rst:359
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about"
" 18 quintillion. May also be called 'uint' or 'num', but 'num' is "
"deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:363
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in "
"memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string"
" may have a :ref:`collation <index-collation>`."
msgstr ""

#: ../doc/book/box/box_space.rst:367
msgid ""
"**integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:370
msgid ""
"**number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:374
msgid ""
"**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:376
msgid ""
"**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-"
"rtree>` indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:377
msgid ""
"**scalar**: booleans (true or false), or integers between "
"-9223372036854775808 and 18446744073709551615, or single-precision "
"floating point numbers, or double-precison floating-point numbers, or "
"strings. When there is a mix of types, the key order is: booleans, then "
"numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl "
"TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:384
msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""

#: ../doc/book/box/box_space.rst:389
msgid "**Index field types to use in space_object:create_index()**"
msgstr ""

#: ../doc/book/box/box_space.rst:402
msgid "Index field type"
msgstr ""

#: ../doc/book/box/box_space.rst:402
msgid "What can be in it"
msgstr ""

#: ../doc/book/box/box_space.rst:402
msgid "Where is it legal"
msgstr ""

#: ../doc/book/box/box_space.rst:402
msgid "Examples"
msgstr ""

#: ../doc/book/box/box_space.rst:404
msgid "**unsigned**"
msgstr ""

#: ../doc/book/box/box_space.rst:404
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:404 ../doc/book/box/box_space.rst:411
#: ../doc/book/box/box_space.rst:415 ../doc/book/box/box_space.rst:423
#: ../doc/book/box/box_space.rst:430
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:404
msgid "123456 |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:408
msgid "**string**"
msgstr ""

#: ../doc/book/box/box_space.rst:408
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/book/box/box_space.rst:408
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:408
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/book/box/box_space.rst:411
msgid "**integer**"
msgstr ""

#: ../doc/book/box/box_space.rst:411
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:411
msgid "-2^63 |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:415
msgid "**number**"
msgstr ""

#: ../doc/book/box/box_space.rst:415
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/book/box/box_space.rst:415
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/book/box/box_space.rst:423
msgid "**boolean**"
msgstr ""

#: ../doc/book/box/box_space.rst:423
msgid "true or false"
msgstr ""

#: ../doc/book/box/box_space.rst:423
msgid "false |br| true"
msgstr ""

#: ../doc/book/box/box_space.rst:426
msgid "**array**"
msgstr ""

#: ../doc/book/box/box_space.rst:426
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/book/box/box_space.rst:426
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:426
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/book/box/box_space.rst:430
msgid "**scalar**"
msgstr ""

#: ../doc/book/box/box_space.rst:430
msgid ""
"booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""

#: ../doc/book/box/box_space.rst:430
msgid "true |br| -1 |br| 1.234 |br| '' |br| 'Ñ€Ñƒ'"
msgstr ""

#: ../doc/book/box/box_space.rst:442
msgid ""
"**Allowing null for an indexed key:** If the index type is TREE, and the "
"index is not the primary index, then the ``parts={...}`` clause may "
"include ``is_nullable=true`` or ``is_nullable=false`` (the default). If "
"``is_nullable`` is true, then it is legal to insert ``nil`` or an "
"equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at "
"all for trailing nullable fields). Within indexes, such \"null values\" "
"are always treated as equal to other null values, and are always treated "
"as less than non-null values. Nulls may appear multiple times even in a "
"unique index. Example:"
msgstr ""

#: ../doc/book/box/box_space.rst:451
msgid "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:457
msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call :ref:`space_object:format() "
"<box_space-format>` with a different ``is_nullable`` value from what is "
"used for an index. When there is a contradiction, the rule is: null is "
"illegal unless ``is_nullable=true`` for every index and for the space "
"format."
msgstr ""

#: ../doc/book/box/box_space.rst:465
msgid ""
"**Using field names instead of field numbers:** ``create_index()`` can "
"use field names and/or field types described by the optional "
":ref:`space_object:format() <box_space-format>` clause. In the following "
"example, we show ``format()`` for a space that has two columns named 'x' "
"and 'y', and then we show five variations of the ``parts={}`` clause of "
"``create_index()``, first for the 'x' column, second for both the 'x' and"
" 'y' columns. The variations include omitting the type, using numbers, "
"and adding extra braces."
msgstr ""

#: ../doc/book/box/box_space.rst:474
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:488
msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:495
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/book/box/box_space.rst:502
msgid "the deleted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:505
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/book/box/box_space.rst:507
msgid ""
"**Note re storage engine:** vinyl will return ``nil``, rather than the "
"deleted tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:512
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:527 ../doc/book/box/box_space.rst:821
#: ../doc/book/box/box_space.rst:1148 ../doc/book/box/box_space.rst:1276
#: ../doc/book/box/box_space.rst:1448 ../doc/book/box/box_space.rst:1496
msgid ""
"For more usage scenarios and typical errors see :ref:`Example: using data"
" operations <box_space-operations-detailed-examples>` further in this "
"section."
msgstr ""

#: ../doc/book/box/box_space.rst:535
msgid "Drop a space."
msgstr ""

#: ../doc/book/box/box_space.rst:540 ../doc/book/box/box_space.rst:1102
#: ../doc/book/box/box_space.rst:1161 ../doc/book/box/box_space.rst:1291
msgid "nil"
msgstr ""

#: ../doc/book/box/box_space.rst:542 ../doc/book/box/box_space.rst:759
#: ../doc/book/box/box_space.rst:1104
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/book/box/box_space.rst:544 ../doc/book/box/box_space.rst:761
#: ../doc/book/box/box_space.rst:1139
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:549
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/book/box/box_space.rst:557
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr ""

#: ../doc/book/box/box_space.rst:561
msgid "a list of field names and types"
msgstr ""

#: ../doc/book/box/box_space.rst:563
msgid "nil, unless format-clause is omitted"
msgstr ""

#: ../doc/book/box/box_space.rst:567
msgid "``space_object`` does not exist;"
msgstr ""

#: ../doc/book/box/box_space.rst:568
msgid "field names are duplicated;"
msgstr ""

#: ../doc/book/box/box_space.rst:569
msgid "type is not legal."
msgstr ""

#: ../doc/book/box/box_space.rst:571
msgid ""
"Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` "
"users can, for example, document that the Nth field is the surname field "
"and must contain strings. It is also possible to specify a format clause "
"in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:577
msgid ""
"The format clause contains, for each field, a definition within braces: "
"``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""

#: ../doc/book/box/box_space.rst:580
msgid ""
"the ``name`` value may be any string, provided that two fields do not "
"have the same name;"
msgstr ""

#: ../doc/book/box/box_space.rst:582
msgid ""
"the ``type`` value may be any of those allowed for :ref:`indexed fields "
"<index-box_indexed-field-types>`: unsigned | string | integer | number | "
"boolean | array | scalar (the same as the requirement in :ref:`\"Options "
"for space_object:create_index\" <box_space-create_index-options>`);"
msgstr ""

#: ../doc/book/box/box_space.rst:587
msgid ""
"the optional ``is_nullable`` value may be either ``true`` or ``false`` "
"(the same as the requirement in :ref:`\"Options for "
"space_object:create_index\" <box_space-create_index-options>`). See also "
"the warning notice in section :ref:`Allowing null for an indexed key "
"<box_space-is_nullable>`."
msgstr ""

#: ../doc/book/box/box_space.rst:593
msgid ""
"It is not legal for tuples to contain values that have the wrong type; "
"for example after ``box.space.tester:format({{' ',type='number'}})`` the "
"request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will "
"cause an error."
msgstr ""

#: ../doc/book/box/box_space.rst:597
msgid ""
"It is not legal for tuples to contain null values if "
"``is_nullable=false``, which is the default; for example after "
"``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the "
"request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""

#: ../doc/book/box/box_space.rst:601
msgid ""
"It is legal for tuples to have more fields than are described by a format"
" clause. The way to constrain the number of fields is to specify a "
"space's :ref:`field_count <box_space-field_count>` member."
msgstr ""

#: ../doc/book/box/box_space.rst:605
msgid ""
"It is legal for tuples to have fewer fields than are described by a "
"format clause, if the omitted trailing fields are described with "
"``is_nullable=true``; for example after "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" the request ``box.space.tester:insert{2}`` will not cause a format-"
"related error."
msgstr ""

#: ../doc/book/box/box_space.rst:610
msgid ""
"It is legal to use ``format`` on a space that already has a format, thus "
"replacing any previous definitions, provided that there is no conflict "
"with existing data or index definitions."
msgstr ""

#: ../doc/book/box/box_space.rst:614
msgid ""
"It is legal to use ``format`` to change the ``is_nullable`` flag; for "
"example after ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` the request "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will "
"not cause an error -- and will not cause rebuilding of the space. But "
"going the other way and changing ``is_nullable`` from ``true`` to "
"``false`` might cause rebuilding and might cause an error if there are "
"existing tuples with nulls."
msgstr ""

#: ../doc/book/box/box_space.rst:624
msgid ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""

#: ../doc/book/box/box_space.rst:630
msgid "There are legal variations of the format clause:"
msgstr ""

#: ../doc/book/box/box_space.rst:632
msgid "omitting both 'name=' and 'type=',"
msgstr ""

#: ../doc/book/box/box_space.rst:633
msgid "omitting 'type=' alone, and"
msgstr ""

#: ../doc/book/box/box_space.rst:634
msgid "adding extra braces."
msgstr ""

#: ../doc/book/box/box_space.rst:636
msgid ""
"The following examples show all the variations, first for one field named"
" 'x', second for two fields named 'x' and 'y'."
msgstr ""

#: ../doc/book/box/box_space.rst:639
msgid ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:652
msgid ""
"The following example shows how to create a space, format it with all "
"possible types, and insert into it."
msgstr ""

#: ../doc/book/box/box_space.rst:655
msgid ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:684
msgid ""
"Names specified with the format clause can be used in "
":ref:`space_object:get() <box_space-get>` and in "
":ref:`space_object:create_index() <box_space-create_index>` and in "
":ref:`tuple_object[field-name] <box_tuple-field_name>` and in "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""

#: ../doc/book/box/box_space.rst:690
msgid ""
"If the format clause is omitted, then the returned value is the table "
"that was used in a previous :samp:`{space_object}:format({format-"
"clause})` invocation. For example, after "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` will return ``[{'name': 'x', 'type': "
"'scalar'}]``."
msgstr ""

#: ../doc/book/box/box_space.rst:695
msgid ""
"**Note re storage engine:** vinyl supports formatting of non-empty "
"spaces. Primary index definition cannot be formatted."
msgstr ""

#: ../doc/book/box/box_space.rst:702
msgid ""
"Convert a map to a tuple instance or to a table. The map must consist of "
"\"field name = value\" pairs. The field names and the value types must "
"match names and types stated previously for the space, via "
":ref:`space_object:format() <box_space-format>`."
msgstr ""

#: ../doc/book/box/box_space.rst:710
msgid "a series of \"field = value\" pairs, in any order."
msgstr ""

#: ../doc/book/box/box_space.rst:711
msgid ""
"the only legal option is ``{table = true|false}``; |br| if the option is "
"omitted or if ``{table = false}``, then return type will be 'cdata' (i.e."
" tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""

#: ../doc/book/box/box_space.rst:716
msgid "a tuple instance or table."
msgstr ""

#: ../doc/book/box/box_space.rst:717
msgid "tuple or table"
msgstr ""

#: ../doc/book/box/box_space.rst:719
msgid ""
"**Possible errors:** ``space_object`` does not exist or has no format; "
"\"unknown field\"."
msgstr ""

#: ../doc/book/box/box_space.rst:723
msgid ""
"-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:749
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:753 ../doc/book/box/box_space.rst:1186
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/book/box/box_space.rst:756
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/book/box/box_space.rst:764
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/book/box/box_space.rst:772
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/book/box/box_space.rst:776
msgid ""
"**Using field names instead of field numbers:** `get()` can use field "
"names described by the optional :ref:`space_object:format() <box_space-"
"format>` clause. This is similar to a standard Lua feature, where a "
"component can be referenced by its name instead of its number. For "
"example, we can format the `tester` space with a field named `x` and use "
"the name `x` in the index definition:"
msgstr ""

#: ../doc/book/box/box_space.rst:783
msgid ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:788
msgid ""
"Then, if ``get`` or ``select`` retrieve a single tuple, we can reference "
"the field 'x' in the tuple by its name:"
msgstr ""

#: ../doc/book/box/box_space.rst:791
msgid ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""

#: ../doc/book/box/box_space.rst:800
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/book/box/box_space.rst:804
msgid "tuple to be inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:806
msgid "the inserted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:809
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same "
"unique-key value already exists."
msgstr ""

#: ../doc/book/box/box_space.rst:814
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:829
msgid ""
"Return the number of tuples in the space. If compared with :ref:`count() "
"<box_space-count>`, this method works faster because ``len()`` does not "
"scan the entire space to count the tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:837
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/book/box/box_space.rst:841
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:848
msgid ""
"**Note re storage engine:** vinyl supports ``len()`` but the result may "
"be approximate. If an exact result is necessary then use :ref:`count() "
"<box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:856 ../doc/book/box/box_space.rst:941
msgid ""
"Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` "
"will be executed whenever a ``replace()`` or ``insert()`` or ``update()``"
" or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/book/box/box_space.rst:861
msgid ""
"function which will become the trigger function; see Example #2 below for"
" details about trigger function parameters"
msgstr ""

#: ../doc/book/box/box_space.rst:865 ../doc/book/box/box_space.rst:951
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""

#: ../doc/book/box/box_space.rst:868 ../doc/book/box/box_space.rst:954
msgid "nil or function pointer"
msgstr ""

#: ../doc/book/box/box_space.rst:870
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""

#: ../doc/book/box/box_space.rst:873 ../doc/book/box/box_space.rst:959
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""

#: ../doc/book/box/box_space.rst:876 ../doc/book/box/box_space.rst:961
msgid ""
"If it is necessary to know whether the trigger activation happened due to"
" replication or on a specific connection type, the function can refer to "
":ref:`box.session.type() <box_session-type>`."
msgstr ""

#: ../doc/book/box/box_space.rst:880 ../doc/book/box/box_space.rst:965
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""

#: ../doc/book/box/box_space.rst:883
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:885 ../doc/book/box/box_space.rst:1874
msgid "**Example #1:**"
msgstr ""

#: ../doc/book/box/box_space.rst:887
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/book/box/box_space.rst:894 ../doc/book/box/box_space.rst:1919
msgid "**Example #2:**"
msgstr ""

#: ../doc/book/box/box_space.rst:896
msgid "The ``trigger-function`` can have up to four parameters:"
msgstr ""

#: ../doc/book/box/box_space.rst:898
msgid "(tuple) old value which has the contents before the request started,"
msgstr ""

#: ../doc/book/box/box_space.rst:899
msgid "(tuple) new value which has the contents after the request ended,"
msgstr ""

#: ../doc/book/box/box_space.rst:900
msgid "(string) space name,"
msgstr ""

#: ../doc/book/box/box_space.rst:901
msgid ""
"(string) type of request which is 'INSERT', 'DELETE', 'UPDATE', or "
"'REPLACE'."
msgstr ""

#: ../doc/book/box/box_space.rst:903
msgid ""
"For example, the following code causes nil and 'INSERT' to be printed "
"when the insert request is processed, and causes [1, 'Hi'] and 'DELETE' "
"to be printed when the delete request is processed:"
msgstr ""

#: ../doc/book/box/box_space.rst:907
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/book/box/box_space.rst:916
msgid "**Example #3:**"
msgstr ""

#: ../doc/book/box/box_space.rst:918
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""

#: ../doc/book/box/box_space.rst:923
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {{field = 1, type = "
"'unsigned'}}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/book/box/box_space.rst:946
msgid ""
"function which will become the trigger function; for the trigger "
"function's optional parameters see the description of :ref:`on_replace "
"<box_space-on_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:956
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""

#: ../doc/book/box/box_space.rst:968
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:970
msgid ""
"Administrators can make replace triggers with ``on_replace()``, or make "
"triggers with ``before_replace()``. If they make both types, then all "
"``before_replace`` triggers are executed before all ``on_replace`` "
"triggers. The functions for both ``on_replace`` and ``before_replace`` "
"triggers can make changes to the database, but only the functions for "
"``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""

#: ../doc/book/box/box_space.rst:979
msgid ""
"Since a ``before_replace`` trigger function has the extra capability of "
"making a change to the old tuple, it also can have extra overhead, to "
"fetch the old tuple before making the change. Therefore an ``on_replace``"
" trigger is better if there is no need to change the old tuple. However, "
"this only applies for the memtx engine -- for the vinyl engine, the fetch"
" will happen for either kind of trigger. (With memtx the tuple data is "
"stored along with the index key so no extra search is necessary; with "
"vinyl that is not the case so the extra search is necessary.)"
msgstr ""

#: ../doc/book/box/box_space.rst:991
msgid ""
"Where the extra capability is not needed, ``on_replace`` should be used "
"instead of ``before_replace``. Usually ``before_replace`` is used only "
"for certain replication scenarios -- it is useful for conflict "
"resolution."
msgstr ""

#: ../doc/book/box/box_space.rst:996
msgid ""
"The value that a ``before_replace`` trigger function can return affects "
"what will happen after the return. Specifically:"
msgstr ""

#: ../doc/book/box/box_space.rst:999
msgid ""
"if there is no return value, then execution proceeds, inserting|replacing"
" the new value;"
msgstr ""

#: ../doc/book/box/box_space.rst:1001
msgid "if the value is nil, then the tuple will be deleted;"
msgstr ""

#: ../doc/book/box/box_space.rst:1002
msgid ""
"if the value is the same as the old parameter, then no `on_replace`` "
"function will be called and the data change will be skipped"
msgstr ""

#: ../doc/book/box/box_space.rst:1005
msgid ""
"if the value is the same as the new parameter, then it's as if the "
"``before_replace`` function wasn't called;"
msgstr ""

#: ../doc/book/box/box_space.rst:1007
msgid ""
"if the value is something else, then execution proceeds, "
"inserting|replacing the new value."
msgstr ""

#: ../doc/book/box/box_space.rst:1010
msgid ""
"However, if a trigger function returns an old tuple, or if a trigger "
"function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that "
"will not affect other triggers that are activated for the same "
"insert|update|replace request."
msgstr ""

#: ../doc/book/box/box_space.rst:1017
msgid ""
"The following are ``before_replace`` functions that have no return value,"
" or that return nil, or the same as the old parameter, or the same as the"
" new parameter, or something else."
msgstr ""

#: ../doc/book/box/box_space.rst:1021
msgid ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""

#: ../doc/book/box/box_space.rst:1033
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/book/box/box_space.rst:1038
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/book/box/box_space.rst:1040
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:1043
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/book/box/box_space.rst:1049 ../doc/book/box/box_space.rst:1208
msgid "no such space;"
msgstr ""

#: ../doc/book/box/box_space.rst:1050 ../doc/book/box/box_space.rst:1209
msgid "wrong type."
msgstr ""

#: ../doc/book/box/box_space.rst:1052 ../doc/book/box/box_space.rst:1211
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/book/box/box_space.rst:1054
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1059
msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ "
"documentation."
msgstr ""

#: ../doc/book/box/box_space.rst:1065
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1096
msgid "Rename a space."
msgstr ""

#: ../doc/book/box/box_space.rst:1100
msgid "new name for space"
msgstr ""

#: ../doc/book/box/box_space.rst:1108
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1122
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/book/box/box_space.rst:1130
msgid "tuple to be inserted"
msgstr ""

#: ../doc/book/box/box_space.rst:1135
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with "
"the same unique-key value already exists. (This will only happen if there"
" is a unique secondary index.)"
msgstr ""

#: ../doc/book/box/box_space.rst:1144
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/book/box/box_space.rst:1156
msgid ""
"At the time that a :ref:`trigger <triggers>` is defined, it is "
"automatically enabled - that is, it will be executed. :ref:`Replace "
"<box_space-on_replace>` triggers can be disabled with :samp:`box.space"
".{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space"
".{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/book/box/box_space.rst:1165
msgid ""
"The following series of requests will associate an existing function "
"named `F` with an existing space named `T`, associate the function a "
"second time with the same space (so it will be called twice), disable all"
" triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/book/box/box_space.rst:1170
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/book/box/box_space.rst:1182
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:1188
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:  * ``options.iterator`` (:ref:`type of "
"iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number"
" of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/book/box/box_space.rst:1188
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:"
msgstr ""

#: ../doc/book/box/box_space.rst:1192
msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr ""

#: ../doc/book/box/box_space.rst:1193
msgid "``options.limit`` (maximum number of tuples)"
msgstr ""

#: ../doc/book/box/box_space.rst:1194
msgid "``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/book/box/box_space.rst:1196
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/book/box/box_space.rst:1201
msgid "array of tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:1203
msgid ""
"A ``select`` request can also be done with a specific index and index "
"options, which are the subject of :ref:`index_object:select <box_index-"
"select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1215
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = { {field = 1, type = "
"'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1270
msgid ""
"As the last request in the above example shows: to make complex "
"``select`` requests, where you can specify which index to search and what"
" condition to use (for example \"greater than\" instead of \"equal to\") "
"and how many tuples to return, it will be necessary to become familiar "
"with :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1284
msgid "Deletes all tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:1289
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_space.rst:1293
msgid ""
"The ``truncate`` method can only be called by the user who created the "
"space, or from within a ``setuid`` function created by the user who "
"created the space. Read more about `setuid` functions in the reference "
"for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1299
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr ""

#: ../doc/book/box/box_space.rst:1303
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1317
msgid "Update a tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:1319
msgid ""
"The ``update`` function supports operations on fields â€” assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field number. When multiple operations are present, the field number for "
"each operation is assumed to be relative to the most recent state of the "
"tuple, that is, as if all previous operations in a multi-operation update"
" have already been applied. In other words, it is always safe to merge "
"multiple ``update`` invocations into a single invocation, with no change "
"in semantics."
msgstr ""

#: ../doc/book/box/box_space.rst:1331
msgid "Possible operators are:"
msgstr ""

#: ../doc/book/box/box_space.rst:1333
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:1334
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:1335
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:1336
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:1337
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned "
"numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:1339
msgid "``:`` for string splice"
msgstr ""

#: ../doc/book/box/box_space.rst:1340
msgid "``!`` for insertion"
msgstr ""

#: ../doc/book/box/box_space.rst:1341
msgid "``#`` for deletion"
msgstr ""

#: ../doc/book/box/box_space.rst:1342
msgid "``=`` for assignment"
msgstr ""

#: ../doc/book/box/box_space.rst:1344
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning "
"the last field in the tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:1351 ../doc/book/box/box_space.rst:1472
msgid "operation type represented in string"
msgstr ""

#: ../doc/book/box/box_space.rst:1352 ../doc/book/box/box_space.rst:1473
msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""

#: ../doc/book/box/box_space.rst:1356 ../doc/book/box/box_space.rst:1477
msgid "what value will be applied"
msgstr ""

#: ../doc/book/box/box_space.rst:1358
msgid "the updated tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:1361
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:1363 ../doc/book/box/box_space.rst:1487
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:1366
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/book/box/box_space.rst:1368
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1372
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1380
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``unsigned``. There is one tuple, with "
"``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1384
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation â€” *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1395
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/book/box/box_space.rst:1402
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""

#: ../doc/book/box/box_space.rst:1409
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/book/box/box_space.rst:1417
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/book/box/box_space.rst:1426
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/book/box/box_space.rst:1434
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1439
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1456
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:1458
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple``, "
"then the request has the same effect as :ref:`space_object:update() "
"<box_space-update>` and the ``{{operator, field_no, value}, ...}`` "
"parameter is used. If there is no existing tuple which matches the key "
"fields of ``tuple``, then the request has the same effect as "
":ref:`space_object:insert() <box_space-insert>` and the ``{tuple}`` "
"parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` "
"will not read a tuple and perform error checks before returning -- this "
"is a design feature which enhances throughput but requires more caution "
"on the part of the user."
msgstr ""

#: ../doc/book/box/box_space.rst:1470
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/book/box/box_space.rst:1479
msgid "null"
msgstr ""

#: ../doc/book/box/box_space.rst:1483
msgid "It is illegal to modify a primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:1484
msgid ""
"It is illegal to use upsert with a space that has a unique secondary "
"index."
msgstr ""

#: ../doc/book/box/box_space.rst:1492
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1504
msgid ""
"Users can define any functions they want, and associate them with spaces:"
" in effect they can make their own space methods. They do this by:"
msgstr ""

#: ../doc/book/box/box_space.rst:1508
msgid "creating a Lua function,"
msgstr ""

#: ../doc/book/box/box_space.rst:1509
msgid ""
"adding the function name to a predefined global variable which has type ="
" table, and"
msgstr ""

#: ../doc/book/box/box_space.rst:1511
msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``space_object:function-name([parameters])``."
msgstr ""

#: ../doc/book/box/box_space.rst:1514
msgid ""
"The predefined global variable is ``box.schema.space_mt``. Adding to "
"``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""

#: ../doc/book/box/box_space.rst:1517
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"space, by calling ``getmetatable(space_object)`` and then adding the "
"function name to the meta table. See also the example for "
":ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1522
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1524
msgid "whatever the user defines"
msgstr ""

#: ../doc/book/box/box_space.rst:1528
msgid ""
"-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""

#: ../doc/book/box/box_space.rst:1543
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""

#: ../doc/book/box/box_space.rst:1550
msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""

#: ../doc/book/box/box_space.rst:1590
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/box/box_space.rst:1562
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/book/box/box_space.rst:1566
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1577
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""

#: ../doc/book/box/box_space.rst:1584
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1595
msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""

#: ../doc/book/box/box_space.rst:1599
msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1601
msgid "table"
msgstr ""

#: ../doc/book/box/box_space.rst:1605
msgid ""
"# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1624
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <replication>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1631
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1634 ../doc/book/box/box_space.rst:1687
#: ../doc/book/box/box_space.rst:1746 ../doc/book/box/box_space.rst:1863
#: ../doc/book/box/box_space.rst:1979
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/book/box/box_space.rst:1636
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/book/box/box_space.rst:1637
msgid "the function name,"
msgstr ""

#: ../doc/book/box/box_space.rst:1638
msgid "flag,"
msgstr ""

#: ../doc/book/box/box_space.rst:1639
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/book/box/box_space.rst:1641
msgid ""
"The ``_func`` space does not include the functionâ€™s body. You continue to"
" create Lua functions in the usual way, by saying ``function "
"function_name () ... end``, without adding anything in the ``_func`` "
"space. The ``_func`` space only exists for storing function tuples so "
"that their names can be used within :ref:`grant/revoke <authentication-"
"owners_privileges>` functions."
msgstr ""

#: ../doc/book/box/box_space.rst:1649 ../doc/book/box/box_space.rst:1756
msgid "You can:"
msgstr ""

#: ../doc/book/box/box_space.rst:1651
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""

#: ../doc/book/box/box_space.rst:1653
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""

#: ../doc/book/box/box_space.rst:1655
msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1660
msgid ""
"In the following example, we create a function named â€˜f7â€™, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""

#: ../doc/book/box/box_space.rst:1664
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1685
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:1689
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/book/box/box_space.rst:1690
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/book/box/box_space.rst:1691
msgid "``name``,"
msgstr ""

#: ../doc/book/box/box_space.rst:1692
msgid "``type``,"
msgstr ""

#: ../doc/book/box/box_space.rst:1693
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""

#: ../doc/book/box/box_space.rst:1695
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/book/box/box_space.rst:1697
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1722
msgid ""
"``_vindex`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_index <box_space-"
"index>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vindex`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:1728
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vindex`` match the contents of ``_index``. If the user has limited "
"access, ``_vindex`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/book/box/box_space.rst:1734
msgid "``_vindex`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/book/box/box_space.rst:1736
msgid ""
"While the ``_index`` space requires proper access privileges, any user "
"can always read from ``_vindex``."
msgstr ""

#: ../doc/book/box/box_space.rst:1743
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""

#: ../doc/book/box/box_space.rst:1748
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:1749
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:1750
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""

#: ../doc/book/box/box_space.rst:1751
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/book/box/box_space.rst:1752
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, "
"\"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as"
" \"read,write,execute\"."
msgstr ""

#: ../doc/book/box/box_space.rst:1758
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1759
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1763
msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/book/box/box_space.rst:1766
msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""

#: ../doc/book/box/box_space.rst:1769
msgid ""
"Only the :ref:`'admin' user <authentication-owners_privileges>` can grant"
" privileges for the 'universe'."
msgstr ""

#: ../doc/book/box/box_space.rst:1772
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""

#: ../doc/book/box/box_space.rst:1775
msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"userâ€™s password."
msgstr ""

#: ../doc/book/box/box_space.rst:1782
msgid ""
"``_vpriv`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_priv <box_space-"
"priv>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vpriv`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:1788
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vpriv`` match the contents of ``_priv``. If the user has limited "
"access, ``_vpriv`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/book/box/box_space.rst:1794
msgid "``_vpriv`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/book/box/box_space.rst:1796
msgid ""
"While the ``_priv`` space requires proper access privileges, any user can"
" always read from ``_vpriv``."
msgstr ""

#: ../doc/book/box/box_space.rst:1803
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:1805
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/book/box/box_space.rst:1807
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/book/box/box_space.rst:1808
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/book/box/box_space.rst:1809
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/book/box/box_space.rst:1810
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""

#: ../doc/book/box/box_space.rst:1820
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/book/box/box_space.rst:1823
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/book/box/box_space.rst:1837
msgid ""
"``_sequence`` is a system space for support of the :ref:`sequence feature"
" <index-box_sequence>`. It contains persistent information that was "
"established by :ref:`box.schema.sequence.create() <box_schema-"
"sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-"
"sequence_alter>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1847
msgid ""
"``_sequence_data`` is a system space for support of the :ref:`sequence "
"feature <index-box_sequence>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1850
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr ""

#: ../doc/book/box/box_space.rst:1852
msgid "the id of the sequence, and"
msgstr ""

#: ../doc/book/box/box_space.rst:1853
msgid ""
"the last value that the sequence generator returned (non-persistent "
"information)."
msgstr ""

#: ../doc/book/box/box_space.rst:1860
msgid ""
"``_space`` is a system space. It contains all spaces hosted on the "
"current Tarantool instance, both system ones and created by users."
msgstr ""

#: ../doc/book/box/box_space.rst:1865
msgid "``id``,"
msgstr ""

#: ../doc/book/box/box_space.rst:1866
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/book/box/box_space.rst:1867
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/book/box/box_space.rst:1868
msgid "``flags`` (e.g. temporary),"
msgstr ""

#: ../doc/book/box/box_space.rst:1869
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr ""

#: ../doc/book/box/box_space.rst:1871
msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1876
msgid ""
"The following function will display every simple field in all tuples of "
"``_space``."
msgstr ""

#: ../doc/book/box/box_space.rst:1879
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:1898
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/book/box/box_space.rst:1900
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1921
msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a :ref:`format clause <box_space-"
"format>`, then retrieve the ``_space`` tuple for the new space. This "
"illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""

#: ../doc/book/box/box_space.rst:1927
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1956
msgid ""
"``_vspace`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_space <box_space-"
"space>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vspace`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:1962
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vspace`` match the contents of ``_space``. If the user has limited "
"access, ``_vspace`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/book/box/box_space.rst:1968
msgid "``_vspace`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/book/box/box_space.rst:1970
msgid ""
"While the ``_space`` space requires proper access privileges, any user "
"can always read from ``_vspace``."
msgstr ""

#: ../doc/book/box/box_space.rst:1977
msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""

#: ../doc/book/box/box_space.rst:1981
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:1982
msgid "the numeric id of the tupleâ€™s creator,"
msgstr ""

#: ../doc/book/box/box_space.rst:1983
msgid "the name,"
msgstr ""

#: ../doc/book/box/box_space.rst:1984
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/book/box/box_space.rst:1985
msgid "optional password."
msgstr ""

#: ../doc/book/box/box_space.rst:1987
msgid ""
"There are five special tuples in the ``_user`` space: 'guest', 'admin', "
"'public', 'replication', and 'super'."
msgstr ""

#: ../doc/book/box/box_space.rst:2000
msgid "ID"
msgstr ""

#: ../doc/book/box/box_space.rst:2000
msgid "Description"
msgstr ""

#: ../doc/book/box/box_space.rst:2002
msgid "guest"
msgstr ""

#: ../doc/book/box/box_space.rst:2002
msgid "0"
msgstr ""

#: ../doc/book/box/box_space.rst:2002 ../doc/book/box/box_space.rst:2005
msgid "user"
msgstr ""

#: ../doc/book/box/box_space.rst:2002
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2005
msgid "admin"
msgstr ""

#: ../doc/book/box/box_space.rst:2005
msgid "1"
msgstr ""

#: ../doc/book/box/box_space.rst:2005
msgid ""
"Default user when using Tarantool as a console. Usually an "
":ref:`administrative user <authentication-owners_privileges>` with all "
"privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2010
msgid "public"
msgstr ""

#: ../doc/book/box/box_space.rst:2010 ../doc/book/box/box_space.rst:2018
#: ../doc/book/box/box_space.rst:2022
msgid "role"
msgstr ""

#: ../doc/book/box/box_space.rst:2010
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically granted to "
"new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore a convenient way to grant 'read' on space 't' to every"
" user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/book/box/box_space.rst:2018
msgid "replication"
msgstr ""

#: ../doc/book/box/box_space.rst:2018
msgid "3"
msgstr ""

#: ../doc/book/box/box_space.rst:2018
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need to use :ref:`replication <replication>` "
"features."
msgstr ""

#: ../doc/book/box/box_space.rst:2022
msgid "super"
msgstr ""

#: ../doc/book/box/box_space.rst:2022
msgid "31"
msgstr ""

#: ../doc/book/box/box_space.rst:2022
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need all privileges on all objects. The 'super' "
"role has these privileges on 'universe': read, write, execute, create, "
"drop, alter."
msgstr ""

#: ../doc/book/box/box_space.rst:2030
msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""

#: ../doc/book/box/box_space.rst:2034
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2043
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""

#: ../doc/book/box/box_space.rst:2047
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2086
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/book/box/box_space.rst:2056
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2095
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2068
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2107
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2075
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/book/box/box_space.rst:2115
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2083
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2122
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2092
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/book/box/box_space.rst:2096
msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/book/box/box_space.rst:2099
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2114
msgid "Example: using box.space functions to read _space tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:2116
msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""

#: ../doc/book/box/box_space.rst:2126
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:2150
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/book/box/box_space.rst:2152
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2172
msgid "Example: using box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:2174
msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""

#: ../doc/book/box/box_space.rst:2177
msgid ""
"To begin: how can one select the ``_space`` tuple that describes "
"``_space``?"
msgstr ""

#: ../doc/book/box/box_space.rst:2179
msgid ""
"A simple way is to look at the constants in ``box.schema``, which tell us"
" that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""

#: ../doc/book/box/box_space.rst:2183
msgid ""
"box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""

#: ../doc/book/box/box_space.rst:2189
msgid ""
"Another way is to look at the tuples in ``box.space._index``, which tell "
"us that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/book/box/box_space.rst:2193
msgid "box.space._space.index.name:select{ '_space' }"
msgstr ""

#: ../doc/book/box/box_space.rst:2197
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/book/box/box_space.rst:2199
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2209
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""

#: ../doc/book/box/box_space.rst:2214
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2236
msgid ""
"``_vuser`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_user <box_space-"
"user>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vuser`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2242
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vuser`` match the contents of ``_user``. If the user has limited "
"access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/book/box/box_space.rst:2246
msgid ""
"To see how ``_vuser`` works, :ref:`connect to a Tarantool database "
"remotely <connecting-remotely>` via ``tarantoolctl`` and select all "
"tuples from the ``_user`` space, both when the 'guest' user *is* and *is "
"not* allowed to read from the database."
msgstr ""

#: ../doc/book/box/box_space.rst:2252
msgid ""
"First, start Tarantool and grant the 'guest' user with read, write and "
"execute privileges:"
msgstr ""

#: ../doc/book/box/box_space.rst:2255
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2264
msgid ""
"Switch to the other terminal, connect to the Tarantool instance and "
"select all tuples from the ``_user`` space:"
msgstr ""

#: ../doc/book/box/box_space.rst:2267
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2279
msgid ""
"This result contains the same set of users as if you made the request "
"from your Tarantool instance as 'admin'."
msgstr ""

#: ../doc/book/box/box_space.rst:2282
msgid ""
"Switch to the first terminal and revoke the read privileges from the "
"'guest' user:"
msgstr ""

#: ../doc/book/box/box_space.rst:2284
msgid ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2290
msgid ""
"Switch to the other terminal, stop the session (to stop ``tarantoolctl``,"
" type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` "
"request. The access is denied:"
msgstr ""

#: ../doc/book/box/box_space.rst:2294
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2302
msgid ""
"However, if you select from ``_vuser`` instead, the users' data available"
" for the 'guest' user is displayed:"
msgstr ""

#: ../doc/book/box/box_space.rst:2305
msgid ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2314
msgid "``_vuser`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/book/box/box_space.rst:2315
msgid ""
"While the ``_user`` space requires proper access privileges, any user can"
" always read from ``_vuser``."
msgstr ""

#: ../doc/book/box/box_space.rst:2322
msgid "Example: using data operations"
msgstr ""

#: ../doc/book/box/box_space.rst:2324
msgid ""
"This example demonstrates all legal scenarios -- as well as typical "
"errors -- for each :ref:`data operation <index-box_data-operations>` in "
"Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-"
"select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2333
msgid ""
"-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique"
" = false})"
msgstr ""

#: ../doc/book/box/box_space.rst:2353
msgid "INSERT"
msgstr ""

#: ../doc/book/box/box_space.rst:2355
msgid ""
"``insert`` accepts a well-formatted tuple and checks all keys for "
"duplicates."
msgstr ""

#: ../doc/book/box/box_space.rst:2357
msgid ""
"tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: "
"ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2387
msgid "DELETE"
msgstr ""

#: ../doc/book/box/box_space.rst:2389
msgid "``delete`` accepts a full key of any unique index."
msgstr ""

#: ../doc/book/box/box_space.rst:2391
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""

#: ../doc/book/box/box_space.rst:2393
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2466
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""

#: ../doc/book/box/box_space.rst:2468
msgid ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2502
msgid "UPDATE"
msgstr ""

#: ../doc/book/box/box_space.rst:2504
msgid ""
"Similarly to ``delete``, ``update`` accepts a full key of any unique "
"index, and also the operations to execute."
msgstr ""

#: ../doc/book/box/box_space.rst:2507
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""

#: ../doc/book/box/box_space.rst:2509
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2595
msgid "UPSERT"
msgstr ""

#: ../doc/book/box/box_space.rst:2597
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""

#: ../doc/book/box/box_space.rst:2599
msgid ""
"If an old tuple is found by the primary key of the specified tuple, then "
"the update operations are applied to the old tuple, and the new tuple is "
"ignored."
msgstr ""

#: ../doc/book/box/box_space.rst:2603
msgid ""
"If no old tuple is found, then the new tuple is inserted, and the update "
"operations are **ignored**."
msgstr ""

#: ../doc/book/box/box_space.rst:2606
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr ""

#: ../doc/book/box/box_space.rst:2608
msgid ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2642
msgid ""
"``upsert`` turns into ``insert`` when no old tuple is found by the "
"primary key."
msgstr ""

#: ../doc/book/box/box_space.rst:2644
msgid ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2668
msgid ""
"``upsert`` searches for an old tuple by the primary index, NOT by a "
"secondary index. This can lead to a duplication error if the new tuple "
"ruins the uniqueness of a secondary index."
msgstr ""

#: ../doc/book/box/box_space.rst:2672
msgid ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2699
msgid "REPLACE"
msgstr ""

#: ../doc/book/box/box_space.rst:2701
msgid ""
"``replace`` accepts a well-formatted tuple and searches for an old tuple "
"by the primary key of the new tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:2704
msgid ""
"If the old tuple is found, then it is deleted, and the new tuple is "
"inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:2706
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:2708
msgid ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2730
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr ""

#: ../doc/book/box/box_space.rst:2732
msgid ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} "
"replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1},"
" --\n"
"tarantool> -- this results in a duplicate unique secondary key in "
"'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2758
msgid "SELECT"
msgstr ""

#: ../doc/book/box/box_space.rst:2760
msgid ""
"``select`` works with any indexes (primary/secondary) and with any keys "
"(unique/non-unique, full/partial)."
msgstr ""

#: ../doc/book/box/box_space.rst:2763
msgid ""
"If a key is partial, then ``select`` searches by all keys, where the "
"prefix matches the specified key part."
msgstr ""

#: ../doc/book/box/box_space.rst:2766
msgid ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""

