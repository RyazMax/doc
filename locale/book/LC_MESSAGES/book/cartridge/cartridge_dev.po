# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../doc/book/cartridge/cartridge_dev.rst:5
msgid "Tarantool Cartridge developer's guide"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:7
msgid ""
"For a quick start, skip the details below and jump right away to this "
"detailed `guide <https://github.com/tarantool/cartridge-"
"cli/blob/master/examples/getting-started-app/README.md>`_ to creating a "
"cluster-aware Tarantool application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:11
msgid ""
"For a deep dive into what you can do with Tarantool Cartridge, go on with"
" this section."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:13
msgid ""
"To develop and start an application, in short, you need to go through the"
" following steps:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:16
msgid ""
":ref:`Install <cartridge-install>` Tarantool Cartridge and other "
"components of the development environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:18
msgid ""
"Choose a :ref:`template <cartridge-templates>` for the application and "
"create a project."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:20
msgid ""
"Develop the application. In case it is a cluster-aware application, "
"implement its logic in a custom (user-defined) :ref:`cluster role "
"<cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:24
msgid ""
":ref:`Deploy <cartridge-deploy>` the application to target server(s). "
"This includes :ref:`configuring <cartridge-config>` and :ref:`starting "
"<cartridge-run>` the instance(s)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:27
msgid ""
"In case it is a cluster-aware application, :ref:`deploy the cluster "
"<cartridge-deployment>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:30
msgid "The following sections provide details for each of these steps."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:36
msgid "Installing Tarantool Cartridge"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:38
msgid ""
"Install ``catridge-cli``, a command-line tool for developing, deploying, "
"and managing Tarantool applications:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:41
msgid "$ tarantoolctl rocks install cartridge-cli"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:45
msgid ""
"The Cartridge framework will come as a dependency when you create your "
"project."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:47
msgid ""
"Everything will be installed to ``.rocks/bin``, so for convenient usage "
"add ``.rocks/bin`` to the executable path:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:50
msgid "$ export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:54
msgid "Install ``git``, a version control system."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:56
msgid "Install ``npm``, a package manager for ``node.js``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:58
msgid "Install the ``unzip`` utility."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:64
msgid "Application templates"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:66
msgid ""
"Tarantool Cartridge provides you with two templates that help instantly "
"set up the application development environment:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:69
msgid ""
"``plain``, for developing an application that runs on a single or "
"multiple independent Tarantool instances (e.g. acting as a proxy to "
"third-party databases) -- that's what you could do before, :ref:`without "
"Tarantool Cartridge <app_server-creating_app>`, but now it's more "
"convenient."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:74
msgid ""
"``cartridge``, for developing a cluster-aware application -- this is an "
"exclusive feature of Tarantool Cartridge."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:77
msgid "To create a project based on either template, in any directory say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:79
msgid ""
"# plain application\n"
"$ plain create --name <app_name> /path/to/\n"
"\n"
"# - OR -\n"
"\n"
"# cluster application\n"
"$ cartridge create --name <app_name> /path/to/"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:89
msgid ""
"This will automatically set up a Git repository in a new "
"``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-"
"versioning>` ``0.1.0``, and put the necessary files into it (read about "
"default files for each template below)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:94
msgid ""
"In this Git repository, you can develop the application (by simply "
"editing the default files provided by the template), plug the necessary "
"modules, and then easily pack everything to deploy on your server(s)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:102
msgid "Plain template"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:104
msgid ""
"The plain template creates the ``<app_name>/`` directory with the "
"following contents:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:107
msgid ""
"``<app_name>-scm-1.rockspec`` file where you can specify the application "
"dependencies."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:109
msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:110
msgid "``init.lua`` file which is the entry point for your application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:111
msgid "``.git`` file necessary for a Git repository."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:112
msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:118
msgid "Cluster template"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:120
msgid ""
"In addition to the files listed in the plain template section, the "
"cluster template contains the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:123
msgid ""
"``env.lua`` file that sets common rock paths so that the application can "
"be started from any directory."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:125
msgid ""
"``custom-role.lua`` file that is a placeholder for a custom (user-"
"defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:128
msgid ""
"The entry point file (``init.lua``) of the cluster template differs from "
"the plain one. Among other things, it loads the ``cartridge`` module and "
"calls its initialization function:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:132
msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"-- cartridge options example\n"
"  workdir = '/var/lib/tarantool/app',\n"
"  advertise_uri = 'localhost:3301',\n"
"  cluster_cookie = 'super-cluster-cookie',\n"
"  ...\n"
"}, {\n"
"-- box options example\n"
"  memtx_memory = 1000000000,\n"
"  ... })\n"
" ..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:149
msgid ""
"The ``cartridge.cfg()`` call renders the instance operable via the "
"administrative console but does not call ``box.cfg()`` to configure "
"instances."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:154
msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:156
msgid "The cluster itself will do it for you when it is time to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:158
msgid "bootstrap the current instance once you:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:160
msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:161
msgid "click **Create** in the web interface;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:163
msgid "join the instance to an existing cluster once you:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:165
msgid ""
"run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the "
"console, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:166
msgid ""
"click **Join** (an existing replica set) or **Create** (a new replica "
"set) in the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:169
msgid ""
"Notice that you can specify a cookie for the cluster (``cluster_cookie`` "
"parameter) if you need to run several clusters in the same network. The "
"cookie can be any string value."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:173
msgid ""
"Before developing a cluster-aware application, familiarize yourself with "
"the notion of :ref:`cluster roles <cartridge-roles>` and make sure to "
"define a custom role to initialize the database for the cluster "
"application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:182
msgid "Cluster roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:184
msgid ""
"A Tarantool Cartridge cluster segregates instance functionality in a "
"role-based way. **Cluster roles** are Lua modules that implement some "
"instance-specific functions and/or logic."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:188
msgid ""
"Since all instances running cluster applications use the same source code"
" and are aware of all the defined roles (and plugged modules), multiple "
"different roles can be dynamically enabled and disabled on any number of "
"instances without restarts even during cluster operation."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:197
msgid "Built-in roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:199
msgid ""
"The ``cartridge`` module comes with two *built-in* roles that implement "
"automatic sharding:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:202
msgid ""
"``vshard-router`` that handles the ``vshard``'s *compute-intensive* "
"workload: routes requests to storage nodes."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:204
msgid ""
"``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* "
"workload: stores and manages a subset of a dataset."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:209
msgid ""
"For more information on sharding, see the :ref:`vshard module "
"documentation <vshard>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:212
msgid ""
"With the built-in and custom roles, Tarantool Cartridge allows you to "
"develop applications with separated compute and transaction handling. "
"Later, the relevant workload-specific roles can be enabled on different "
"instances running on physical servers with workload-dedicated hardware."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:217
msgid ""
"Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, "
"or formats. To start developing an application, edit the ``custom-"
"role.lua`` placeholder file: add a ``box.schema.space.create()`` call to "
"your first cluster role."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:222
msgid "Additionally, you can implement several such roles to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:224
msgid "define stored procedures;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:225
msgid "implement functionality on top of ``vshard``;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:226
msgid "go without ``vshard`` at all;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:227
msgid ""
"implement one or multiple supplementary services such as e-mail notifier,"
" replicator, etc."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:234
msgid "Custom roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:236
msgid "To implement a *custom* cluster role, do the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:238
msgid ""
"Register the new role in the cluster by modifying the ``cartridge.cfg()``"
" call in the ``init.lua`` entry point file:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:241
msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:254
msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:256
msgid ""
"Implement the role in a file with the appropriate name (``custom-"
"role.lua``). For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:259
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:279
msgid ""
"Where the ``role_name`` may differ from the module name passed to the "
"``cartridge.cfg()`` function. If the ``role_name`` variable is not "
"specified, the module name is the default value."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:285
msgid ""
"Role names must be unique as it is impossible to register multiple roles "
"with the same name."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:288
msgid ""
"The role module does not have required functions but the cluster may "
"execute the following ones during the role's life cycle:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:291
msgid "``init()`` is the role's *initialization* function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:293
msgid ""
"Inside the function's body you can call any ``box`` functions: create "
"spaces, indexes, grant permissions, etc. Here is what the initialization "
"function may look like:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:297
msgid ""
"local function init(opts)\n"
"    -- The cluster passes an 'opts' Lua table containing an 'is_master' "
"flag.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:320
msgid ""
"The function's body is wrapped in a conditional statement that lets you "
"call ``box`` functions on masters only. This protects against replication"
" collisions as data propagates to replicas automatically."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:325
msgid ""
"``stop()`` is the role's *termination* function. Implement it if "
"initialization starts a fiber that has to be stopped or does any job that"
" has to be undone on termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:329
msgid ""
"``validate_config()`` and ``apply_config()`` are *validation* and "
"*application* functions that make custom roles configurable. Implement "
"them if some configuration data has to be stored cluster-wide."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:333
msgid ""
"Next, get a grip on the :ref:`role's life cycle <cartridge-role-"
"lifecycle>` to implement the necessary functions."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:340
msgid "Defining role dependencies"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:342
msgid ""
"You can instruct the cluster to apply some other roles if your custom "
"role is enabled."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:345
#: ../doc/book/cartridge/cartridge_dev.rst:1233
msgid "For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:347
msgid ""
"-- Role dependencies defined in custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:358
msgid ""
"Here ``vshard-router`` role will be initialized automatically for every "
"instance with ``custom-role`` enabled."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:365
msgid "Using multiple vshard storage groups"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:367
msgid ""
"Replica sets with ``vshard-storage`` roles can belong to different "
"*groups*. For example, ``hot`` or ``cold`` groups meant to independently "
"process hot and cold data."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:371
msgid "Groups are specified in the cluster's configuration:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:373
msgid ""
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:380
msgid ""
"If no groups are specified, the cluster assumes that all replica sets "
"belong to the ``default`` group."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:383
msgid ""
"With multiple groups enabled, every replica set with a ``vshard-storage``"
" role enabled must be assigned to a particular group. The assignment can "
"never be changed."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:387
msgid ""
"Another limitation is that you cannot add groups dynamically (this will "
"become available in future)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:390
msgid ""
"Finally, mind the new syntax for router access. Every instance with a "
"``vshard-router`` role enabled initializes multiple routers. All of them "
"are accessible through the role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:394
msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:399
msgid "If you have no roles specified, you can access a static router as before:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:401
msgid ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:406
msgid ""
"However, when using the new API, you must call a static router with a "
"colon:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:408
msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')"
"\n"
"default_router:call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:418
msgid "Role's life cycle and the order of function execution"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:420
msgid ""
"The cluster displays all custom role names along with the built-in "
"``vshard`` ones in the web interface. Cluster administrators can enable "
"and disable them for particular instances either via the web interface or"
" cluster public API. For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:425
msgid ""
"cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-"
"router', 'custom-role'}})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:429
msgid ""
"If multiple roles are enabled on an instance at the same time, the "
"cluster first initializes the built-in roles (if any) and then the custom"
" ones (if any) in the order the latter were listed in "
"``cartridge.cfg()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:433
msgid ""
"If a custom role has dependent roles, the dependencies are registered and"
" validated first, prior to the role itself."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:436
msgid "The cluster calls the role's functions in the following circumstances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:438
msgid ""
"The ``init()`` function, typically, once: either when the role is enabled"
" by the administrator or at the instance restart. Enabling a role once is"
" normally enough."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:442
msgid ""
"The ``stop()`` function -- only when the administrator disables the role,"
" not on instance termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:445
msgid ""
"The ``validate_config()`` function, first, before the automatic "
"``box.cfg()`` call (database initialization), then -- upon every "
"configuration update."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:448
msgid "The ``apply_config()`` function upon every configuration update."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:450
msgid ""
"Hence, if the cluster is tasked with performing the following actions, it"
" will execute the functions listed in the following order:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:453
msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:455
#: ../doc/book/cartridge/cartridge_dev.rst:461
#: ../doc/book/cartridge/cartridge_dev.rst:469
#: ../doc/book/cartridge/cartridge_dev.rst:474
msgid "``validate_config()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:456
#: ../doc/book/cartridge/cartridge_dev.rst:462
msgid "``init()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:457
#: ../doc/book/cartridge/cartridge_dev.rst:463
#: ../doc/book/cartridge/cartridge_dev.rst:470
#: ../doc/book/cartridge/cartridge_dev.rst:475
msgid "``apply_config()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:459
msgid "Restart an instance with an enabled role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:465
msgid "Disable role: ``stop()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:467
msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:472
msgid "Upon a triggered failover:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:477
msgid "Considering the described behavior:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:479
msgid "The ``init()`` function may:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:481
msgid "Call ``box`` functions."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:482
msgid ""
"Start a fiber and, in this case, the ``stop()`` function should take care"
" of the fiber's termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:484
msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:485
msgid "Execute any code related to the role's initialization."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:487
msgid ""
"The ``stop()`` functions must undo any job that has to be undone on "
"role's termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:490
msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:492
msgid ""
"The ``apply_config()`` function may execute any code related to a "
"configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:495
msgid ""
"The validation and application functions together allow you to customize "
"the cluster-wide configuration as described in the :ref:`next section "
"<cartridge-role-config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:503
msgid "Configuring custom roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:505
msgid "You can:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:507
msgid ""
"Store configurations for your custom roles as sections in cluster-wide "
"configuration, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:510
msgid ""
"# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:516
msgid ""
"-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:525
msgid ""
"Download and upload cluster-wide configuration using :ref:`cluster UI "
"<cartridge-ui-configuration>` or API (via GET/PUT queries to "
"``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and "
"``curl -X PUT -d \"{'my_parameter': 'value'}\" "
"localhost:8081/admin/config``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:531
msgid "Utilize it in your role ``apply_config()`` function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:533
msgid ""
"Every instance in the cluster stores a copy of the configuration file in "
"its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:536
msgid ""
"``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed "
"from RPM packages and managed by ``systemd``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:538
msgid ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for "
"instances deployed from archives."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:541
msgid ""
"The cluster's configuration is a Lua table, downloaded and uploaded as "
"YAML. If some application-specific configuration data, e.g., a database "
"schema as defined by DDL (data definition language), has to be stored on "
"every instance in the cluster, you can implement your own API by adding a"
" custom section to the table. The cluster will help you spread it safely "
"across all instances."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:547
msgid ""
"Such section goes in parallel (in the same file) with the topology-"
"specific and ``vshard``-specific ones the cluster automatically "
"generates. Unlike the generated, the custom section's modification, "
"validation, and application logic has to be defined."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:552
msgid "The common way is to define two functions:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:554
msgid ""
"``validate_config(conf_new, conf_old)`` to validate changes made in the "
"new configuration (``conf_new``) versus the old configuration "
"(``conf_old``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:556
msgid ""
"``apply_config(conf, opts)`` to execute any code related to a "
"configuration change. As input, this function takes the configuration to "
"apply (``conf``, which is actually the new configuration that you "
"validated earlier with ``validate_config()``) and options (the ``opts`` "
"argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:564
msgid ""
"The ``validate_config()`` function must detect all configuration problems"
" that may lead to ``apply_config()`` errors. For more information, see "
"the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:568
msgid ""
"When implementing validation and application functions that call ``box`` "
"ones for some reason, the following precautions apply:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:571
msgid ""
"Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the "
"cluster does not guarantee an automatic ``box.cfg()`` call prior to "
"calling ``validate_config()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:575
msgid ""
"If the validation function is to call any ``box`` functions (e.g., to "
"check a format), make sure the calls are wrapped in a protective "
"conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:579
msgid ""
"-- Inside the validation function:\n"
"\n"
"if type(box.cfg) == 'table' then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:590
msgid ""
"Unlike the validation and similar to initialization function, "
"``apply_config()`` can call ``box`` functions freely as the cluster "
"applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:594
msgid ""
"However, creating spaces, users, etc., can cause replication collisions "
"when performed on both master and replica instances simultaneously. The "
"appropriate way is to call such ``box`` functions on masters only and let"
" the changes propagate to replicas automatically."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:599
msgid ""
"Upon the ``apply_config(conf, opts)`` execution, the cluster passes an "
"``is_master`` flag in the ``opts`` table which you can use to wrap "
"collision-inducing ``box`` functions in a protective conditional "
"statement:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:603
msgid ""
"-- Inside the configuration application function:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:618
msgid "Custom configuration example"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:620
msgid ""
"Consider the following code as part of the role's module (``custom-"
"role.lua``) implementation:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:623
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP "
"PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name)"
" or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-"
"role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:662
msgid "Once the configuration is customized, do one of the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:664
msgid ""
"continue developing your application and pay attention to its "
":ref:`versioning <cartridge-versioning>`;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:666
msgid ""
"(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web"
" interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:667
msgid ""
"in case the cluster is already deployed, :ref:`apply the configuration "
"<cartridge-role-config-apply>` cluster-wide."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:674
msgid "Applying custom role's configuration"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:676
msgid ""
"With the implementation showed by the :ref:`example <cartridge-role-"
"config-example>`, you can call the ``set_secret()`` function to apply the"
" new configuration via the administrative console or an HTTP endpoint if "
"the role exports one."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:680
msgid ""
"The ``set_secret()`` function calls "
"``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase "
"commit:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:683
msgid ""
"It patches the active configuration in memory: copies the table and "
"replaces the ``\"custom-role\"`` section in the copy with the one given "
"by the ``set_secret()`` function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:687
msgid ""
"The cluster checks if the new configuration can be applied on all "
"instances except disabled and expelled. All instances subject to update "
"must be healthy and ``alive`` according to the `membership module "
"<https://www.tarantool.io/en/doc/2.2/reference/reference_rock/membership/>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:692
msgid ""
"(**Preparation phase**) The cluster propagates the patched configuration."
" Every instance validates it with the ``validate_config()`` function of "
"every registered role. Depending on the validation's result:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:696
msgid ""
"If successful (i.e., returns ``true``), the instance saves the new "
"configuration to a temporary file named ``config.prepare.yml`` within the"
" working directory."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:699
msgid ""
"(**Abort phase**) Otherwise, the instance reports an error and all other "
"instances roll back the update: remove the file they may have already "
"prepared."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:703
msgid ""
"(**Commit phase**) Upon successful preparation of all instances, the "
"cluster commits the changes. Every instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:706
msgid "Creates the active configuration's hard-link."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:707
msgid ""
"Atomically replaces the active one with the prepared. The atomic "
"replacement is indivisible -- it can either succeed or fail entirely, "
"never partially."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:710
msgid "Calls the ``apply_config()`` function of every registered role."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:712
msgid ""
"If any of these steps fail, an error pops up in the web interface next to"
" the corresponding instance. The cluster does not handle such errors "
"automatically, they require manual repair."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:716
msgid ""
"You will avoid the repair if the ``validate_config()`` function can "
"detect all configuration problems that may lead to ``apply_config()`` "
"errors."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:723
msgid "Using the built-in HTTP server"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:725
msgid ""
"The cluster launches an ``httpd`` server instance during initialization "
"(``cartridge.cfg()``). You can bind a port to the instance via an "
"environmental variable:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:729
msgid ""
"-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Pass the port to the cluster:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:741
msgid ""
"To make use of the ``httpd`` instance, access it and configure routes "
"inside the ``init()`` function of some role, e.g. a role that exposes API"
" over HTTP:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:744
msgid ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Get the httpd instance:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Configure a route to, for example, metrics:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:766
msgid ""
"For more information on the usage of Tarantool's HTTP server, see `its "
"documentation <https://github.com/tarantool/http>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:773
msgid "Implementing authorization in the web interface"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:775
msgid ""
"To implement authorization in the web interface of every instance in "
"Tarantool cluster:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:778
msgid ""
"Implement a new, say, ``auth`` module with a ``check_password`` function."
" It should check the credentials of any user trying to log in to the web "
"interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:781
msgid ""
"The ``check_password`` function accepts a username and password and "
"returns an authentication success or failure."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:784
msgid ""
"-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:801
msgid ""
"Pass the implemented ``auth`` module name as a parameter to "
"``cartridge.cfg()``, so the cluster can use it:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:804
msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' "
"module.\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:814
msgid ""
"This adds a **Log in** button to the upper right corner of the web "
"interface but still lets the unsigned users interact with the interface. "
"This is convenient for testing."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:820
msgid ""
"Also, to authorize requests to cluster API, you can use the HTTP basic "
"authorization header."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:823
msgid ""
"To require the authorization of every user in the web interface even "
"before the cluster bootstrap, add the following line:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:826
msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:837
msgid ""
"With the authentication enabled and the ``auth`` module implemented, the "
"user will not be able to even bootstrap the cluster without logging in. "
"After the successful login and bootstrap, the authentication can be "
"enabled and disabled cluster-wide in the web interface and the "
"``auth_enabled`` parameter is ignored."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:847
msgid "Application versioning"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:849
msgid ""
"Tarantool Cartridge understands semantic versioning as described at "
"`semver.org <https://semver.org>`_. When developing an application, "
"create new Git branches and tag them appropriately. These tags are used "
"to calculate version increments for subsequent packaging."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:854
msgid ""
"For example, if your application has version 1.2.1, tag your current "
"branch with ``1.2.1`` (annotated or not)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:857
msgid "To retrieve the current version from Git, say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:859
msgid ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:864
msgid ""
"This output shows that we are 12 commits after the version 1.2.1. If we "
"are to package the application at this point, it will have a full version"
" of ``1.2.1-12`` and its package will be named "
"``<app_name>-1.2.1-12.rpm``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:868
msgid ""
"Non-semantic tags are prohibited. You will not be able to create a "
"package from a branch with the latest tag being non-semantic."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:871
msgid ""
"Once you :ref:`package <cartridge-deploy>` your application, the version "
"is saved in a ``VERSION`` file in the package root."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:878
msgid "Using .cartridge-cli.ignore files"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:880
msgid ""
"You can add a ``.cartridge-cli.ignore`` file to your application "
"repository to exclude particular files and/or directories from package "
"builds."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:883
msgid ""
"For the most part, the logic is similar to that of ``.gitignore`` files. "
"The major difference is that in ``.cartridge-cli.ignore`` files the order"
" of exceptions relative to the rest of the templates does not matter, "
"while in ``.gitignore`` files the order does matter."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:894
msgid "**.cartridge-cli.ignore** entry"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:894
msgid "ignores every..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:896
msgid "``target/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:896
msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:899
msgid "``target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:899
msgid "**file or folder** named ``target``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:902
msgid "``/target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:902
msgid ""
"**file or folder** named ``target`` in the top-most directory (due to the"
" leading ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:905
msgid "``/target/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:905
msgid ""
"**folder** named ``target`` in the top-most directory (leading and "
"trailing ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:908
msgid "``*.class``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:908
msgid "every **file or folder** ending with ``.class``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:911
msgid "``#comment``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:911
msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:914
msgid "``\\#comment``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:914
msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:917
msgid "``target/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:917
msgid ""
"every **folder** named ``logs`` which is a subdirectory of a folder named"
" ``target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:920
msgid "``target/*/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:920
msgid ""
"every **folder** named ``logs`` two levels under a folder named "
"``target`` (``*`` doesn’t include ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:924
msgid "``target/**/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:924
msgid ""
"every **folder** named ``logs`` somewhere under a folder named ``target``"
" (``**`` includes ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:928
msgid "``*.py[co]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:928
msgid ""
"every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it "
"doesn’t match ``.py!``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:931
msgid "``*.py[!co]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:931
msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:934
msgid "``*.file[0-9]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:934
msgid "every **file or folder** ending in digit"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:936
msgid "``*.file[!0-9]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:936
msgid "every **file or folder** ending in anything other than digit"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:939
msgid "``*``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:939
msgid "**every**"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:941
msgid "``/*``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:941
msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:944
msgid "``**/*.tar.gz``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:944
msgid ""
"every ``*.tar.gz`` file or folder which is **one or more** levels under "
"the starting folder"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:948
msgid "``!file``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:948
msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:956
msgid "Deploying an application"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:958
msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:960
msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:961
msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:962
msgid ""
"as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a "
"workaround for production if root access is unavailable)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:964
msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:971
msgid "Deploying as an rpm or deb package"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:973
#: ../doc/book/cartridge/cartridge_dev.rst:1018
msgid "Pack the application into a distributable:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:975
msgid ""
"$ cartridge pack rpm /path/to/<app_name>\n"
"# -- OR --\n"
"$ cartridge pack deb /path/to/<app_name>"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:981
msgid ""
"This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB "
"package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:984
msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:986
msgid "Install:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:988
msgid ""
"$ yum install APP_NAME-VERSION.rpm\n"
"# -- OR --\n"
"$ dpkg -i APP_NAME-VERSION.deb"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:994
#: ../doc/book/cartridge/cartridge_dev.rst:1035
#: ../doc/book/cartridge/cartridge_dev.rst:1072
msgid ":ref:`Configure the instance(s) <cartridge-config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:996
msgid ""
"Start Tarantool instances with the corresponding services. You can do it "
"using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:999
msgid ""
"# starts a single instance\n"
"$ systemctl start my_app\n"
"\n"
"# starts multiple instances\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1009
#: ../doc/book/cartridge/cartridge_dev.rst:1057
#: ../doc/book/cartridge/cartridge_dev.rst:1094
msgid ""
"In case it is a cluster-aware application, proceed to :ref:`deploying the"
" cluster <cartridge-deployment>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1016
msgid "Deploying as a tar+gz archive"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1020
msgid "$ cartridge pack tgz /path/to/<app_name>"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1024
msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1026
msgid ""
"Upload the archive to target servers, with ``tarantool`` and (optionally)"
" :ref:`cartridge-cli <cartridge-install>` installed."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1029
msgid "Extract the archive:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1031
msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1037
#: ../doc/book/cartridge/cartridge_dev.rst:1074
msgid "Start Tarantool instance(s). You can do it using:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1039
#: ../doc/book/cartridge/cartridge_dev.rst:1076
msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1041
#: ../doc/book/cartridge/cartridge_dev.rst:1078
msgid "$ tarantool init.lua # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1045
#: ../doc/book/cartridge/cartridge_dev.rst:1082
msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1047
msgid ""
"# in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1064
msgid "Deploying from sources"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1066
msgid "This deployment method is intended for local testing only."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1068
msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1070
msgid "$ tarantoolctl rocks make"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1084
msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1101
msgid "Configuring instances"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1103
msgid "Instance configuration includes two sets of parameters:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1105
msgid ""
"`cartridge.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#cluster-opts>`_;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1106
msgid ""
"`box.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#box-opts>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1108
msgid "You can set any of these parameters in:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1110
msgid "Command line arguments."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1111
msgid "Environment variables."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1112
msgid "YAML configuration file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1113
msgid "``init.lua`` file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1115
msgid ""
"The order here indicates the priority: command-line arguments override "
"environment variables, and so forth."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1118
msgid ""
"No matter how you :ref:`start the instances <cartridge-run>`, you need to"
" set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1121
msgid ""
"``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or "
"``<PORT>``. Used by other instances to connect to the current one. **DO "
"NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a "
"socket bind."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1125
msgid ""
"``http_port`` -- port to open administrative web interface and API on. "
"Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1128
msgid ""
"``workdir`` -- a directory where all data will be stored: snapshots, wal "
"logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1135
msgid ""
"If you start instances using ``cartridge`` CLI or ``systemctl``, save the"
" configuration as a YAML file, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1138
msgid ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1144
msgid ""
"With ``cartridge`` CLI, you can pass the path to this file as the "
"``--cfg`` command-line argument to the ``cartridge start`` command -- or "
"specify the path in ``cartridge`` CLI configuration (in "
"``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1148
msgid ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1154
msgid ""
"With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the"
" default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` "
"environment variable."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1160
msgid ""
"If you start instances with ``tarantool init.lua``, you need to pass "
"other configuration options as command-line parameters and environment "
"variables, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1164
msgid ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1172
msgid "Starting/stopping instances"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1174
msgid ""
"Depending on your :ref:`deployment method <cartridge-deploy>`, you can "
"start/stop the instances using :ref:`tarantool <cartridge-run-"
"tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or "
":ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1183
msgid "Start/stop using ``tarantool``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1185
msgid "With ``tarantool``, you can start only a single instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1187
msgid "$ tarantool init.lua # the simplest command"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1191
msgid ""
"You can also :ref:`specify more options <cartridge-config-tarantool>` on "
"the command line or in environment variables."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1194
msgid "To stop the instance, use Ctrl+C."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1200
msgid "Start/stop using ``cartridge`` CLI"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1202
msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1204
msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1208
msgid "The options are:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1216
msgid "``--script FILE``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1211
msgid "Application's entry point. Defaults to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1214
msgid "``TARANTOOL_SCRIPT``, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1215
msgid "``./init.lua`` when running from the app's directory, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1216
msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1220
msgid "``--apps_path PATH``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1219
msgid ""
"Path to apps directory when running in a multi-app environment. Defaults "
"to ``/usr/share/tarantool``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1224
#: ../doc/book/cartridge/cartridge_dev.rst:1266
msgid "``--run_dir DIR``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1223
msgid ""
"Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or "
"``/var/run/tarantool``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1228
#: ../doc/book/cartridge/cartridge_dev.rst:1267
msgid "``--cfg FILE``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1227
msgid ""
"Cartridge instances YAML configuration file. Defaults to "
"``TARANTOOL_CFG`` or ``./instances.yml``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1231
msgid "``--foreground``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1231
msgid "Do not daemonize."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1235
msgid "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1239
msgid ""
"It starts all ``tarantool`` instances specified in ``cfg`` file, in "
"foreground, with enforced :ref:`environment variables <cartridge-"
"config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1242
msgid ""
"When ``APP_NAME`` is not provided, ``cartridge`` parses it from "
"``./*.rockspec`` filename."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1245
msgid ""
"When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file "
"and starts all defined instances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1248
msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # start a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1258
msgid "To stop the instances, say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1260
msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1264
msgid "These options from the ``cartridge start`` command are supported:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1273
msgid "Start/stop using ``systemctl``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1275
msgid "To run a single instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1277
msgid "$ systemctl start APP_NAME"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1281
msgid ""
"This will start a  ``systemd`` service that will listen to the port "
"specified in :ref:`instance configuration <cartridge-config>` "
"(``http_port`` parameter)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1285
msgid "To run multiple instances on one or multiple servers:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1287
msgid ""
"$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1294
msgid ""
"where ``APP_NAME@INSTANCE_N`` is the instantiated service name for "
"``systemd`` with an incremental ``N`` -- a number, unique for every "
"instance, added to the port the instance will listen to (e.g., ``3301``, "
"``3302``, etc.)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1299
msgid ""
"To stop all services on a server, use the ``systemctl stop`` command and "
"specify instance names one by one. For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1302
msgid ""
"$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... "
"APP_NAME@INSTANCE_<N>"
msgstr ""

