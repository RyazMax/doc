# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../doc/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:9
msgid "Overview"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:14
msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-"
"channel>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:16
msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, "
"similar to \"condition variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:22
msgid "Index"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:32
msgid "Name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:32
msgid "Use"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid "Create but do not start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid "Yield control"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid "Get information about all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
#: ../doc/reference/reference_lua/fiber.rst:76
msgid "Cancel a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid "Get a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid "Set a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid "Get a fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:76
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid "Make it possible for a new fiber to join"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid "Wait for a fiber's state to become 'dead'"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid "Create a communication channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid "Send a message via a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid "Close a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid "Count messages in a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid "Check if a channel is full"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid "Create a condition variable"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid "Wake up all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:142
msgid "Fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:144
msgid ""
"A **fiber** is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:148
msgid ""
"A fiber has three possible states: **running**, **suspended** or "
"**dead**. When a fiber is created with :ref:`fiber.create() <fiber-"
"create>`, it is running. When a fiber is created with :ref:`fiber.new() "
"<fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, "
"it is suspended. When a fiber ends (because the fiber function ends), it "
"is dead."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:154
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:158
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:169
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:176
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The Lua garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:181
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:193
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "Parameters"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:195
#: ../doc/reference/reference_lua/fiber.rst:236
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:196
#: ../doc/reference/reference_lua/fiber.rst:237
msgid "what will be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "Return"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:198
#: ../doc/reference/reference_lua/fiber.rst:239
msgid "created fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "Rtype"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:199
#: ../doc/reference/reference_lua/fiber.rst:240
#: ../doc/reference/reference_lua/fiber.rst:267
#: ../doc/reference/reference_lua/fiber.rst:287
msgid "userdata"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:201
#: ../doc/reference/reference_lua/fiber.rst:242
#: ../doc/reference/reference_lua/fiber.rst:269
#: ../doc/reference/reference_lua/fiber.rst:289
#: ../doc/reference/reference_lua/fiber.rst:309
#: ../doc/reference/reference_lua/fiber.rst:324
#: ../doc/reference/reference_lua/fiber.rst:343
#: ../doc/reference/reference_lua/fiber.rst:362
#: ../doc/reference/reference_lua/fiber.rst:389
#: ../doc/reference/reference_lua/fiber.rst:415
#: ../doc/reference/reference_lua/fiber.rst:439
#: ../doc/reference/reference_lua/fiber.rst:464
#: ../doc/reference/reference_lua/fiber.rst:491
#: ../doc/reference/reference_lua/fiber.rst:514
#: ../doc/reference/reference_lua/fiber.rst:541
#: ../doc/reference/reference_lua/fiber.rst:572
#: ../doc/reference/reference_lua/fiber.rst:640
#: ../doc/reference/reference_lua/fiber.rst:690
#: ../doc/reference/reference_lua/fiber.rst:723
#: ../doc/reference/reference_lua/fiber.rst:742
msgid "**Example:**"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:203
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name); print(\"Fiber "
"started\")\n"
"I'm a fiber\n"
"Fiber started\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:223
msgid ""
"Create but do not start a fiber: the fiber is created but does not begin "
"to run immediately -- it starts after the fiber creator (that is, the job"
" that is calling ``fiber.new()``) yields, under :ref:`transaction control"
" <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus"
" ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-"
"create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:231
msgid ""
"Ordinarily ``fiber.new()`` is used in conjunction with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and "
":ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:244
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name); print(\"Fiber not "
"started yet\")\n"
"Fiber not started yet\n"
"---\n"
"...\n"
"tarantool> I'm a fiber\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:266
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:271
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:284
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:286
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:291
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:304
msgid ""
"Yield control to the scheduler and sleep for the specified number of "
"seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:307
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:311
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:321
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, "
"`fiber.yield()` does not."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:326
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:336
msgid ""
"Return the status of the current fiber. Or, if optional fiber_object is "
"passed, return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:340
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:341
#: ../doc/reference/reference_lua/fiber.rst:460
#: ../doc/reference/reference_lua/fiber.rst:510
msgid "string"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:345
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:356
msgid "Return information about all fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:358
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:360
msgid "table"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:364
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:382
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:386
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:387
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:391
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:403
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:408
msgid ""
"Even if you catch the exception, the fiber will remain cancelled. Most "
"types of calls will check ``fiber.testcancel()``. However, some functions"
" (``id``, ``status``, ``join`` etc.) will return no error. We recommend "
"application developers to implement occasional checks with "
":ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution"
" as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:417
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:430
#: ../doc/reference/reference_lua/fiber.rst:455
#: ../doc/reference/reference_lua/fiber.rst:483
#: ../doc/reference/reference_lua/fiber.rst:505
#: ../doc/reference/reference_lua/fiber.rst:533
msgid ""
"generally this is an object referenced in the return from "
":ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or "
":ref:`fiber.find <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:434
msgid "id of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:435
#: ../doc/reference/reference_lua/fiber.rst:908
msgid "number"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:437
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:441
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:459
msgid "name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:462
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:466
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:477
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:487
msgid "the new name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:489
#: ../doc/reference/reference_lua/fiber.rst:537
#: ../doc/reference/reference_lua/fiber.rst:638
#: ../doc/reference/reference_lua/fiber.rst:1068
#: ../doc/reference/reference_lua/fiber.rst:1076
msgid "nil"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:493
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:503
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:509
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:512
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:516
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:527
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause"
" ``error: the fiber is dead``. But a dead fiber can still report its id "
"and status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:539
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:543
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:565
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The Lua garbage collector will mark or free the local storage "
"when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:574
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:600
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:606
msgid ""
"``fiber_object:set_joinable(true)`` makes a fiber joinable; "
"``fiber_object:set_joinable(false)`` makes a fiber not joinable; the "
"default is false."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:610
msgid ""
"A joinable fiber can be waited for, with :ref:`fiber_object:join() "
"<fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:613
msgid ""
"Best practice is to call ``fiber_object:set_joinable()`` before the fiber"
" function begins to execute, because otherwise the fiber could become "
"'dead' before ``fiber_object:set_joinable()`` takes effect. The usual "
"sequence could be:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:618
msgid ""
"Call ``fiber.new()`` instead of ``fiber.create()`` to create a new "
"fiber_object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:621
msgid ""
"Do not yield at this point, because that will cause the fiber function to"
" begin."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:624
msgid ""
"Call ``fiber_object:set_joinable(true)`` to make the new fiber_object "
"joinable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:627
msgid "Now it is safe to yield."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:629
msgid "Call ``fiber_object:join()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:631
msgid ""
"Usually ``fiber_object:join()`` should be called, otherwise the fiber's "
"status may become 'suspended' when the fiber function ends, instead of "
"'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:635
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:642
#: ../doc/reference/reference_lua/fiber.rst:692
msgid "The result of the following sequence of requests is:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:644
msgid ""
"the global variable ``d`` will be 6 (which proves that the function was "
"not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` "
"caused a yield);"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:647
msgid ""
"``fiber.status(fi2)`` will be 'suspended' (which proves that after the "
"function was executed the fiber status did not change to 'dead')."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:650
msgid ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:663
msgid ""
"\"Join\" a joinable fiber. That is, let the fiber's function run and wait"
" until the fiber's status is 'dead' (normally a status becomes 'dead' "
"when the function execution finishes). Joining will cause a yield, "
"therefore, if the fiber is currently in a suspended state, execution of "
"its fiber function will resume."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:671
msgid ""
"This kind of waiting is more convenient than going into a loop and "
"periodically checking the status; however, it works only if the fiber was"
" created with :ref:`fiber.new() <fiber-new>` and was made joinable with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:678
msgid ""
"two values. The first value is boolean. If the first value is true, then "
"the join succeeded because the fiber's function ended normally and the "
"second result has the return value from the fiber's function. If the "
"first value is false, then the join succeeded because the fiber's "
"function ended abnormally and the second result has the details about the"
" error, which one can unpack in the same way that one unpacks :ref:`a "
"pcall result <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:688
msgid "boolean +result type, or boolean + struct error"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:694
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:695
msgid "the ``join()`` call returns true,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:696
msgid "the elapsed time is usually 5 seconds, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:697
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:699
msgid ""
"This proves that the ``join()`` does not return until the function -- "
"which sleeps 5 seconds -- is 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:702
msgid ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:717
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:721
#: ../doc/reference/reference_lua/fiber.rst:740
msgid "num"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:725
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:737
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:744
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:754
#: ../doc/reference/reference_lua/fiber.rst:951
#: ../doc/reference/reference_lua/fiber.rst:1080
msgid "Example"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:756
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop. Each iteration of the loop adds 1 to a global "
"variable named gvar, then goes to sleep for 2 seconds. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:761
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:774
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:777
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:785
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:787
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:793
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:798
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:805
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:810
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:826
msgid "Channels"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:828
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:831
msgid ""
"Call the other routines, via channel, to send messages, receive messages,"
" or check channel status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:834
msgid ""
"Message exchange is synchronous. The Lua garbage collector will mark or "
"free the channel when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:843
msgid "Create a new communication channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:845
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "return"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:849
msgid "new channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst
msgid "rtype"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:850
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:858
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:861
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:862
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:863
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:867
#: ../doc/reference/reference_lua/fiber.rst:899
#: ../doc/reference/reference_lua/fiber.rst:919
#: ../doc/reference/reference_lua/fiber.rst:929
#: ../doc/reference/reference_lua/fiber.rst:939
#: ../doc/reference/reference_lua/fiber.rst:947
#: ../doc/reference/reference_lua/fiber.rst:1059
msgid "boolean"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:873
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:881
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:884
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:885
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:890
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:896
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:898
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:905
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:907
msgid "the number of messages."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:914
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:916
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:925
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:928
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:935
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:938
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:945
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:953
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:957
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1023
msgid "Condition variables"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1025
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called 'cond' for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1028
msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition "
"variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1030
msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that "
"has executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1033
msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have "
"executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1040
msgid "Create a new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1042
msgid "new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1043
msgid "Lua object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1051
msgid ""
"Make the current fiber go to sleep, waiting until another fiber invokes "
"the ``signal()`` or ``broadcast()`` method on the cond object. The sleep "
"causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1055
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1056
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1065
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1074
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1082
msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1086
msgid "On terminal #1, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1088
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1095
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1098
msgid "On terminal #2, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1100
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1105
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1108
msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""

