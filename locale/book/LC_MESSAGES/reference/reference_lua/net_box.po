# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:9
msgid "Overview"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:11
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). "
"The other variant, which is discussed in this section, is for connecting "
"to Tarantool server instances via a network."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:19
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:21
msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:23
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on "
"the remote database system,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:27
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In fact"
" that is perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. However for "
"some cases a single connection is not enough â€”- for example, when it is "
"necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:36
msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can "
"be:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:38
msgid ""
"``{timeout=...}``. For example, a method whose final argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although"
" this does not guarantee that execution will stop on the remote server "
"node."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:42
msgid ""
"``{is_async=...}``. For example, a method whose final argument is "
"``{is_async=true}`` will not wait for the result of a request. See the "
":ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:45
msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. "
"See the :ref:`box.session.push <box_session-push>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:60
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:62
msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:66
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:71
msgid "Index"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:81
msgid "Name"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:81
msgid "Use"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:83
msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>` |br| :ref:`net_box.self <net_box-self>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:89
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:89
msgid "Execute a PING command"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:92
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:92
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:95
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:95
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:98
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:98
msgid "Wait for a target state"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:101
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:101
msgid "Close a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:104
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:104
msgid "Select one or more tuples"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:107
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:107
msgid "Select a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:110
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:110
msgid "Insert a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:113
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:113
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:116
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:116
#: ../doc/reference/reference_lua/net_box.rst:119
msgid "Update a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:119
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:122
msgid "Delete a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:125
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:125
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:128
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:128
msgid "Call a stored procedure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:131
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:131
msgid "Set a timeout"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:134
msgid ":ref:`conn:on_connect() <net_box-on_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:134
msgid "Define a connect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:137
msgid ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:137
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:140
msgid ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:140
msgid "Define a trigger when schema is modified"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:155
msgid ""
"The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
"preferred; ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:158
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:164
msgid "Possible options:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:166
msgid ""
"`user/password`: you have two ways to connect to a remote host: using "
":ref:`URI <index-uri>` or using the options `user` and `password`. For "
"example, instead of ``connect('username:userpassword@localhost:33301')`` "
"you can write ``connect('localhost:33301', {user = 'username', "
"password='userpassword'})``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:171
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 "
"seconds)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:177
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores "
"transient failures. The wait completes once the connection is established"
" or is closed explicitly."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:180
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any "
"time the connection is broken or if a connection attempt fails. This "
"makes transient network failures become transparent to the application. "
"Reconnect happens automatically in the background, so queries/requests "
"that suffered due to connectivity loss are transparently retried. The "
"number of retries is unlimited, connection attempts are done over the "
"specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a "
"connection is explicitly closed, or once the Lua garbage collector "
"removes it, reconnects stop."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:190
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:199
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported). Deprecation notice: "
"``console = true`` is deprecated, users should use "
":ref:`console.connect() <console-connect>` instead."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:207
msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst
msgid "Parameters"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:209
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:210
msgid ""
"possible options are `user`, `password`, `wait_connected`, "
"`reconnect_after`, `call_16`, `console` and `connect_timeout`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst
msgid "return"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:212
msgid "conn object"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst
msgid "rtype"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:213
msgid "userdata"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:215
#: ../doc/reference/reference_lua/net_box.rst:305
#: ../doc/reference/reference_lua/net_box.rst:436
#: ../doc/reference/reference_lua/net_box.rst:470
msgid "**Examples:**"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:217
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:227
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:233
msgid ""
"However, there is an important difference between the embedded connection"
" and a remote one:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:236
msgid ""
"With the embedded connection, requests which do not modify data do not "
"yield. When using a remote connection, due to :ref:`the implicit rules "
"<atomic-implicit-yields>` any request can yield, and the database state "
"may have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
msgid ""
"All the options passed to a request (as ``is_async``, ``on_push``, "
"``timeout``) will be ignored."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:251
msgid "Execute a PING command."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:253
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:254
msgid "true on success, false on error"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:255
#: ../doc/reference/reference_lua/net_box.rst:271
#: ../doc/reference/reference_lua/net_box.rst:286
#: ../doc/reference/reference_lua/net_box.rst:303
msgid "boolean"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:257
#: ../doc/reference/reference_lua/net_box.rst:273
#: ../doc/reference/reference_lua/net_box.rst:288
#: ../doc/reference/reference_lua/net_box.rst:329
#: ../doc/reference/reference_lua/net_box.rst:342
#: ../doc/reference/reference_lua/net_box.rst:364
#: ../doc/reference/reference_lua/net_box.rst:377
#: ../doc/reference/reference_lua/net_box.rst:390
#: ../doc/reference/reference_lua/net_box.rst:403
#: ../doc/reference/reference_lua/net_box.rst:499
#: ../doc/reference/reference_lua/net_box.rst:551
msgid "**Example:**"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:259
msgid "net_box.self:ping({timeout = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:267
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:269
#: ../doc/reference/reference_lua/net_box.rst:301
msgid "in seconds"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:270
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:275
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:283
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:285
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:290
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:298
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:300
msgid "target states"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:302
msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:307
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:322
msgid "Close a connection."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:324
msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like "
"any other objects in Lua, so an explicit destruction is not mandatory. "
"However, since close() is a system call, it is good programming practice "
"to close a connection explicitly when it is no longer needed, to avoid "
"lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:331
msgid "conn:close()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:339
msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:344
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:350
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:361
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:366
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:374
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:379
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:387
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:392
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:400
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:405
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:413
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:420
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:427
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:433
msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua "
"expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:438
msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:462
msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call. The return from ``conn:call`` is whatever the function "
"returns."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:466
msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then "
"``conn:call(func2)`` will return \"error: unsupported Lua type "
"'function'\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:472
msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:495
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it. Since version 1.7.4 this method is deprecated -- it is better"
" to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:501
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:505
msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its "
"use. Using a wrapper object makes the remote connection API compatible "
"with the local one, removing the need for a separate ``timeout`` "
"argument, which the local version would ignore. Once a request is sent, "
"it cannot be revoked from the remote server even if a timeout expires: "
"the timeout expiration only aborts the wait for the remote server "
"response, not the request itself."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:517
msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the "
"``conn.space.space-name`` requests."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:521
msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for "
"the fiber. The fiber is blocked, waiting until there is a reply to the "
"request or until timeout expires. Before Tarantool version 1.10, the only"
" way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:527
msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous "
"for the fiber. The request causes a yield but there is no waiting. The "
"immediate return is not the result of the request, instead it is an "
"object that the calling program can use later to get the result of the "
"request."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:533
msgid ""
"This immediately-returned object, which we'll call \"future\", has its "
"own methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:536
msgid ""
"``future:is_ready()`` which will return true when the result of the "
"request is available,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:538
msgid ""
"``future:result()`` to get the result of the request (returns the "
"response or **nil** in case it's not ready yet or there has been an "
"error),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:540
msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request "
"is available and then get it,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:542
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:544
msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, "
"then either loop checking ``future:is_ready()`` until it is true and then"
" say ``request_result=future:result()``, or say "
"``request_result=future:wait_result(...)``. Alternatively the client "
"could check for \"out-of-band\" messages from the server by calling "
"``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-"
"push>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:553
msgid ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:575
msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more "
"than 100,000 requests per second) and latency is large (more than 1 "
"second), or when it is necessary to send multiple requests in parallel "
"then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:583
msgid ""
"Although the final result of an async request is the same as the result "
"of a sync request, it is structured differently: as a table, instead of "
"as the unpacked values."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:591
msgid "Triggers"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:593
msgid ""
"With the ``net.box`` module, you can use the following :ref:`triggers "
"<triggers-box_triggers>`:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:600
msgid ""
"Define a trigger for execution when a new connection is created due to an"
" event such as ``net_box.connect``. The trigger function will be the "
"first thing executed after a new connection is created. If the trigger "
"execution fails and raises an error, the error is sent to the client and "
"the connection is closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:605
#: ../doc/reference/reference_lua/net_box.rst:619
#: ../doc/reference/reference_lua/net_box.rst:632
msgid ""
"function which will become the trigger function. Takes the ``conn`` "
"object as the first argument"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:607
#: ../doc/reference/reference_lua/net_box.rst:621
#: ../doc/reference/reference_lua/net_box.rst:634
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:608
#: ../doc/reference/reference_lua/net_box.rst:622
#: ../doc/reference/reference_lua/net_box.rst:635
msgid "nil or function pointer"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:614
msgid ""
"Define a trigger for execution after a connection is closed. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. Execution stops after a connection is explicitly closed, or once"
" the Lua garbage collector removes it."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:628
msgid ""
"Define a trigger executed when some operation has been performed on the "
"remote server after schema has been updated. So, if a server request "
"fails due to a schema version mismatch error, schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:639
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:642
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:645
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:650
msgid "Example"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:652
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:654
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:656
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:657
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:659
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:661
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:663
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:671
msgid "And here starts the example:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:673
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

