# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: 2019-10-23 18:45+0400\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/tutorials/sql_tutorial.rst:5
#, fuzzy
msgid "SQL tutorial"
msgstr "Практическое задание на C"

#: ../doc/tutorials/sql_tutorial.rst:7
msgid ""
"This tutorial is a demonstration of the SQL feature introduced in Tarantool "
"2.x series. There are two ways to go through this tutorial:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:10
msgid "read what we say the results are and take our word for it, or"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:11
msgid "copy and paste each section and see everything work with Tarantool 2.1."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:13
msgid ""
"You will encounter all the functionality that you'd encounter in an "
"\"SQL-101\" course."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:20
msgid "Starting up with a first table and SELECTs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:24
msgid "Initialize"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:26
#, fuzzy
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool and, optionally, enter the "
"Tarantool configuration request, for example:"
msgstr ""
"Tarantool выполняет запросы в качестве :ref:`клиента <admin-"
"using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

#: ../doc/tutorials/sql_tutorial.rst:31
msgid "tarantool> box.cfg{}"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:35
msgid ""
"Before Tarantool 2.0 you needed to say ``box.cfg{...}`` prior to performing "
"any database operations. Now you can start working with the database "
"outright. Tarantool initiates the database module and applies :ref:`default "
"settings <box_introspection-box_cfg>`."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:43
msgid "\\set"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:45
msgid ""
"A feature of the client console program is that you can switch languages and "
"specify the end-of-statement delimiter."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:48
msgid ""
"Here we say: default language is SQL and statements end with semicolons."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:50
msgid ""
"tarantool> \\set language sql\n"
"tarantool> \\set delimiter ;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:57
msgid "CREATE, INSERT, UPDATE, SELECT"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:59
msgid "Start with simple SQL statements just to be sure they're there."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:61
msgid ""
"CREATE TABLE table1 (column1 INTEGER PRIMARY KEY, column2 VARCHAR(100));\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"UPDATE table1 SET column2 = 'B';\n"
"SELECT * FROM table1 WHERE column1 = 1;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:68
#, fuzzy
msgid "The result of the ``SELECT`` statement will look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

#: ../doc/tutorials/sql_tutorial.rst:70
msgid ""
"tarantool> SELECT * FROM table1 WHERE column1 = 1;\n"
"---\n"
"- - [1, 'B']\n"
"..."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:77
msgid ""
"Reality check: actually the result will include include initial fields "
"called \"metadata\", the names and data types of each column. For all SELECT "
"examples we show only the result rows without showing the metadata."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:83
msgid "CREATE TABLE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:85
msgid "Here is ``CREATE TABLE`` with more details:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:87
msgid "There are multiple columns, with different data types."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:88
msgid ""
"There is a ``PRIMARY KEY`` (unique and not-null) for two of the columns."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:90
msgid ""
"CREATE TABLE table2 (column1 INTEGER,\n"
"                     column2 VARCHAR(100),\n"
"                     column3 SCALAR,\n"
"                     column4 FLOAT,\n"
"                     PRIMARY KEY (column1, column2));"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:98 ../doc/tutorials/sql_tutorial.rst:253
msgid "The result will be: \"``rowcount: 1``\" (no error)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:102
msgid "INSERT"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:104
msgid "Try to put 5 rows in the table:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:106
msgid "The INTEGER and FLOAT columns get numbers."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:107
msgid ""
"The VARCHAR and SCALAR columns get strings (the SCALAR strings are expressed "
"as hexadecimals)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:110
msgid ""
"INSERT INTO table2 VALUES (1, 'AB', X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (1, 'CD', X'2020', 1E4);\n"
"INSERT INTO table2 VALUES (1, 'AB', X'A5', -5.5);\n"
"INSERT INTO table2 VALUES (2, 'AB', X'2020', 12.34567);\n"
"INSERT INTO table2 VALUES (-1000, '', X'', 0.0);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:118 ../doc/tutorials/sql_tutorial.rst:138
#: ../doc/tutorials/sql_tutorial.rst:200 ../doc/tutorials/sql_tutorial.rst:229
#: ../doc/tutorials/sql_tutorial.rst:272 ../doc/tutorials/sql_tutorial.rst:322
#: ../doc/tutorials/sql_tutorial.rst:421 ../doc/tutorials/sql_tutorial.rst:509
#: ../doc/tutorials/sql_tutorial.rst:536
msgid "The result will be:"
msgstr "Получим следующий результат:"

#: ../doc/tutorials/sql_tutorial.rst:120
msgid ""
"The third ``INSERT`` will fail because of a primary-key violation (``1, "
"'AB'`` is a duplication)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:122
msgid "The other four ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:126
msgid "SELECT with ORDER BY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:128
msgid ""
"Retrieve the 4 rows in the table, in descending order by ``column2``, then "
"(where the ``column2`` values are the same) in ascending order by column4."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:132
msgid "\"*\" is short for \"all columns\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:134
msgid "SELECT * FROM table2 ORDER BY column2 DESC, column4 ASC;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:140
msgid ""
"- - [1, 'CD', '  ', 10000]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [2, 'AB', '  ', 12.34567]\n"
"  - [-1000, '', '', 0]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:149
msgid "SELECT with WHERE clauses"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:151
msgid "Retrieve some of what you inserted:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:153
msgid ""
"The first statement uses the ``LIKE`` comparison operator which is asking "
"for \"first character must be 'A', the next characters can be anything.\""
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:156
msgid ""
"The second statement uses logical operators and parentheses, so the ANDed "
"expressions must be true, or the ORed expression must be true. Notice the "
"columns don't have to be indexed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:160
msgid ""
"SELECT column1, column2, column1 * column4 FROM table2 WHERE column2\n"
"LIKE 'A%';\n"
"SELECT column1, column2, column3, column4 FROM table2\n"
"    WHERE (column1 < 2 AND column4 < 10)\n"
"    OR column3 = X'2020';"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:168
#, fuzzy
msgid "The results will be:"
msgstr "Получим следующий результат:"

#: ../doc/tutorials/sql_tutorial.rst:170
msgid ""
"- - [1, 'AB', 5.5]\n"
"  - [2, 'AB', 24.69134]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:175
msgid "and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:177
msgid ""
"- - [-1000, '', '', 0]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [1, 'CD', '  ', 10000]\n"
"  - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:186
msgid "SELECT with GROUP BY and aggregating"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:188
msgid "Retrieve with grouping."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:190
msgid ""
"The rows which have the same values for ``column2`` are grouped and are "
"aggregated -- summed, counted, averaged -- for ``column4``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:194
msgid ""
"SELECT column2, SUM(column4), COUNT(column4), AVG(column4)\n"
"FROM table2\n"
"GROUP BY column2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:202
msgid ""
"- - ['', 0, 1, 0]\n"
"  - ['AB', 17.84567, 2, 8.922835]\n"
"  - ['CD', 10000, 1, 10000]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:212
msgid "Complications and complex SELECTs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:216
msgid "NULLs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:218
msgid "Insert more rows, containing NULL values."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:220
msgid ""
"NULL is not the same as Lua nil; it commonly is used in SQL for unknown or "
"not-applicable."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:223
msgid ""
"INSERT INTO table2 VALUES (1, NULL, X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (0, '!!@', NULL, NULL);\n"
"INSERT INTO table2 VALUES (0, '!!!', X'00', NULL);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:231
msgid ""
"The first ``INSERT`` will fail because NULL is not permitted for a column "
"that was defined with a ``PRIMARY KEY`` clause."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:234
msgid "The other ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:238
msgid "Indexes"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:240
msgid "Make a new index on column4."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:242
msgid ""
"There already is an index for the primary key. Indexes are useful for making "
"queries faster. In this case, the index also acts as a constraint, because "
"it prevents two rows from having the same values in ``column4``. However, it "
"is not an error that ``column4`` has multiple occurrences of NULLs."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:249
msgid "CREATE UNIQUE INDEX i ON table2 (column4);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:257
msgid "Create a subset table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:259
msgid ""
"Make a table which will have some of the columns of ``table2``, and some of "
"the rows of ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:262
msgid ""
"You can do this by combining ``INSERT`` with ``SELECT``. Then select "
"everything in the resultant subset table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:265
msgid ""
"CREATE TABLE table3 (column1 INTEGER, column2 VARCHAR(100), PRIMARY KEY\n"
"(column2));\n"
"INSERT INTO table3 SELECT column1, column2 FROM table2 WHERE column1 <> 2;\n"
"SELECT * FROM table3;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:274
msgid ""
"- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:284
msgid "SELECT with a subquery"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:286
msgid "A subquery is a query within a query."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:288
msgid ""
"Here we find all the rows in ``table2`` whose ``(column1, column2)`` values "
"are not in ``table3``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:291
msgid ""
"SELECT * FROM table2 WHERE (column1, column2) NOT IN (SELECT column1,\n"
"column2 FROM table3);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:296
msgid ""
"The result is, unsurprisingly, the single row which we deliberately excluded "
"when we inserted the rows in the ``INSERT ... SELECT`` statement:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:300
msgid "- - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:306
msgid "SELECT with a join"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:308
msgid ""
"A join is a combination of two tables. There is more than one way to do them "
"in Tarantool: \"Cartesian joins\", \"left outer joins\", etc."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:312
msgid ""
"Here we're just showing the most typical case, where column values from one "
"table match column values from another table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:316
msgid ""
"SELECT * FROM table2, table3\n"
"    WHERE table2.column1 = table3.column1 AND table2.column2 = table3."
"column2\n"
"    ORDER BY table2.column4;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:324
msgid ""
"- - [0, '!!!', \"\\0\", null, 0, '!!!']\n"
"  - [0, '!!@', null, null, 0, '!!@']\n"
"  - [-1000, '', '', 0, -1000, '']\n"
"  - [1, 'AB', 'AB', 5.5, 1, 'AB']\n"
"  - [1, 'CD', ' ', 10000, 1, 'CD']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:336
msgid "Constraints affecting updates"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:340
msgid "CREATE TABLE, with a CHECK clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:342
msgid ""
"First we make a table which includes a \"constraint\" that there must not be "
"any rows containing 13 in ``column2``. Then we try to insert such a row."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:346
msgid ""
"CREATE TABLE table4 (column1 INTEGER PRIMARY KEY, column2 INTEGER, CHECK\n"
"(column2 <> 13));\n"
"INSERT INTO table4 VALUES (12, 13);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:352
msgid ""
"Result: the insert fails, as it should, with the message \"``error: 'CHECK "
"constraint failed: TABLE4'``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:357
msgid "CREATE TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:359
msgid ""
"First we make a table which includes a \"constraint\" that there must not be "
"any rows containing values that do not appear in ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:363
msgid ""
"When we made ``table2``, we specified that its \"primary key\" columns were "
"``(column1, column2)``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:366
msgid ""
"CREATE TABLE table5 (column1 INTEGER, column2 VARCHAR(100),\n"
"    PRIMARY KEY (column1),\n"
"    FOREIGN KEY (column1, column2) REFERENCES table2 (column1, column2));\n"
"INSERT INTO table5 VALUES (2,'AB');\n"
"INSERT INTO table5 VALUES (3,'AB');"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:374 ../doc/tutorials/sql_tutorial.rst:477
msgid "Result:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:376
msgid ""
"The first ``INSERT`` statement succeeds because ``table3`` contains a row "
"with ``[2, 'AB', ' ', 12.34567]``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:378
msgid ""
"The second INSERT statement, correctly, fails with the message \"``error: "
"FOREIGN KEY constraint failed``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:383
msgid "UPDATE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:385
msgid ""
"Due to earlier INSERT statements, these values are in ``table2 column4``: "
"``{0, NULL, NULL, 5.5, 10000, 12.34567}``. We will add 5 to every one of "
"them except the one with 0. (Adding 5 to NULL will result in NULL, as SQL "
"arithmetic requires.) Then we'll use ``SELECT`` to see what happened to "
"``column4``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:391
msgid ""
"UPDATE table2 SET column4 = column4 + 5 WHERE column4 <> 0;\n"
"SELECT column4 FROM table2 ORDER BY column4;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:396
msgid "The result is: ``{NULL, NULL, 0, 10.5, 17.34567, 10005}``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:400
msgid "DELETE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:402
msgid ""
"Due to earlier ``INSERT`` statements, there are now 6 rows in ``table2``:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:404
msgid ""
"- - [-1000, '', '', 0]\n"
"  - [0, '!!!', \"\\0\", null]\n"
"  - [0, '!!@', null, null]\n"
"  - [1, 'AB', 'AB', 10.5]\n"
"  - [1, 'CD', '  ', 10005]\n"
"  - [2, 'AB', '  ', 17.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:413
msgid "We will try to delete the last and first of these rows."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:415
msgid ""
"DELETE FROM table2 WHERE column1 = 2;\n"
"DELETE FROM table2 WHERE column1 = -1000;\n"
"SELECT COUNT(column1) FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:423
msgid ""
"The first ``DELETE`` statement causes an error message because (remember?) "
"there's a foreign-key constraint."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:425
msgid "The second ``DELETE`` statement succeeds."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:426
msgid ""
"The ``SELECT`` statement shows that there are now only 5 rows remaining."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:430
msgid "ALTER TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:432
msgid ""
"Now we want to make another \"constraint\", that there must not be any rows "
"in ``table1`` containing values that do not appear in ``table5``. We "
"couldn't do this when we created ``table1`` because at that time ``table5`` "
"did not exist. But we can add constraints to existing tables with the ALTER "
"TABLE statement."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:440
msgid ""
"ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);\n"
"DELETE FROM table1;\n"
"ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:448
msgid ""
"Result: the ``ALTER TABLE`` statement fails the first time because there is "
"a row in ``table1``, and ADD CONSTRAINT requires that the table be empty. "
"But after we delete that row, the ``ALTER TABLE`` statement succeeds the "
"second time. Thus we have set up a chain of references, from ``table1`` to "
"``table5`` and from ``table5`` to ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:457
msgid "Triggers"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:459
msgid ""
"The idea of a trigger is: if a change (``INSERT`` or ``UPDATE`` or "
"``DELETE``) happens, then a further action -- perhaps another ``INSERT`` or "
"``UPDATE`` or ``DELETE`` -- will happen."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:463
msgid ""
"There are many variants, the one we'll illustrate here is: just after doing "
"an update in ``table3``, do an update in ``table2``. We will specify this as "
"``FOR EACH ROW``, so (since there are 5 rows in ``table3``) the trigger will "
"be activated 5 times."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:469
msgid ""
"SELECT column4 FROM table2 WHERE column1 = 2;\n"
"CREATE TRIGGER tr AFTER UPDATE ON table3 FOR EACH ROW\n"
"BEGIN UPDATE table2 SET column4 = column4 + 1 WHERE column1 = 2; END;\n"
"UPDATE table3 SET column2 = column2;\n"
"SELECT column4 FROM table2 WHERE column1 = 2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:479
msgid ""
"The first ``SELECT`` shows that the original value of ``column4`` in "
"``table2`` where ``column1 = 2`` was: 17.34567."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:481
msgid "The second ``SELECT`` returns:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:483
msgid "- - [22.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:491
msgid "Operators and functions"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:495
#, fuzzy
msgid "String operations"
msgstr "начинает транзакцию;"

#: ../doc/tutorials/sql_tutorial.rst:497
msgid ""
"You can manipulate string data (usually defined with CHAR or VARCHAR data "
"types) in many ways."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:500 ../doc/tutorials/sql_tutorial.rst:527
msgid "We'll illustrate here:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:502
msgid "the ``||`` operator for concatenation and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:503
msgid "the ``SUBSTR`` function for extraction."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:505
msgid "SELECT column2, column2 || column2, SUBSTR(column2, 2, 1) FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:511
msgid ""
"- - ['!!!', '!!!!!!', '!']\n"
"  - ['!!@', '!!@!!@', '!']\n"
"  - ['AB', 'ABAB', 'B']\n"
"  - ['CD', 'CDCD', 'D']\n"
"  - ['AB', 'ABAB', 'B']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:522
msgid "Number operations"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:524
msgid ""
"You can also manipulate number data (usually defined with INTEGER or FLOAT "
"data types) in many ways."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:529
msgid "the ``<<`` operator for shift left and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:530
msgid "the ``%`` operator for modulo."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:532
msgid "SELECT column1, column1 << 1, column1 << 2, column1 % 2 FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:538
msgid ""
"- - [0, 0, 0, 0]\n"
"  - [0, 0, 0, 0]\n"
"  - [1, 2, 4, 1]\n"
"  - [1, 2, 4, 1]\n"
"  - [2, 4, 8, 0]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:548
msgid "Ranges and limits"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:550
msgid "Tarantool can handle:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:552
msgid "integers anywhere in the 4-byte integer range,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:553
msgid "approximate-numerics anywhere in the 8-byte IEEE floating point range,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:554
msgid "any Unicode characters, with UTF-8 encoding and a choice of collations."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:556
msgid ""
"Here we will insert some such values in a new table, and see what happens "
"when we select them, with arithmetic on a number column and ordering by a "
"string column."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:560
msgid ""
"CREATE TABLE t6 (column1 INTEGER, column2 VARCHAR(10), column4 FLOAT,\n"
"PRIMARY KEY (column1));\n"
"INSERT INTO t6 VALUES (-1234567890, 'АБВГД', 123456.123456);\n"
"INSERT INTO t6 VALUES (+1234567890, 'GD', 1e30);\n"
"INSERT INTO t6 VALUES (10, 'FADEW?', 0.000001);\n"
"INSERT INTO t6 VALUES (5, 'ABCDEFG', NULL);\n"
"SELECT column1 + 1, column2, column4 * 2 FROM t6 ORDER BY column2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:570 ../doc/tutorials/sql_tutorial.rst:596
#: ../doc/tutorials/sql_tutorial.rst:781
#, fuzzy
msgid "The result is:"
msgstr "Получим следующий результат:"

#: ../doc/tutorials/sql_tutorial.rst:572
msgid ""
"- - [6, 'ABCDEFG', null]\n"
"  - [11, 'FADEW?', 2e-06]\n"
"  - [1234567891, 'GD', 2e+30]\n"
"  - [-1234567889, 'АБВГД', 246912.246912]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:581
msgid "Views"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:583
msgid ""
"A view, or \"viewed table\", is virtual, that is, its rows aren't physically "
"in the database, their values are calculated from other tables."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:587
msgid ""
"Here we'll create a view ``v3`` based on ``table3``, then we select from it."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:590
msgid ""
"CREATE VIEW v3 AS SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE\n"
"column4 >= 0;\n"
"SELECT * FROM v3;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:598 ../doc/tutorials/sql_tutorial.rst:623
msgid ""
"- - ['АБ', 123456.123456]\n"
"  - ['FA', 1e-06]\n"
"  - ['GD', 1e+30]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:606
msgid "Common table expressions"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:608
msgid ""
"By putting ``WITH`` + ``SELECT`` in front of a ``SELECT``, we can make a "
"sort of temporary view that lasts for the duration of the statement."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:612
msgid "Here we'll select from the sort of temporary view."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:614
msgid ""
"WITH cte AS (\n"
"             SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE column4\n"
"             >= 0)\n"
"SELECT * FROM cte;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:621
msgid "Result: the same as the result we got with ``CREATE VIEW`` earlier:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:631
msgid "VALUES"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:633
msgid ""
"Tarantool can handle statements like ``SELECT 55;`` (select without "
"``FROM``) like some other popular DBMSs. But it also handles the more "
"standard statement ``VALUES (expression [, expression ...]);``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:638
msgid "Here we'll use both styles."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:640
msgid ""
"SELECT 55 * 55, 'The rain in Spain';\n"
"VALUES (55 * 55, 'The rain in Spain');"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:645
#, fuzzy
msgid "The result of either statement will be:"
msgstr "Получим следующий результат:"

#: ../doc/tutorials/sql_tutorial.rst:647
msgid "- - [3025, 'The rain in Spain']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:653
msgid "Metadata"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:655
msgid "What database objects have we created? We can find out about:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:657
msgid "tables with ``SELECT * FROM \"_space\";``"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:658
msgid "indexes with ``SELECT * FROM \"_index\";``"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:659
msgid ""
"triggers with ``SELECT * FROM \"_trigger\";`` (These names will be familiar "
"to old Tarantool users because we're actually selecting from NoSQL \"system "
"spaces\".)"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:663
msgid "Here we will select from ``_space``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:665
msgid ""
"SELECT \"id\", \"name\", \"owner\", \"engine\" FROM \"_space\" WHERE \"name"
"\"='TABLE3';"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:669
msgid ""
"The result is (we know we will get a row because we created ``table3`` "
"earlier):"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:671
msgid "- - [517, 'table3', 1, 'memtx']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:679
msgid "Calling from a host language to make a big table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:683
msgid "box.execute()"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:685
msgid ""
"Now we will change the settings so that the console accepts statements "
"written in Lua instead of statements written in SQL. (More ways to switch "
"languages will exist in Tarantool clients in our next version.)"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:690
msgid ""
"This doesn't mean we have left the SQL world though, because we can invoke "
"SQL statements using a Lua function: ``box.execute(string)``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:694
msgid ""
"Here we'll switch languages, and ask to select again what's in ``table3``. "
"These statements must be entered separately."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:698
msgid ""
"tarantool> \\set language lua\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:703
msgid "Showing both the statements and the results:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:705
msgid ""
"tarantool> \\set language lua\n"
"---\n"
"...\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);\n"
"---\n"
"- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']\n"
"..."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:721
msgid "Create a million-row table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:723
msgid ""
"We've illustrated a lot of SQL, but does it scale? To answer that, let's "
"make a bigger table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:726
msgid ""
"For this we are going to use Lua. We will not explain the Lua, because "
"that's in the Lua section of the Tarantool manual. Just copy-and-paste these "
"instructions and wait for about a minute."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:731
#, fuzzy
msgid ""
"box.execute(\"CREATE TABLE tester (s1 INT PRIMARY KEY, s2 VARCHAR(10))\");\n"
"\n"
"function string_function()\n"
"   local random_number\n"
"   local random_string\n"
"   random_string = \"\"\n"
"   for x = 1,10,1 do\n"
"     random_number = math.random(65, 90)\n"
"     random_string = random_string .. string.char(random_number)\n"
"   end\n"
"   return random_string\n"
"end;\n"
"\n"
"function main_function()\n"
"   local string_value, t, sql_statement\n"
"   for i = 1,1000000,1 do\n"
"     string_value = string_function()\n"
"     sql_statement = \"INSERT INTO tester VALUES (\" .. i .. \",'\" .. "
"string_value .. \"')\"\n"
"     box.execute(sql_statement)\n"
"   end\n"
"end;\n"
"start_time = os.clock();\n"
"main_function();\n"
"end_time = os.clock();\n"
"'insert done in ' .. end_time - start_time .. ' seconds';"
msgstr ""
"function string_function()\n"
"           local random_number\n"
"           local random_string\n"
"           random_string = \"\"\n"
"           for x = 1,10,1 do\n"
"             random_number = math.random(65, 90)\n"
"             random_string = random_string .. string.char(random_number)\n"
"           end\n"
"           return random_string\n"
"         end\n"
"         \n"
"         function main_function()\n"
"           local string_value, t\n"
"           for i = 1,1000000,1 do\n"
"             string_value = string_function()\n"
"             t = box.tuple.new({i,string_value})\n"
"             box.space.tester:replace(t)\n"
"           end\n"
"         end\n"
"         start_time = os.clock()\n"
"         main_function()\n"
"         end_time = os.clock()\n"
"         'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/tutorials/sql_tutorial.rst:759
msgid ""
"The result is: you now have a table with a million rows, with a message "
"saying \"``insert done in 88.570578 seconds``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:764
msgid "Select from a million-row table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:766
msgid ""
"Now that we have something a bit larger to play with, let's see how long it "
"takes to SELECT."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:769
msgid ""
"The first query we'll do will automatically go via an index, because ``s1`` "
"is the primary key."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:772
msgid ""
"The second query we'll do will not go via an index, because for ``s2`` we "
"didn't say ``CREATE INDEX xxxx ON tester (s2);``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:776
msgid ""
"box.execute([[SELECT * FROM tester WHERE s1 = 73446;]]);\n"
"box.execute([[SELECT * FROM tester WHERE s2 LIKE 'QFML%';]]);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:783
msgid "the first statement will finish instantaneously,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:784
msgid ""
"the second statement will be noticeably slower but still a fraction of a "
"second."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:789
msgid "Cleanup and exit"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:791
msgid ""
"We're done. We've shown that Tarantool 2.1 has a very reasonable subset of "
"SQL, and it works."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:794
msgid ""
"The rest of these commands will simply destroy all the database objects that "
"were created so that you can do the demonstration again. These statements "
"must be entered separately."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:799
msgid ""
"tarantool> \\set language sql\n"
"tarantool> DROP TABLE tester;\n"
"tarantool> DROP TABLE table1;\n"
"tarantool> DROP VIEW v3;\n"
"tarantool> DROP TRIGGER tr;\n"
"tarantool> DROP TABLE table5;\n"
"tarantool> DROP TABLE table4;\n"
"tarantool> DROP TABLE table3;\n"
"tarantool> DROP TABLE table2;\n"
"tarantool> DROP TABLE t6;\n"
"tarantool> \\set language lua\n"
"tarantool> os.exit();"
msgstr ""
