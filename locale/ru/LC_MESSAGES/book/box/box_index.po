# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:10+0000\n"
"PO-Revision-Date: 2019-12-06 16:11+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"Generated-By: Babel 2.7.0\n"
"X-Generator: Poedit 2.2.4\n"

#: ../doc/book/box/box_index.rst:5
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/book/box/box_index.rst:9
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/book/box/box_index.rst:11
msgid ""
"The ``box.index`` submodule provides read-only access for index definitions "
"and index keys. Indexes are contained in :samp:`box.space.{space-name}."
"index` array within each space object. They provide an API for ordered "
"iteration over tuples. This API is a direct binding to corresponding methods "
"of index objects of type ``box.index`` in the storage engine."
msgstr ""
"Вложенный модуль ``box.index`` обеспечивает доступ к схемам индекса и ключам "
"индекса в режиме только для чтения. Индексы хранятся в массиве :samp:`box."
"space.{имя-спейса}.index` в каждом спейсе. Они предоставляют API для "
"упорядоченной итерации по кортежам. Этот API представляет собой прямую "
"привязку к соответствующим методам объектов типа``box.index`` в движке базы "
"данных."

#: ../doc/book/box/box_index.rst:19
msgid "Index"
msgstr "Индекс"

#: ../doc/book/box/box_index.rst:21
msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.index``."

#: ../doc/book/box/box_index.rst:29
msgid "Name"
msgstr "Имя"

#: ../doc/book/box/box_index.rst:29
msgid "Use"
msgstr "Использование"

#: ../doc/book/box/box_index.rst:31
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ":ref:`index_object.unique <box_index-unique>`"

#: ../doc/book/box/box_index.rst:31
msgid "Flag, true if an index is unique"
msgstr "Флаг, если индекс уникальный -- true"

#: ../doc/book/box/box_index.rst:34
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`index_object.type <box_index-type>`"

#: ../doc/book/box/box_index.rst:34
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/book/box/box_index.rst:37
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`index_object.parts <box_index-parts>`"

#: ../doc/book/box/box_index.rst:37
msgid "Array of index key fields"
msgstr "Массив полей с ключами индекса"

#: ../doc/book/box/box_index.rst:40
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`index_object:pairs() <box_index-index_pairs>`"

#: ../doc/book/box/box_index.rst:40
msgid "Prepare for iterating"
msgstr "Подготовка к итерации"

#: ../doc/book/box/box_index.rst:43
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`index_object:select() <box_index-select>`"

#: ../doc/book/box/box_index.rst:43
msgid "Select one or more tuples via index"
msgstr "Выбор одного или более кортежей по индексу"

#: ../doc/book/box/box_index.rst:46
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`index_object:get() <box_index-get>`"

#: ../doc/book/box/box_index.rst:46
msgid "Select a tuple via index"
msgstr "Выбор кортежа по индексу"

#: ../doc/book/box/box_index.rst:49
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`index_object:min() <box_index-min>`"

#: ../doc/book/box/box_index.rst:49
msgid "Find the minimum value in index"
msgstr "Поиск минимального значения в индексе"

#: ../doc/book/box/box_index.rst:52
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`index_object:max() <box_index-max>`"

#: ../doc/book/box/box_index.rst:52
msgid "Find the maximum value in index"
msgstr "Поиск максимального значения в индексе"

#: ../doc/book/box/box_index.rst:55
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`index_object:random() <box_index-random>`"

#: ../doc/book/box/box_index.rst:55
msgid "Find a random value in index"
msgstr "Поиск случайного значения в индексе"

#: ../doc/book/box/box_index.rst:58
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`index_object:count() <box_index-count>`"

#: ../doc/book/box/box_index.rst:58
msgid "Count tuples matching key value"
msgstr "Подсчет кортежей с совпадающим значением ключа"

#: ../doc/book/box/box_index.rst:61
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`index_object:update() <box_index-update>`"

#: ../doc/book/box/box_index.rst:61
msgid "Update a tuple"
msgstr "Обновление кортежа"

#: ../doc/book/box/box_index.rst:64
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`index_object:delete() <box_index-delete>`"

#: ../doc/book/box/box_index.rst:64
msgid "Delete a tuple by key"
msgstr "Удаление кортежа по ключу"

#: ../doc/book/box/box_index.rst:67
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`index_object:alter() <box_index-alter>`"

#: ../doc/book/box/box_index.rst:67
msgid "Alter an index"
msgstr "Изменение индекса"

#: ../doc/book/box/box_index.rst:70
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`index_object:drop() <box_index-drop>`"

#: ../doc/book/box/box_index.rst:70
msgid "Drop an index"
msgstr "Удаление индекса"

#: ../doc/book/box/box_index.rst:73
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`index_object:rename() <box_index-rename>`"

#: ../doc/book/box/box_index.rst:73
msgid "Rename an index"
msgstr "Переименование индекса"

#: ../doc/book/box/box_index.rst:76
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`index_object:bsize() <box_index-bsize>`"

#: ../doc/book/box/box_index.rst:76
msgid "Get count of bytes for an index"
msgstr "Подсчет байтов для индекса"

#: ../doc/book/box/box_index.rst:79
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ":ref:`index_object:stat() <box_index-stat>`"

#: ../doc/book/box/box_index.rst:79
msgid "Get statistics for an index"
msgstr "Получение статистических данных по индексу"

#: ../doc/book/box/box_index.rst:82
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ":ref:`index_object:compact() <box_index-compact>`"

#: ../doc/book/box/box_index.rst:82
msgid "Remove unused index space"
msgstr "Удаление неиспользуемого пространства индекса"

#: ../doc/book/box/box_index.rst:85
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ":ref:`index_object:user_defined() <box_index-user_defined>`"

#: ../doc/book/box/box_index.rst:85
msgid "Any function / method that any user wants to add"
msgstr "Любая функция / метод, которые хочет добавить любой пользователь"

#: ../doc/book/box/box_index.rst:98
msgid "True if the index is unique, false if the index is not unique."
msgstr "Если индекс уникальный -- true, если индекс не уникален -- false."

#: ../doc/book/box/box_index.rst:0
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/book/box/box_index.rst:100
msgid "boolean"
msgstr "boolean (логический)"

#: ../doc/book/box/box_index.rst:106
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr "Тип индекса: 'TREE' или 'HASH' или 'BITSET' или 'RTREE'."

#: ../doc/book/box/box_index.rst:112
msgid ""
"An array describing the index fields. To learn more about the index field "
"types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""
"Массив, описывающий поля индекса. Чтобы узнать больше о типах полей индекса, "
"обращайтесь к :ref:`этой таблице <box_space-index_field_types>`."

#: ../doc/book/box/box_index.rst:115 ../doc/book/box/box_index.rst:943
msgid "table"
msgstr "таблица"

#: ../doc/book/box/box_index.rst:117 ../doc/book/box/box_index.rst:503
#: ../doc/book/box/box_index.rst:643 ../doc/book/box/box_index.rst:673
#: ../doc/book/box/box_index.rst:703 ../doc/book/box/box_index.rst:732
#: ../doc/book/box/box_index.rst:756 ../doc/book/box/box_index.rst:839
#: ../doc/book/box/box_index.rst:869 ../doc/book/box/box_index.rst:891
#: ../doc/book/box/box_index.rst:989 ../doc/book/box/box_index.rst:1002
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/book/box/box_index.rst:119
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."

#: ../doc/book/box/box_index.rst:138
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей по заданному индексу и итерация по одному "
"кортежу за раз."

#: ../doc/book/box/box_index.rst:141
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""
"Параметр :samp:`{key}` (ключ) задает, что именно должно совпадать в индексе."

#: ../doc/book/box/box_index.rst:145
msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""
":samp:`{key}` используется в поиске только первого совпадения. Не стоит "
"ожидать, что все подобранные кортежи будут содержать этот ключ."

#: ../doc/book/box/box_index.rst:148
msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example, a "
"TREE index maintains a strict order of keys and can return all tuples in "
"ascending or descending order, starting from the specified key. Other index "
"types, however, do not support ordering."
msgstr ""
"Параметр :samp:`{iterator}` (итератор) задает правило для совпадений и "
"упорядочивания. Различные типы индексов поддерживают различные итераторы. "
"Например, TREE-индекс поддерживает строгий порядок ключей и может вернуть "
"все кортежи в порядке по возрастанию или по убыванию, начиная с указанного "
"ключа. Однако другие типы индексов не поддерживают упорядочивание."

#: ../doc/book/box/box_index.rst:154
msgid ""
"To understand consistency of tuples returned by an iterator, it's essential "
"to know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there "
"is a \"context switch\": which may happen due to :ref:`the implicit yield "
"rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield "
"<fiber-yield>`. When the execution flow returns to the yielded procedure, "
"the data set could have changed significantly. Iteration, resumed after a "
"yield point, does not preserve the read view, but continues with the new "
"content of the database. The tutorial :ref:`Indexed pattern search "
"<c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and "
"yields can be used together."
msgstr ""
"Чтобы понять логику возврата кортежей с помощью итератора, важно знать "
"принципы работы подсистемы обработки транзакций в Tarantool'е. В итераторе "
"Tarantool'а нет собственного постоянного вида просмотра. Наоборот, каждая "
"процедура получает эксклюзивный доступ ко всем кортежам и спейсам до тех "
"пор, пока не \"переключится контекст\", что может произойти по причине :ref:"
"`неявной передачи управления <atomic-implicit-yields>` или в результате "
"явного вызова функции :ref:`fiber.yield <fiber-yield>`. Когда поток "
"выполнения возвращается к процедуре, передавшей управление, набор данных "
"может уже значительно измениться. Итерация возобновляется после стадии "
"передачи управления и не сохраняет вид просмотра, а продолжает работу с "
"новым содержимым базы данных. В практическом задании :ref:`\"Индексированный "
"поиск по шаблонам\" <c_lua_tutorial-indexed_pattern_search>` демонстрируется "
"один из способов одновременного использования итераторов и передачи "
"управления."

#: ../doc/book/box/box_index.rst:168
msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. документацию "
"по библиотеке для функционального программирования в Lua `\"Lua Functional "
"library\" <https://luafun.github.io/index.html>`_."

#: ../doc/book/box/box_index.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../doc/book/box/box_index.rst:172 ../doc/book/box/box_index.rst:492
#: ../doc/book/box/box_index.rst:627 ../doc/book/box/box_index.rst:658
#: ../doc/book/box/box_index.rst:688 ../doc/book/box/box_index.rst:721
#: ../doc/book/box/box_index.rst:748 ../doc/book/box/box_index.rst:779
#: ../doc/book/box/box_index.rst:802 ../doc/book/box/box_index.rst:823
#: ../doc/book/box/box_index.rst:858 ../doc/book/box/box_index.rst:883
#: ../doc/book/box/box_index.rst:907 ../doc/book/box/box_index.rst:939
#: ../doc/book/box/box_index.rst:985
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

#: ../doc/book/box/box_index.rst:174
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""
"значение должно совпасть с индексным ключом, который может быть составным"

#: ../doc/book/box/box_index.rst:176
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""
"как определено в таблицах ниже. По умолчанию используется итератор 'EQ'"

#: ../doc/book/box/box_index.rst:0
msgid "return"
msgstr "возвращается"

#: ../doc/book/box/box_index.rst:180
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/"
"end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing."
"html#fun.totable>`_"
msgstr ""
"`итератор <https://www.lua.org/pil/7.1.html>`_, который может использовать в "
"цикле for/end или с функцией `totable() <https://rtsisyk.github.io/luafun/"
"reducing.html#fun.totable>`_"

#: ../doc/book/box/box_index.rst:184 ../doc/book/box/box_index.rst:634
#: ../doc/book/box/box_index.rst:831 ../doc/book/box/box_index.rst:863
msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

#: ../doc/book/box/box_index.rst:186
msgid "no such space; wrong type;"
msgstr "спейс отсутствует; неправильный тип;"

#: ../doc/book/box/box_index.rst:187
msgid "selected iteration type is not supported for the index type;"
msgstr "выбранный тип итерации не поддерживается для данного типа индекса;"

#: ../doc/book/box/box_index.rst:188
msgid "key is not supported for the iteration type."
msgstr "ключ не поддерживается для данного типа итерации."

#: ../doc/book/box/box_index.rst:190
msgid ""
"**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса; количество кортежей, к "
"которым получен доступ."

#: ../doc/book/box/box_index.rst:193
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example ``{1234, "
"'abcd'}``). Each part of a key will be compared to each part of an index key."
msgstr ""
"Значение искомого ключа может представлять собой число (например, ``1234``), "
"строку (например, ``'abcd'``) или таблицу из чисел и строк (например, "
"``{1234, 'abcd'}``). Каждая часть ключа будет сопоставляться с каждой частью "
"ключа в индексе."

#: ../doc/book/box/box_index.rst:198
msgid ""
"The returned tuples will be in order by index key value, or by the hash of "
"the index key value if index type = 'hash'. If the index is non-unique, then "
"duplicates will be secondarily in order by primary key value. The order will "
"be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""
"Найденные кортежи будут упорядочены по значению ключа в индексе или по хешу "
"значения ключа, если тип индекса -- 'hash'. Если индекс не уникален, то "
"дубликаты будут упорядочены во вторую очередь по первичному значению ключа. "
"Порядок будет обратным, если тип итератора -- 'LT', 'LE' или 'REQ'."

#: ../doc/book/box/box_index.rst:205
msgid "**Iterator types for TREE indexes**"
msgstr "**Типы итераторов для TREE-индексов**"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
msgid "Type"
msgstr "Type"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
msgid "Arguments"
msgstr "Аргументы"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
msgid "Description"
msgstr "Описание"

#: ../doc/book/box/box_index.rst:218 ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:357 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.EQ or 'EQ'"
msgstr "box.index.EQ или 'EQ'"

#: ../doc/book/box/box_index.rst:218 ../doc/book/box/box_index.rst:224
#: ../doc/book/box/box_index.rst:229 ../doc/book/box/box_index.rst:236
#: ../doc/book/box/box_index.rst:243 ../doc/book/box/box_index.rst:247
#: ../doc/book/box/box_index.rst:253 ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:328 ../doc/book/box/box_index_rtree.csv:1
msgid "search value"
msgstr "искомое значение"

#: ../doc/book/box/box_index.rst:218
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. Tuples are returned in ascending order by index "
"key. This is the default."
msgstr ""
"Оператором сравнения будет '==' (равно). Если ключ индекса равен искомому "
"значению, получим совпадение. Найденные кортежи упорядочены по возрастанию "
"по ключу индекса. Этот тип используется по умолчанию."

#: ../doc/book/box/box_index.rst:224
msgid "box.index.REQ or 'REQ'"
msgstr "box.index.REQ или 'REQ'"

#: ../doc/book/box/box_index.rst:224
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""
"Совпадения находятся таким же образом, что и для ``box.index.EQ``. Разница "
"только в том, что найденные кортежи упорядочены по ключу индекса по "
"убыванию, а не по возрастанию."

#: ../doc/book/box/box_index.rst:229 ../doc/book/box/box_index.rst:328
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GT or 'GT'"
msgstr "box.index.GT или 'GT'"

#: ../doc/book/box/box_index.rst:229
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater "
"than a search value, it matches. Tuples are returned in ascending order by "
"index key."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если ключ индекса больше, чем "
"искомое значение, получим совпадение. Найденные кортежи упорядочены по "
"возрастанию по ключу индекса."

#: ../doc/book/box/box_index.rst:236 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GE or 'GE'"
msgstr "box.index.GE или 'GE'"

#: ../doc/book/box/box_index.rst:236
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key "
"is greater than or equal to a search value, it matches. Tuples are returned "
"in ascending order by index key."
msgstr ""
"Оператором сравнения будет '>=' (больше или равен). Если ключ индекса больше "
"искомого значения или равен ему, получим совпадение. Найденные кортежи "
"упорядочены по возрастанию по ключу индекса."

#: ../doc/book/box/box_index.rst:243 ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.ALL or 'ALL'"
msgstr "box.index.ALL или 'ALL'"

#: ../doc/book/box/box_index.rst:243
msgid "Same as box.index.GE."
msgstr "Как для box.index.GE."

#: ../doc/book/box/box_index.rst:247 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LT or 'LT'"
msgstr "box.index.LT или 'LT'"

#: ../doc/book/box/box_index.rst:247
msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index "
"key."
msgstr ""
"Оператором сравнения будет  '<' (меньше чем). Если ключ индекса меньше "
"искомого значения, получим совпадение. Найденные кортежи упорядочены по "
"убыванию по ключу индекса."

#: ../doc/book/box/box_index.rst:253 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LE or 'LE'"
msgstr "box.index.LE или 'LE'"

#: ../doc/book/box/box_index.rst:253
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is "
"less than or equal to a search value, it matches. Tuples are returned in "
"descending order by index key."
msgstr ""
"Оператором сравнения будет '<=' (меньше или равен). Если ключ индекса меньше "
"искомого значения или равен ему, получим совпадение. Найденные кортежи "
"упорядочены по убыванию по ключу индекса."

#: ../doc/book/box/box_index.rst:261
msgid ""
"Informally, we can state that searches with TREE indexes are generally what "
"users will find is intuitive, provided that there are no nils and no missing "
"parts. Formally, the logic is as follows. A search key has zero or more "
"parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more "
"parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but "
"not msgpack.NULL, which is the wrong type). An index key may not contain nil "
"or msgpack.NULL, although a later version of Tarantool will have different "
"rules --  the behavior of searches with nil is subject to change. Possible "
"iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an "
"index key if the following statements, which are pseudocode for the "
"comparison operation, return TRUE."
msgstr ""
"Неофициально можно сказать, что поиск с помощью TREE-индексов пользователи "
"обычно считают интуитивно понятным при условии, что нет нулевых значений и "
"отсутствующих частей. Формально же логика заключается в следующем. Ключ "
"поиска состоит из нуля или более частей, например, {}, {1,2,3},{1,nil,3}. "
"Ключ индекса состоит из одной или более частей, например, {1}, {1,2,3},"
"{1,2,3}. Ключ поиска может содержать нулевое значение nil (но не msgpack."
"NULL, этот тип не будет правильным). Ключ индекса не может содержать nil или "
"msgpack.NULL, хотя в последующих версиях правила работы Tarantool'а будут "
"другие -- поведение поиска с nil может измениться. Возможные итераторы: LT, "
"LE, EQ, REQ, GE, GT. Считается, что ключ поиска соответствует ключу индекса, "
"если следующие операторы, которые представляют собой псевдокод для операции "
"сопоставления, возвращают TRUE."

#: ../doc/book/box/box_index.rst:311
msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-"
"part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-"
"part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"

#: ../doc/book/box/box_index.rst:306
msgid "**Iterator types for HASH indexes**"
msgstr "**Типы итераторов для HASH-индексов**"

#: ../doc/book/box/box_index.rst:317
msgid "box.index.ALL"
msgstr "box.index.ALL"

#: ../doc/book/box/box_index.rst:317 ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "none"
msgstr "нет"

#: ../doc/book/box/box_index.rst:317
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по "
"возрастанию по хешу ключа индекса, который будет выглядеть случайным."

#: ../doc/book/box/box_index.rst:322
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. The number of returned tuples will be 0 or 1. This "
"is the default."
msgstr ""
"Оператором сравнения будет '==' (равный). Если ключ индекса равен искомому "
"значению, получим совпадение. Количество найденных кортежей будет 0 или 1. "
"Этот тип используется по умолчанию."

#: ../doc/book/box/box_index.rst:328
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. "
"Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in "
"each search, and using the last returned value from the previous result as "
"the start search value for the next search."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если хеш ключа индекса больше, "
"чем хеш искомого значения, получим совпадение. Найденные кортежи упорядочены "
"по возрастанию по хешу ключа индекса, который будет выглядеть случайным. При "
"условии, что спейс не обновляется, можно получить все кортежи в спейсе, N "
"кортежей за раз, используя  {iterator='GT', limit=N} в каждом поиске и "
"последнее найденное значение из предыдущего результата поиска в качестве "
"начального значения для следующего поиска."

#: ../doc/book/box/box_index.rst:342
msgid "**Iterator types for BITSET indexes**"
msgstr "**Типы итераторов для BITSET-индексов**"

#: ../doc/book/box/box_index.rst:353
msgid ""
"All index keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/book/box/box_index.rst:357 ../doc/book/box/box_index.rst:362
#: ../doc/book/box/box_index.rst:367 ../doc/book/box/box_index.rst:372
msgid "bitset value"
msgstr "значение bitset (битовое множество)"

#: ../doc/book/box/box_index.rst:357
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned "
"in their order within the space. This is the default."
msgstr ""
"Если ключ индекса равен искомому значению, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе. Этот тип используется по "
"умолчанию."

#: ../doc/book/box/box_index.rst:362
msgid "box.index.BITS_ALL_SET"
msgstr "box.index.BITS_ALL_SET"

#: ../doc/book/box/box_index.rst:362
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, также равны 1 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в "
"спейсе."

#: ../doc/book/box/box_index.rst:367
msgid "box.index.BITS_ANY_SET"
msgstr "box.index.BITS_ANY_SET"

#: ../doc/book/box/box_index.rst:367
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если один из битов, которые равны 1 в битовом множестве, также равен 1 в "
"ключе индекса, получим совпадение. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/book/box/box_index.rst:372
msgid "box.index.BITS_ALL_NOT_SET"
msgstr "box.index.BITS_ALL_NOT_SET"

#: ../doc/book/box/box_index.rst:372
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, равны 0 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в "
"спейсе."

#: ../doc/book/box/box_index.rst:380
msgid "**Iterator types for RTREE indexes**"
msgstr "**Типы итераторов для RTREE-индексов**"

#: ../doc/book/box/box_index_rtree.csv:1
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи являются совпадениями. Найденные кортежи упорядочены по положению "
"в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are the "
"same as the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space. \"Rectangle-or-box\" means "
"\"rectangle-or-box as explained in section about :ref:`RTREE <box_index-"
"rtree>`\". This is the default."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, совпадают с точками прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе. \"Прямоугольник-или-параллелепипед\" "
"означает \"прямоугольник-или-параллелепипед, как описано в разделе о :ref:"
"`RTREE <box_index-rtree>`\". Этот тип используется по умолчанию."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, или рядом с ним, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are within "
"the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are within, "
"or at the side of, the rectangle-or-box defined by the search key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr "box.index.OVERLAPS или 'OVERLAPS'"

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"искомым значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr "box.index.NEIGHBOR или 'NEIGHBOR'"

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"ключом, находятся в пределах, определенных ключом индекса, или рядом с ним, "
"получим совпадение. Найденные кортежи упорядочены следующим образом: сначала "
"ближайший сосед."

#: ../doc/book/box/box_index.rst:394
msgid "**First example of index pairs():**"
msgstr "**Первый пример pairs():**"

#: ../doc/book/box/box_index.rst:396
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr "'TREE'-индекс, используемый по умолчанию, и функция ``pairs()``:"

#: ../doc/book/box/box_index.rst:398
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:444
msgid "**Second example of index pairs():**"
msgstr "**Второй пример pairs():**"

#: ../doc/book/box/box_index.rst:446
msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. "
"The assumptions include that there is a one-part primary-key TREE index on "
"the first field, which must be a string. The iterator loop ensures that the "
"search will return tuples where the first value is greater than or equal to "
"'XY'. The conditional statement within the loop ensures that the looping "
"will stop when the first two letters are not 'XY'."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа в которых "
"начинаются с 'XY'. Рабочие предположения заключаются в следующем: есть "
"однокомпонентный первичный TREE-индекс по первому полю, которое должно "
"представлять собой строку. Цикл с итератором обеспечивает поиск кортежей, в "
"которых первое значение больше или равно 'XY'. Условный оператор в цикле "
"служит для того, чтобы цикл останавливался, если первые две буквы не 'XY'."

#: ../doc/book/box/box_index.rst:454
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/book/box/box_index.rst:462
msgid "**Third example of index pairs():**"
msgstr "**Третий пример pairs():**"

#: ../doc/book/box/box_index.rst:464
msgid ""
"This Lua code finds all the tuples whose primary key values are greater than "
"or equal to 1000, and less than or equal to 1999 (this type of request is "
"sometimes called a \"range search\" or a \"between search\"). The "
"assumptions include that there is a one-part primary-key TREE index on the "
"first field, which must be a :ref:`number <index-box_number>`. The iterator "
"loop ensures that the search will return tuples where the first value is "
"greater than or equal to 1000. The conditional statement within the loop "
"ensures that the looping will stop when the first value is greater than 1999."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа которых "
"равны или больше 1000 и меньше или равны 1999 (такой тип запроса иногда "
"называют поиском по диапазону или поиском в заданных пределах). Рабочие "
"предположения заключаются в следующем: есть однокомпонентный первичный TREE-"
"индекс по первому полю, которое должно представлять собой :ref:`число <index-"
"box_number>`. Цикл с итератором обеспечивает поиск кортежей, в которых "
"первое значение больше или равно 1000. Условный оператор в цикле служит для "
"того, чтобы цикл останавливался, если первое значение больше 1999."

#: ../doc/book/box/box_index.rst:474
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/book/box/box_index.rst:486
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional parameters "
"that specify the iterator type, and the limit (that is, the maximum number "
"of tuples to return) and the offset (that is, which tuple to start with in "
"the list)."
msgstr ""
"Это может быть альтернативой для функции :ref:`box.space...select() "
"<box_space-select>`, которая проходит по определенному индексу и может "
"использовать дополнительные параметры, которые определяют тип итератора и "
"пределы (то есть максимальное количество возвращаемых кортежей) и смещение "
"(то есть с какого кортежа в списке начинать)."

#: ../doc/book/box/box_index.rst:494 ../doc/book/box/box_index.rst:629
#: ../doc/book/box/box_index.rst:660 ../doc/book/box/box_index.rst:690
#: ../doc/book/box/box_index.rst:750 ../doc/book/box/box_index.rst:781
#: ../doc/book/box/box_index.rst:804
msgid "values to be matched against the index key"
msgstr "значения для сопоставления с ключом индекса"

#: ../doc/book/box/box_index.rst:495
msgid "none, any or all of next parameters"
msgstr "ни один, любой или все следующие параметры"

#: ../doc/book/box/box_index.rst:496
msgid "type of iterator"
msgstr "тип итератора"

#: ../doc/book/box/box_index.rst:497
msgid "maximum number of tuples"
msgstr "максимальное количество кортежей"

#: ../doc/book/box/box_index.rst:498
msgid "start tuple number"
msgstr "номер начального кортежа"

#: ../doc/book/box/box_index.rst:500
msgid "the tuple or tuples that match the field values."
msgstr "кортеж или кортежи, которые совпадают со значениями поля."

#: ../doc/book/box/box_index.rst:501
msgid "array of tuples"
msgstr "массив кортежей"

#: ../doc/book/box/box_index.rst:505
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""
"-- Создать спейс под названием tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Создать уникальный индекс 'primary'\n"
"-- который не будет нужен для данного примера..\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Создать неуникальный индекс 'secondary'\n"
"-- по второму полю.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Вставить три кортежа, значения в поле2 field[2]\n"
"-- равны 'X', 'Y' и 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Выбрать все кортежи, где вторичные ключи\n"
"-- больше, чем 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"

#: ../doc/book/box/box_index.rst:531
msgid "The result will be a table of tuple and will look like this:"
msgstr "Результатом будет следующая таблица кортежа:"

#: ../doc/book/box/box_index.rst:533
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."

#: ../doc/book/box/box_index.rst:542
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed "
"index is the first (primary-key) index. Therefore, for the example above, "
"``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the "
"same two rows, via the 'primary' index."
msgstr ""
"Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
"подразумевается первый индекс (первичный ключ). Таким образом, для примера "
"выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет две "
"одинаковых строки по первичному индексу 'primary'."

#: ../doc/book/box/box_index.rst:549
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""
"Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
"Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."

#: ../doc/book/box/box_index.rst:554
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, "
"then every key in the index is considered to be a match, regardless of "
"iterator type. Therefore, for the example above, ``box.space.tester:select{}"
"`` will select every tuple in the tester space via the first (primary-key) "
"index."
msgstr ""
"Параметр :samp:`{field-value} [, {значение поля ...}]` необязателен. Если он "
"пропущен, то каждый ключ в индексе будет считаться совпадением независимо от "
"типа итератора. Таким образом, для примера выше, ``box.space.tester:select{}"
"`` выберет каждый кортеж в спейсе tester по первому индексу (первичный ключ)."

#: ../doc/book/box/box_index.rst:564
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That "
"is, ``get`` can be used as a convenient shorthand to get the first tuple in "
"the tuple set that would be returned by ``select``. However, if there is "
"more than one tuple in the tuple set, then ``get`` throws an error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]`` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа, "
"``get`` завершится с ошибкой."

#: ../doc/book/box/box_index.rst:572
msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

#: ../doc/book/box/box_index.rst:574
msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: "
"bit values are entered as hexadecimal literals for easier reading."
msgstr ""
"Следующий скрипт показывает создание BITSET-индекса и поиск по нему. "
"Обратите внимание, что битовое множество BITSET не может быть уникальным, "
"поэтому сначала создается первичный индекс. Обратите внимание, что битовые "
"значения вводятся как шестнадцатеричные литералы для удобства чтения."

#: ../doc/book/box/box_index.rst:578
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

#: ../doc/book/box/box_index.rst:625
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""
"Поиск кортежа по заданному индексу, как описано :ref:`выше <box_index-note>`."

#: ../doc/book/box/box_index.rst:631
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""
"кортеж, в котором поля ключа в индексе равны переданным значениям ключа."

#: ../doc/book/box/box_index.rst:632 ../doc/book/box/box_index.rst:667
#: ../doc/book/box/box_index.rst:697 ../doc/book/box/box_index.rst:726
#: ../doc/book/box/box_index.rst:790 ../doc/book/box/box_index.rst:807
msgid "tuple"
msgstr "кортеж"

#: ../doc/book/box/box_index.rst:636
msgid "no such index;"
msgstr "отсутствие такого индекса;"

#: ../doc/book/box/box_index.rst:637
msgid "wrong type;"
msgstr "неправильный тип;"

#: ../doc/book/box/box_index.rst:638
msgid "more than one tuple matches."
msgstr "больше одного кортежа подходят."

#: ../doc/book/box/box_index.rst:640
msgid ""
"**Complexity factors:** Index size, Index type. See also :ref:`space_object:"
"get() <box_space-get>`."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса. См. также :ref:"
"`space_object:get() <box_space-get>`."

#: ../doc/book/box/box_index.rst:645
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."

#: ../doc/book/box/box_index.rst:656
msgid "Find the minimum value in the specified index."
msgstr "Поиск минимального значения в указанном индексе."

#: ../doc/book/box/box_index.rst:662
msgid ""
"the tuple for the first key in the index. If optional ``key`` value is "
"supplied, returns the first key which is greater than or equal to ``key`` "
"value. In a future version of Tarantool, index:min(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для первого ключа в индексе. Если указано необязательное значение "
"ключа ``key``, будет выведен первый ключ, который больше или равен значению "
"ключа ``key``. В будущей версии Tarantool'а index:min(значение ``key``) не "
"вернет ничего, если значение ``key`` не равно значению в индексе."

#: ../doc/book/box/box_index.rst:669 ../doc/book/box/box_index.rst:699
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** тип индекса не 'TREE'."

#: ../doc/book/box/box_index.rst:671 ../doc/book/box/box_index.rst:701
#: ../doc/book/box/box_index.rst:728
msgid "**Complexity factors:** Index size, Index type."
msgstr "**Факторы сложности:** Размер индекса, тип индекса."

#: ../doc/book/box/box_index.rst:675
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:686
msgid "Find the maximum value in the specified index."
msgstr "Поиск максимального значения в указанном индексе."

#: ../doc/book/box/box_index.rst:692
msgid ""
"the tuple for the last key in the index. If optional ``key`` value is "
"supplied, returns the last key which is less than or equal to ``key`` value. "
"In a future version of Tarantool, index:max(``key`` value) will return "
"nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для последнего ключа в индексе. Если указано необязательное значение "
"ключа ``key``, будет выведен последний ключ, который меньше или равен "
"значению ключа ``key``. В будущей версии Tarantool'а index:max(значение "
"``key``) не вернет ничего, если значение ``key`` не равно значению в индексе."

#: ../doc/book/box/box_index.rst:705
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:716
msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having "
"to iterate over the entire data set."
msgstr ""
"Поиск случайного значения в заданном индексе. Данный метод используется, "
"когда важно получить представление о распределении данных в индексе без "
"необходимости проходить по всему набору данных."

#: ../doc/book/box/box_index.rst:723
msgid "an arbitrary non-negative integer"
msgstr "произвольное неотрицательное целое число"

#: ../doc/book/box/box_index.rst:725
msgid "the tuple for the random key in the index."
msgstr "кортеж для случайного ключа в индексе."

#: ../doc/book/box/box_index.rst:730
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr ""
"**Примечание про движок базы данных:** vinyl не поддерживает ``random()``."

#: ../doc/book/box/box_index.rst:734
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:745
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""
"Итерация по индексу с подсчетом количества кортежей, которые соответствуют "
"паре ключ-значение."

#: ../doc/book/box/box_index.rst:751
msgid "comparison method"
msgstr "метод сопоставления"

#: ../doc/book/box/box_index.rst:753
msgid "the number of matching tuples."
msgstr "количество совпадающих кортежей."

#: ../doc/book/box/box_index.rst:754 ../doc/book/box/box_index.rst:911
msgid "number"
msgstr "число"

#: ../doc/book/box/box_index.rst:758
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."

#: ../doc/book/box/box_index.rst:773
msgid "Update a tuple."
msgstr "Обновление кортежа."

#: ../doc/book/box/box_index.rst:775
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched "
"in this index instead of primary key. This index ought to be unique."
msgstr ""
"То же, что и :ref:`box.space...update() <box_space-update>`, но поиск ключа "
"происходит в этом индексе, вместо первичного. Данный индекс должен быть "
"уникальным."

#: ../doc/book/box/box_index.rst:782
msgid "operation type represented in string"
msgstr "тип операции, представленный строкой"

#: ../doc/book/box/box_index.rst:783
msgid ""
"what field the operation will apply to. The field number can be negative, "
"meaning the position from the end of tuple. (#tuple + negative field number "
"+ 1)"
msgstr ""
"к какому полю применяется операция. Номер поля может быть отрицательным, что "
"означает, что позиция рассчитывается с конца кортежа. (#кортеж + "
"отрицательный номер поля + 1)"

#: ../doc/book/box/box_index.rst:787
msgid "what value will be applied"
msgstr "какое значение применяется"

#: ../doc/book/box/box_index.rst:789
msgid "the updated tuple."
msgstr "обновленный кортеж."

#: ../doc/book/box/box_index.rst:796
msgid "Delete a tuple identified by a key."
msgstr "Удаление кортежа по ключу."

#: ../doc/book/box/box_index.rst:798
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched "
"in this index instead of in the primary-key index. This index ought to be "
"unique."
msgstr ""
"То же, что и :ref:`box.space...delete() <box_space-delete>`, но поиск ключа "
"происходит в этом индексе, вместо первичного. Данный индекс должен быть "
"уникальным."

#: ../doc/book/box/box_index.rst:806
msgid "the deleted tuple."
msgstr "удаленный кортеж."

#: ../doc/book/box/box_index.rst:809
msgid ""
"**Note re storage engine:** vinyl will return `nil`, rather than the deleted "
"tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет `nil`, а не удаленный "
"кортеж."

#: ../doc/book/box/box_index.rst:816
msgid ""
"Alter an index. It is legal in some circumstances to change one or more of "
"the index characteristics, for example its type, its sequence options, its "
"parts, and whether it is unique, Usually this causes rebuilding of the "
"space,  except for the simple case where a part's ``is_nullable`` flag is "
"changed from ``false`` to ``true``."
msgstr ""
"Изменение индекса. В определенных обстоятельствах можно изменять некоторые "
"характеристики индекса, например тип, параметры последовательности и "
"определение его уникальности. Тем не менее, это обычно приводит к "
"перестроению спейса за исключением простого случая, когда значение флага "
"``is_nullable`` меняется с ``false`` на ``true``."

#: ../doc/book/box/box_index.rst:825
msgid ""
"options list, same as the options list for ``create_index``, see the chart "
"named :ref:`Options for space_object:create_index() <box_space-"
"create_index>`."
msgstr ""
"список параметров, аналогичный списку параметров для ``create_index``, см. "
"таблицу под названием :ref:`Параметры для space_object:create_index() "
"<box_space-create_index>`."

#: ../doc/book/box/box_index.rst:829 ../doc/book/box/box_index.rst:887
msgid "nil"
msgstr "nil"

#: ../doc/book/box/box_index.rst:833 ../doc/book/box/box_index.rst:865
msgid "index does not exist,"
msgstr "индекс не существует,"

#: ../doc/book/box/box_index.rst:834
msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""
"индекс по первичному ключу не может быть неуникальным, то есть нельзя задать "
"``{unique = false}``."

#: ../doc/book/box/box_index.rst:836
msgid ""
"**Note re storage engine:** vinyl does not support ``alter()`` of a primary-"
"key index unless the space is empty."
msgstr ""
"**Примечание про движок базы данных:** vinyl не поддерживает ``alter()`` для "
"первичного индекса, если спейс содержит данные."

#: ../doc/book/box/box_index.rst:841
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:855
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples "
"are deleted."
msgstr ""
"Удаление индекса. Побочный эффект удаления первичного индекса -- все кортежи "
"удалятся."

#: ../doc/book/box/box_index.rst:861
msgid "nil."
msgstr "nil."

#: ../doc/book/box/box_index.rst:866
msgid ""
"a primary-key index cannot be dropped while a secondary-key index exists."
msgstr "первичный индекс невозможно удалить, если существует вторичный индекс."

#: ../doc/book/box/box_index.rst:871
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:881
msgid "Rename an index."
msgstr "Переименование индекса."

#: ../doc/book/box/box_index.rst:885
msgid "new name for index"
msgstr "новое имя индекса"

#: ../doc/book/box/box_index.rst:889
msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** index_object не существует."

#: ../doc/book/box/box_index.rst:893
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:899
msgid ""
"**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса, количество кортежей, к "
"которым получен доступ."

#: ../doc/book/box/box_index.rst:905
msgid "Return the total number of bytes taken by the index."
msgstr "Возврат общего количества байтов, занятых индексом."

#: ../doc/book/box/box_index.rst:910
msgid "number of bytes"
msgstr "количество байтов"

#: ../doc/book/box/box_index.rst:917
msgid "Return statistics about actions taken that affect the index."
msgstr ""
"Получение статистики о предпринятых действиях, которые влияют на индекс."

#: ../doc/book/box/box_index.rst:919
msgid "This is for use with the vinyl engine."
msgstr "Используется с движком базы данных vinyl."

#: ../doc/book/box/box_index.rst:921
msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr "Подробные данные в выводе ``index_object:stat()``:"

#: ../doc/book/box/box_index.rst:923
msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr "``index_object:stat().latency`` содержит отметки времени в процентах;"

#: ../doc/book/box/box_index.rst:924
msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr "``index_object:stat().bytes`` содержит общее количество байтов;"

#: ../doc/book/box/box_index.rst:925
msgid ""
"``index_object:stat().disk.rows`` -- the approximate number of tuples in "
"each range;"
msgstr ""
"``index_object:stat().disk.rows`` содержит примерное количество кортежей в "
"каждом диапазоне;"

#: ../doc/book/box/box_index.rst:926
msgid ""
"``index_object:stat().disk.statement`` -- counts of inserts|updates|upserts|"
"deletes;"
msgstr ""
"``index_object:stat().disk.statement`` содержит количество вставок, "
"обновлений, обновлений и вставок, удалений (inserts|updates|upserts|deletes);"

#: ../doc/book/box/box_index.rst:927
msgid ""
"``index_object:stat().disk.compaction`` -- counts of compactions and their "
"amounts;"
msgstr ""
"``index_object:stat().disk.compaction`` содержит количество слияний и их "
"объем;"

#: ../doc/book/box/box_index.rst:928
msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr ""
"``index_object:stat().disk.dump`` содержит количество дампов и их объем;"

#: ../doc/book/box/box_index.rst:929
msgid ""
"``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter hits|"
"misses;"
msgstr ""
"``index_object:stat().disk.iterator.bloom`` содержит количество совпадений и "
"несовпадений по фильтрами Блума;"

#: ../doc/book/box/box_index.rst:930
msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr "``index_object:stat().disk.pages`` содержит размер в страницах;"

#: ../doc/book/box/box_index.rst:931
msgid ""
"``index_object:stat().disk.last_level`` -- size of data in the last LSM tree "
"level;"
msgstr ""
"``index_object:stat().disk.last_level`` содержит объем данных на последнем "
"уровне LSM-дерева;"

#: ../doc/book/box/box_index.rst:932
msgid ""
"``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr ""
"``index_object:stat().cache.evict`` содержит количество освобождений кэша;"

#: ../doc/book/box/box_index.rst:933
msgid ""
"``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""
"``index_object:stat().range_size`` содержит максимальное количество байтов в "
"диапазоне;"

#: ../doc/book/box/box_index.rst:934
msgid ""
"``index_object:stat().dumps_per_compaction`` -- average number of dumps "
"required to trigger major compaction in any range of the LSM tree."
msgstr ""
"``index_object:stat().dumps_per_compaction`` содержит среднее число дампов, "
"которое необходимо для запуска значительного слияния в любом диапазоне LSM-"
"дерева."

#: ../doc/book/box/box_index.rst:936
msgid ""
"Summary index statistics are also available via :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl_details>`."
msgstr ""
"С помощью :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl_details>` "
"можно получить сводную статистику по индексу."

#: ../doc/book/box/box_index.rst:942
msgid "statistics"
msgstr "статистические данные"

#: ../doc/book/box/box_index.rst:949
msgid ""
"Remove unused index space. For the memtx storage engine this method does "
"nothing; ``index_object:compact()`` is only for the vinyl storage engine. "
"For example, with vinyl, if a tuple is deleted, the space is not immediately "
"reclaimed. There is a scheduler for reclaiming space automatically based on "
"factors such as lsm shape and amplification as discussed in the section :ref:"
"`Storing data with vinyl <engines-vinyl>`, so calling ``index_object:"
"compact()`` manually is not always necessary."
msgstr ""
"Удаление неиспользуемого пространства индекса. Для движка базы данных memtx "
"метод бесполезен; ``index_object:compact()`` используется только для движка "
"vinyl. Например, на движке vinyl при удалении кортежа память не возвращается "
"незамедлительно. Существует планировщик автоматического восстановления "
"ресурсов на основании таких факторов, как форма LSM-дерева и усложнение, как "
"описано в разделе :ref:`Хранение данных с помощью vinyl <engines-vinyl>`, "
"поэтому выполнять ``index_object:compact()`` вручную необходимости нет."

#: ../doc/book/box/box_index.rst:958
msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""
"nil (Tarantool возвращает нулевое значение сразу же, не ожидая завершения "
"слияния)"

#: ../doc/book/box/box_index.rst:965
msgid ""
"Users can define any functions they want, and associate them with indexes: "
"in effect they can make their own index methods. They do this by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их с "
"индексами: фактически они могут создавать собственные методы для работы с "
"индексом. Это можно сделать так:"

#: ../doc/book/box/box_index.rst:969
msgid "creating a Lua function,"
msgstr "создать Lua-функцию,"

#: ../doc/book/box/box_index.rst:970
msgid ""
"adding the function name to a predefined global variable which has type = "
"table, and"
msgstr ""
"добавить имя функции в заданную глобальную переменную с типом \"таблица"
"\" (table),"

#: ../doc/book/box/box_index.rst:972
msgid ""
"invoking the function any time thereafter, as long as the server is up, by "
"saying ``index_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с помощью "
"``объект_индекса:имя-функции([параметры])``."

#: ../doc/book/box/box_index.rst:975
msgid "There are three predefined global variables:"
msgstr "Есть три заданные глобальные переменные:"

#: ../doc/book/box/box_index.rst:977
msgid ""
"Adding to ``box_schema.index_mt`` makes the method available for all indexes."
msgstr ""
"Метод, добавленный в ``box_schema.index_mt``, будет доступен для всех "
"индексов."

#: ../doc/book/box/box_index.rst:978
msgid ""
"Adding to ``box_schema.memtx_index_mt`` makes the method available for all "
"memtx indexes."
msgstr ""
"Метод, добавленный в ``box_schema.memtx_index_mt``, будет доступен для всех "
"индексов в memtx'е."

#: ../doc/book/box/box_index.rst:979
msgid ""
"Adding to ``box_schema.vinyl_index_mt`` makes the method available for all "
"vinyl indexes."
msgstr ""
"Метод, добавленный в ``box_schema.vinyl_index_mt``, будет доступен для всех "
"индексов в vinyl'е."

#: ../doc/book/box/box_index.rst:981
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"index, by calling ``getmetatable(index_object)`` and then adding the "
"function name to the meta table."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_индекса)`` и последующего "
"добавления имени функции в метатаблицу."

#: ../doc/book/box/box_index.rst:987
msgid "whatever the user defines"
msgstr "то, что определяет пользователь"

#: ../doc/book/box/box_index.rst:991
msgid ""
"-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""
"-- Доступный для любого индекса спейса memtx, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable будет "
"6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"

#: ../doc/book/box/box_index.rst:1004
msgid ""
"-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""
"-- Доступный только для индекса box.space.t.index.i, 1 параметр.\n"
"-- После таких запросов значение X будет 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"

#: ../doc/book/box/box_index.rst:1020
msgid "Example showing use of the box functions"
msgstr "Пример использования функций box"

#: ../doc/book/box/box_index.rst:1022
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary key. "
"The example function will:"
msgstr ""
"Данный пример сработает на конфигурации из песочницы, описанной в "
"предисловии, то есть создан спейс под названием tester с первичным числовым "
"ключом. Функция в примере выполнит следующие действия:"

#: ../doc/book/box/box_index.rst:1026
msgid "select a tuple whose key value is 1000;"
msgstr "выбрать кортеж, значение ключа в котором равно 1000;"

#: ../doc/book/box/box_index.rst:1027
msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""
"выдать сообщение об ошибке, если такой кортеж уже существует и содержит 3 "
"поля;"

#: ../doc/book/box/box_index.rst:1030
msgid "Insert or replace the tuple with:"
msgstr "вставить или заменить кортеж следующими данными:"

#: ../doc/book/box/box_index.rst:1029
msgid "field[1] = 1000"
msgstr "поле [1] = 1000"

#: ../doc/book/box/box_index.rst:1030
msgid "field[2] = a uuid"
msgstr "поле [2] = UUID"

#: ../doc/book/box/box_index.rst:1031
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr "поле [3] = количество секунд с 01.01.1970;"

#: ../doc/book/box/box_index.rst:1032
msgid "Get field[3] from what was replaced;"
msgstr "получить поле [3] из того, что заменили;"

#: ../doc/book/box/box_index.rst:1033
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""
"преобразовать значение из поля [3] в формат yyyy-mm-dd hh:mm:ss.ffff (год-"
"месяц-день час:минута:секунда.десятитысячные доли секунды);"

#: ../doc/book/box/box_index.rst:1034
msgid "Return the formatted value."
msgstr "вернуть преобразованное значение."

#: ../doc/book/box/box_index.rst:1036
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:"
"`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua "
"functions `os.date()`_ and `string.sub()`_."
msgstr ""
"Данная функция использует функции box в Tarantool'е: :ref:`box.space..."
"select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :"
"ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. Данная функция "
"использует Lua-функции `os.date()`_ и `string.sub()`_."

#: ../doc/book/box/box_index.rst:1045
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"

#: ../doc/book/box/box_index.rst:1070
msgid "... And here is what happens when one invokes the function:"
msgstr "... А вот что происходит, когда вызывается функция:"

#: ../doc/book/box/box_index.rst:1072
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."

#: ../doc/book/box/box_index.rst:1089
msgid "Example showing a user-defined iterator"
msgstr "Пример с заданным пользователем итератором"

#: ../doc/book/box/box_index.rst:1091
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators "
"and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named \"t"
"\", whose primary key was defined with ``create_index('primary',"
"{parts={1,'string'}})``."
msgstr ""
"Здесь приведен пример того, как создать свой собственный итератор. Функция "
"``paged_iter`` представляет собой \"функцию с итератором\", что поймут "
"только разработчики, которые ознакомились с разделом руководства по Lua "
"`Итераторы и замыкания <https://www.lua.org/pil/7.1.html>`_. Она делает "
"постраничную выборку, то есть возвращает 10 кортежей одновременно из таблицы "
"под названием \"t\", первичный ключ которой определен с помощью "
"``create_index('primary',{parts={1,'string'}})``."

#: ../doc/book/box/box_index.rst:1098
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"

#: ../doc/book/box/box_index.rst:1112
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they "
"only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples."
msgstr ""
"Разработчикам, использующим ``paged_iter``, необязательно знать, почему она "
"работает, следует лишь понимать, что вызвав функцию в цикле, можно получать "
"10 кортежей за раз до тех пор, пока кортежи не кончатся."

#: ../doc/book/box/box_index.rst:1116
msgid ""
"In this example the tuples are merely printed, a page at a time. But it "
"should be simple to change the functionality, for example by yielding after "
"each retrieval, or by breaking when the tuples fail to match some additional "
"criteria."
msgstr ""
"В данном примере кортежи лишь выводятся по странице за раз. Но легко "
"изменить функцию, например, путем передачи управления после каждой выборки "
"или с помощью прерывания, если кортежи не будут соответствовать "
"дополнительным критериям."

#: ../doc/book/box/box_index.rst:1121
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"

#: ../doc/book/box/box_index.rst:1134
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""
"Вложенный модуль `box.index` с типом индекса RTREE для поиска в "
"пространственных данных"

#: ../doc/book/box/box_index.rst:1136
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches "
"if the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric "
"objects with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles "
"will be illustrated."
msgstr ""
"Вложенный модуль :ref:`box.index <box_index>` может использоваться для "
"поиска в пространственных данных, если тип индекса -- RTREE. Существуют "
"операции для поиска *прямоугольников* (геометрические фигуры с 4 углами и 4 "
"сторонами) и *параллелепипедов* (геометрические фигуры с количеством углов "
"более 4 и количеством сторон более 4, которые иногда называются "
"гиперпрямоугольниками). В данном руководстве используется термин "
"*прямоугольник-или-параллелепипед* для всего класса объектов, который "
"включает в себя прямоугольники и параллелепипеды. Примерами иллюстрируются "
"только прямоугольники."

#: ../doc/book/box/box_index.rst:1144
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-"
"axis (vertical axis) coordinates in a grid of arbitrary size. Here is a "
"picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""
"Прямоугольники описаны в соответствии с координатами по оси X "
"(горизонтальной оси) и оси Y (вертикальной оси) на сетке произвольного "
"размера. Ниже представлен рисунок четырех прямоугольников на сетке с 11 "
"горизонтальными точками и 11 вертикальными точками:"

#: ../doc/book/box/box_index.rst:1148
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-"
"Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-"
"Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-"
"Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""
"           X AXIS\n"
"                1   2   3   4   5   6   7   8   9   10  11\n"
"             1\n"
"             2  #-------+                                           <-"
"Прямоугольник №1\n"
"     Y AXIS  3  |       |\n"
"             4  +-------#\n"
"             5          #-----------------------+                   <-"
"Прямоугольник №2\n"
"             6          |                       |\n"
"             7          |   #---+               |                   <-"
"Прямоугольник №3\n"
"             8          |   |   |               |\n"
"             9          |   +---#               |\n"
"             10         +-----------------------#\n"
"             11                                     #               <-"
"Прямоугольник №4"

#: ../doc/book/box/box_index.rst:1164
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of "
"top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, "
"Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So "
"in the picture ... Rectangle#1 starts at position 1 on the X axis and "
"position 2 on the Y axis, and ends at position 3 on the X axis and position "
"4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates "
"are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally "
"Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a "
"\"point\" since it has zero width and zero height, so it could have been "
"described with only two digits: {10,11}."
msgstr ""
"Прямоугольники определяются в соответствии со следующей схемой: {верхняя "
"левая координата по оси X, верхняя левая координата по оси Y, нижняя правая "
"координата по оси X, нижняя правая координата по оси Y} -- или коротко: {x1,"
"y1,x2,y2}. Таким образом, на рисунке ... Прямоугольник № 1 начинается в "
"точке 1 по оси X и точке 2 по оси Y, а заканчивается в точке 3 по оси X и "
"точке 4 по оси Y, поэтому его координаты будут следующие: {1,2,3,4}. "
"Координаты Прямоугольника № 2: {3,5,9,10}. Координаты Прямоугольника № 3: "
"{4,7,5,9}. И наконец, координаты Прямоугольника № 4: {10,11,10,11}. "
"Прямоугольник № 4, на самом деле, является точкой, поскольку у него нулевая "
"ширина и нулевая высота, так что его можно описать всего двумя числами: "
"{10,11}."

#: ../doc/book/box/box_index.rst:1174
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""
"Некоторые отношения между прямоугольниками могут быть описаны так: "
"\"Прямоугольник №1 является ближайшим соседом Прямоугольника №2\", а "
"\"Прямоугольник №3 полностью находится внутри Прямоугольника №2\"."

#: ../doc/book/box/box_index.rst:1177
msgid "Now let us create a space and add an RTREE index."
msgstr "Сейчас создадим спейс и добавим RTREE-индекс."

#: ../doc/book/box/box_index.rst:1179
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1192
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key "
"indexes.) The second field must be an \"array\", which means its values must "
"represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the "
"table by inserting two tuples, containing the coordinates of Rectangle#2 and "
"Rectangle#4."
msgstr ""
"Поле №1 не имеет значения, мы создаем его лишь потому, что необходим "
"первичный индекс. (RTREE-индексы не могут быть уникальными, поэтому не могут "
"быть первичными индексами.) Второе поле должно быть массивом (\"array\"), "
"что означает, что его значения должны представлять собой точки {x,y} или "
"прямоугольники {x1,y1,x2,y2}. Заполним таблицу, вставив два кортежа с "
"координатами Прямоугольника №2 и Прямоугольника №4."

#: ../doc/book/box/box_index.rst:1198
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"

#: ../doc/book/box/box_index.rst:1203
msgid ""
"And now, following the description of `RTREE iterator types`_, we can search "
"the rectangles with these requests:"
msgstr ""
"Затем, после описания типов RTREE-итераторов (`RTREE iterator types`_), "
"можно произвести поиск прямоугольников с помощью данных запросов:"

#: ../doc/book/box/box_index.rst:1208
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."

#: ../doc/book/box/box_index.rst:1224
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns "
"1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the "
"picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 "
"returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, "
"and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the "
"picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in "
"the picture)."
msgstr ""
"Запрос №1 возвращает 1 кортеж, потому что точка {10,11} представляет собой "
"то же, что и прямоугольник {10,11,10,11} (\"Прямоугольник №4\" на рисунке). "
"Запрос № 2 возвращает 1 кортеж, потому что прямоугольник {4,7,5,9}, который "
"был \"Прямоугольником №3\" на рисунке находится полностью внутри {3,5,9,10}, "
"что представляет собой Прямоугольник № 2. Запрос № 3 возвращает 2 кортежа, "
"потому что итератор NEIGHBOR (сосед) всегда возвращает все кортежи, а первым "
"найденным кортежем будет {3,5,9,10} (\"Прямоугольник №2\" на рисунке), "
"потому что он является ближайшим соседом {1,2,3,4} (\"Прямоугольник №1\" на "
"рисунке)."

#: ../doc/book/box/box_index.rst:1232
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""
"Теперь создадим спейс и индекс для кубоидов, которые представляют собой "
"прямоугольники-или-параллелепипеды, у которых 6 углов и 6 сторон."

#: ../doc/book/box/box_index.rst:1235
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1246
msgid ""
"The additional option here is ``dimension=3``. The default dimension is 2, "
"which is why it didn't need to be specified for the examples of rectangle. "
"The maximum dimension is 20. Now for insertions and selections there will "
"usually be 6 coordinates. For example:"
msgstr ""
"Здесь задается дополнительный параметр``dimension=3``. По умолчанию, "
"измерений 2, поэтому не было необходимости указывать данный параметр в "
"примерах для прямоугольника. Максимальное количество измерений -- 20. Что "
"касается вставки и выборки, здесь будет 6 координат. Например:"

#: ../doc/book/box/box_index.rst:1251
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"

#: ../doc/book/box/box_index.rst:1256
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""
"Теперь создадим спейс и индекс для пространственных объектов с метрикой "
"расстояния городских кварталов (метрика Манхэттена), которые представляют "
"собой прямоугольники-или-параллелепипеды; соседи для них рассчитываются иным "
"образом."

#: ../doc/book/box/box_index.rst:1259
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1270
msgid ""
"The additional option here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies "
"method. The optional distance calculator is 'manhattan', which can be a more "
"appropriate method if one is following the lines of a grid rather than "
"traveling in a straight line."
msgstr ""
"Здесь задается дополнительный параметр ``distance='manhattan'``. По "
"умолчанию, расстояние измеряется по Евклидовой метрике, что лучше всего "
"подходит для измерений по прямой линии. Другой способ расчета расстояния по "
"метрике Манхэттена ('manhattan'), который больше подходит, если необходимо "
"следовать линиям сетки, а не по прямой."

#: ../doc/book/box/box_index.rst:1276
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"

#: ../doc/book/box/box_index.rst:1282
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""
"Другие примеры поиска в пространственных данных см. по ссылке `R tree index "
"quick start and usage`_."
