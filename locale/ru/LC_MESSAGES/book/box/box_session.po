# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: 2019-12-20 21:24+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/book/box/box_session.rst:5
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/book/box/box_session.rst:9
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/book/box/box_session.rst:11
msgid ""
"The ``box.session`` submodule allows querying the session state, writing to "
"a session-specific temporary Lua table, or sending out-of-band messages, or "
"setting up triggers which will fire when a session starts or ends."
msgstr ""
"Вложенный модуль ``box.session`` позволяет делать запросы состояния сессии, "
"вносить записи во временную Lua-таблицу по отдельной сессии, отправлять "
"экстренные сообщения и настраивать триггеры, которые сработают в начале или "
"окончании сессии."

#: ../doc/book/box/box_session.rst:15
msgid "A *session* is an object associated with each client connection."
msgstr "*Сессия* -- это объект, связанный с каждым подключением клиента."

#: ../doc/book/box/box_session.rst:19
msgid "Index"
msgstr "Индекс"

#: ../doc/book/box/box_session.rst:21
msgid "Below is a list of all ``box.session`` functions and members."
msgstr ""
"Ниже приведен перечень всех функций и элементов модуля ``box.session``."

#: ../doc/book/box/box_session.rst:29
msgid "Name"
msgstr "Имя"

#: ../doc/book/box/box_session.rst:29
msgid "Use"
msgstr "Использование"

#: ../doc/book/box/box_session.rst:31
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ":ref:`box.session.id() <box_session-id>`"

#: ../doc/book/box/box_session.rst:31
msgid "Get the current session's ID"
msgstr "Получение идентификатора текущей сессии"

#: ../doc/book/box/box_session.rst:34
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ":ref:`box.session.exists() <box_session-exists>`"

#: ../doc/book/box/box_session.rst:34
msgid "Check if a session exists"
msgstr "Проверка наличия сессии"

#: ../doc/book/box/box_session.rst:37
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ":ref:`box.session.peer() <box_session-peer>`"

#: ../doc/book/box/box_session.rst:37
msgid "Get the session peer's host address and port"
msgstr "Получение адреса хоста и порта подключенного узла"

#: ../doc/book/box/box_session.rst:40
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ":ref:`box.session.sync() <box_session-sync>`"

#: ../doc/book/box/box_session.rst:40
msgid "Get the sync integer constant"
msgstr "Получение целочисленной константы sync"

#: ../doc/book/box/box_session.rst:43
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ":ref:`box.session.user() <box_session-user>`"

#: ../doc/book/box/box_session.rst:43
msgid "Get the current user's name"
msgstr "Получение имени текущего пользователя"

#: ../doc/book/box/box_session.rst:46
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ":ref:`box.session.type() <box_session-type>`"

#: ../doc/book/box/box_session.rst:46
msgid "Get the connection type or cause of action"
msgstr "Получение типа соединения или повода к действию"

#: ../doc/book/box/box_session.rst:49
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ":ref:`box.session.su() <box_session-su>`"

#: ../doc/book/box/box_session.rst:49
msgid "Change the current user"
msgstr "Изменение текущего пользователя"

#: ../doc/book/box/box_session.rst:52
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ":ref:`box.session.uid() <box_session-uid>`"

#: ../doc/book/box/box_session.rst:52
msgid "Get the current user's ID"
msgstr "Получение идентификатора текущего пользователя"

#: ../doc/book/box/box_session.rst:55
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ":ref:`box.session.euid() <box_session-euid>`"

#: ../doc/book/box/box_session.rst:55
msgid "Get the current effective user's ID"
msgstr "Получение идентификатора текущего действующего пользователя"

#: ../doc/book/box/box_session.rst:58
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ":ref:`box.session.storage <box_session-storage>`"

#: ../doc/book/box/box_session.rst:58
msgid "Table with session-specific names and values"
msgstr "Таблица с именами и значениями по сессии"

#: ../doc/book/box/box_session.rst:61
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`"

#: ../doc/book/box/box_session.rst:61
msgid "Define a connect trigger"
msgstr "Определение триггера для подключения"

#: ../doc/book/box/box_session.rst:64
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"

#: ../doc/book/box/box_session.rst:64
msgid "Define a disconnect trigger"
msgstr "Определение триггера для отключения"

#: ../doc/book/box/box_session.rst:67
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`"

#: ../doc/book/box/box_session.rst:67
msgid "Define an authentication trigger"
msgstr "Определение триггера для аутентификации"

#: ../doc/book/box/box_session.rst:70
msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ":ref:`box.session.push() <box_session-push>`"

#: ../doc/book/box/box_session.rst:70
msgid "Send an out-of-band message"
msgstr "Отправка внеполосного сообщения"

#: ../doc/book/box/box_session.rst:0
msgid "return"
msgstr "возвращается"

#: ../doc/book/box/box_session.rst:80
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 or "
"-1 meaning there is no session."
msgstr ""
"уникальный идентификатор (ID) для текущей сессии. Результатом может быть 0 "
"или -1, что означает, что сессии нет."

#: ../doc/book/box/box_session.rst:0
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/book/box/box_session.rst:82 ../doc/book/box/box_session.rst:89
#: ../doc/book/box/box_session.rst:118 ../doc/book/box/box_session.rst:207
#: ../doc/book/box/box_session.rst:238
msgid "number"
msgstr "число"

#: ../doc/book/box/box_session.rst:88
msgid "1 if the session exists, 0 if the session does not exist."
msgstr "1, если сессия есть; 0, если сессии нет."

#: ../doc/book/box/box_session.rst:95
msgid ""
"This function works only if there is a peer, that is, if a connection has "
"been made to a separate Tarantool instance."
msgstr ""
"Данная функция сработает только в том случае, если есть подключенная "
"программа, то есть если было выполнено подключение к отдельному экземпляру "
"Tarantool'а."

#: ../doc/book/box/box_session.rst:98
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to a "
"separate instance, the return is null. The command is executed on the server "
"instance, so the \"local name\" is the server instance's host and port, and "
"the \"peer name\" is the client's host and port."
msgstr ""
"Адрес хоста и порт подключенного узла, например \"127.0.0.1:55457\". Если "
"существует сессия, но отсутствует подключение к отдельному экземпляру, "
"вернется null. Команда выполняется на экземпляре сервера,  поэтому "
"\"локальное имя\" -- это хост и порт экземпляра сервера, а \"имя узла\" -- "
"это хост и порт клиента."

#: ../doc/book/box/box_session.rst:106 ../doc/book/box/box_session.rst:130
#: ../doc/book/box/box_session.rst:138
msgid "string"
msgstr "string (строка)"

#: ../doc/book/box/box_session.rst:108
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr "Возможные ошибки: 'session.peer(): сессия отсутствует'"

#: ../doc/book/box/box_session.rst:114
msgid ""
"the value of the :code:`sync` integer constant used in the `binary protocol "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants."
"h>`_. This value becomes invalid when the session is disconnected."
msgstr ""
"значение целочисленной константы :code:`sync`, используемой в `бинарном "
"протоколе <https://github.com/tarantool/tarantool/blob/2.1/src/box/"
"iproto_constants.h>`_. Это значение будет недействительным после отключения "
"сессии."

#: ../doc/book/box/box_session.rst:120
msgid ""
"This function is local for the request, i.e. not global for the session. If "
"the connection behind the session is multiplexed, this function can be "
"safely used inside the request processor."
msgstr ""

#: ../doc/book/box/box_session.rst:128
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr "имя :ref:`текущего пользователя <authentication-users>`"

#: ../doc/book/box/box_session.rst:136
msgid "the type of connection or cause of action."
msgstr "тип соединения или повод к действию."

#: ../doc/book/box/box_session.rst:140
msgid "Possible return values are:"
msgstr "Возможные возвращаемые значения:"

#: ../doc/book/box/box_session.rst:142
msgid ""
"'binary' if the connection was done via the binary protocol, for example to "
"a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""
"'binary' (бинарное), если подключение было выполнено по бинарному протоколу, "
"например, к объекту с помощью :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"

#: ../doc/book/box/box_session.rst:145
msgid ""
"'console' if the connection was done via the administrative console, for "
"example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""
"'console' (консоль), если подключение было выполнено по административной "
"консоли, например, к объекту с помощью :ref:`console.listen <console-"
"listen>`;"

#: ../doc/book/box/box_session.rst:148
msgid ""
"'repl' if the connection was done directly, for example when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""
"'repl' (репликация), если подключение было выполнено напрямую, например, "
"при :ref:`использовании Tarantool'а в качестве клиента <admin-"
"using_tarantool_as_a_client>`;"

#: ../doc/book/box/box_session.rst:150
msgid ""
"'applier' if the action is due to :ref:`replication <replication>`, "
"regardless of how the connection was done;"
msgstr ""
"'applier' (наложение), если действие происходит по причине :ref:`репликации "
"<replication>`, независимо от типа подключения;"

#: ../doc/book/box/box_session.rst:153
msgid ""
"'background' if the action is in a :ref:`background fiber <fiber-module>`, "
"regardless of whether the Tarantool server was :ref:`started in the "
"background <cfg_basic-background>`."
msgstr ""
"'background' (в фоне), если действие происходит в :ref:`фоновом файбере "
"<fiber-module>`, независимо от того, был ли Tarantool :ref:`запущен в "
"фоновом режиме <cfg_basic-background>`."

#: ../doc/book/box/box_session.rst:158
msgid ""
"``box.session.type()`` is useful for an :ref:`on_replace() <box_space-"
"on_replace>` trigger on a replica -- the value will be 'applier' if and only "
"if the trigger was activated because of a request that was done on the "
"master."
msgstr ""
"``box.session.type()`` используется для триггера при замене :ref:"
"`on_replace() <box_space-on_replace>` на реплике -- значение будет 'applier' "
"только в том случае, если триггер был активирован по причине запроса, "
"выполненного на мастере."

#: ../doc/book/box/box_session.rst:168
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""
"Изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а -- "
"аналогично Unix-команде ``su``."

#: ../doc/book/box/box_session.rst:171
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current "
"user <authentication-users>` temporarily while executing the function -- "
"this is analogous to the Unix command ``sudo``."
msgstr ""
"Или, если указана выполняемая функция (function-to-execute), временное "
"изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а во "
"время выполнения функции – аналогично Unix-команде ``sudo``."

#: ../doc/book/box/box_session.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../doc/book/box/box_session.rst:176
msgid "name of a target user"
msgstr "целевое имя пользователя"

#: ../doc/book/box/box_session.rst:177
msgid ""
"name of a function, or definition of a function. Additional parameters may "
"be passed to ``box.session.su``, they will be interpreted as parameters of "
"function-to-execute."
msgstr ""
"имя функции или определение функции. Дополнительные параметры могут "
"передаваться в ``box.session.su``, они будут интерпретироваться как "
"параметры выполняемой функции."

# ; ../doc/book/box/box_session.rst:313
#: ../doc/book/box/box_session.rst:182 ../doc/book/box/box_session.rst:240
#: ../doc/book/box/box_session.rst:270 ../doc/book/box/box_session.rst:316
#: ../doc/book/box/box_session.rst:557
msgid "**Example**"
msgstr "**Пример**"

#: ../doc/book/box/box_session.rst:184
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

#: ../doc/book/box/box_session.rst:205
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr "ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/book/box/box_session.rst:209
msgid ""
"Every user has a unique name (seen with :ref:`box.session.user() "
"<box_session-user>`) and a unique ID (seen with ``box.session.uid()``). The "
"values are stored together in the ``_user`` space."
msgstr ""
"У каждого пользователя есть уникальное имя (узнать с помощью :ref:`box."
"session.user() <box_session-user>`) и уникальный идентификатор (узнать с "
"помощью ``box.session.uid()``). Значения хранятся вместе в спейсе ``_user``."

#: ../doc/book/box/box_session.rst:217
msgid ""
"the effective user ID of the :ref:`current user <authentication-users>`."
msgstr "рабочий ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/book/box/box_session.rst:219
msgid ""
"This is the same as :ref:`box.session.uid() <box_session-uid>`, except in "
"two cases:"
msgstr ""
"Аналогично :ref:`box.session.uid() <box_session-uid>`, за исключением двух "
"случаев:"

#: ../doc/book/box/box_session.rst:222
msgid ""
"The first case: if the call to ``box.session.euid()`` is within a function "
"invoked by :ref:`box.session.su(user-name, function-to-execute) <box_session-"
"su>` -- in that case, ``box.session.euid()`` returns the ID of the changed "
"user (the user who is specified by the ``user-name`` parameter of the ``su`` "
"function)  but ``box.session.uid()`` returns the ID of the original user "
"(the user who is calling the ``su`` function)."
msgstr ""
"Первый случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции, вызываемой по :ref:`box.session.su(user-name, function-to-execute) "
"<box_session-su>` -- в таком случае ``box.session.euid()`` вернет измененный "
"идентификатор пользователя (пользователь, который указан в параметре ``user-"
"name`` функции ``su``), но ``box.session.uid()`` вернет идентификатор "
"оригинального пользователя (пользователя, который вызывает функцию ``su``)."

#: ../doc/book/box/box_session.rst:230
msgid ""
"The second case: if the call to ``box.session.euid()`` is within a function "
"specified with :ref:`box.schema.func.create(function-name, {setuid= true}) "
"<box_schema-func_create>` and the binary protocol is in use -- in that case, "
"``box.session.euid()`` returns the ID of the user who created \"function-name"
"\" but ``box.session.uid()`` returns the ID of the the user who is calling "
"\"function-name\"."
msgstr ""
"Второй случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции по :ref:`box.schema.func.create(function-name, {setuid= true}) "
"<box_schema-func_create>`, и используется бинарный протокол -- в таком "
"случае ``box.session.euid()`` вернет идентификатор пользователя, который "
"создал функцию \"function-name\", а ``box.session.uid()`` вернет "
"идентификатор пользователя, который вызывает эту функцию \"function-name\"."

#: ../doc/book/box/box_session.rst:242
msgid ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."

#: ../doc/book/box/box_session.rst:265
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool queue "
"manager <https://github.com/tarantool/queue>`_."
msgstr ""
"Lua-таблица с произвольными неупорядоченными именами и значениями по сессии, "
"которая хранится до конца сессии. Например, эту таблицу можно использовать "
"для хранения текущих задач при работе с `очередями сообщений в Tarantool'е "
"<https://github.com/tarantool/queue>`_."

#: ../doc/book/box/box_session.rst:272
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs"
"\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs"
"\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."

#: ../doc/book/box/box_session.rst:301
msgid ""
"Define a trigger for execution when a new session is created due to an event "
"such as :ref:`console.connect <console-connect>`. The trigger function will "
"be the first thing executed after a new session is created. If the trigger "
"execution fails and raises an error, the error is sent to the client and the "
"connection is closed."
msgstr ""
"Определение исполняемого триггера во время создания новой сессии при "
"подключению по консоли :ref:`console.connect <console-connect>`. Функция с "
"триггером будет первой исполняемой функцией после создания сессии. Если "
"триггер не выполняется и выдает ошибку, эта ошибка отправляется на клиент, и "
"подключение разрывается."

#: ../doc/book/box/box_session.rst:306 ../doc/book/box/box_session.rst:342
#: ../doc/book/box/box_session.rst:417
msgid "function which will become the trigger function"
msgstr "функция, в которой будет триггер"

#: ../doc/book/box/box_session.rst:307 ../doc/book/box/box_session.rst:343
#: ../doc/book/box/box_session.rst:418
msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

#: ../doc/book/box/box_session.rst:308 ../doc/book/box/box_session.rst:344
#: ../doc/book/box/box_session.rst:419
msgid "nil or function pointer"
msgstr "nil или указатель функции"

#: ../doc/book/box/box_session.rst:310 ../doc/book/box/box_session.rst:346
#: ../doc/book/box/box_session.rst:421
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger is "
"deleted."
msgstr ""
"Если указаны параметры (nil, old-trigger-function), старый триггер будет "
"удален."

#: ../doc/book/box/box_session.rst:312 ../doc/book/box/box_session.rst:348
#: ../doc/book/box/box_session.rst:423
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих функций с "
"триггером."

#: ../doc/book/box/box_session.rst:314 ../doc/book/box/box_session.rst:350
#: ../doc/book/box/box_session.rst:425
msgid ""
"Details about trigger characteristics are in the :ref:`triggers <triggers-"
"box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе :ref:"
"`Триггеры <triggers-box_triggers>`."

#: ../doc/book/box/box_session.rst:318
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"

#: ../doc/book/box/box_session.rst:327
msgid ""
"If a trigger always results in an error, it may become impossible to connect "
"to a server to reset it."
msgstr ""
"Если триггер всегда приводит к ошибке, подключение к серверу для его "
"переустановки может стать невозможным."

#: ../doc/book/box/box_session.rst:334
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the client "
"still exists and can access session properties, such as :ref:`box.session."
"id() <box_session-id>`."
msgstr ""
"Определение исполняемого триггера после отключения клиента. Если функция с "
"триггером вызывает ошибку, то ошибка записывается в журнал, в противном "
"случае записей не будет. Триггер вызывается во время сессии клиента и может "
"получить доступ к свойствам сессии, как :ref:`box.session.id() <box_session-"
"id>`."

#: ../doc/book/box/box_session.rst:339
msgid ""
"Since version 1.10, the trigger function is invoked immediately after the "
"disconnect, even if requests that were made during the session have not "
"finished."
msgstr ""
"Начиная с версии 1.10, функция с триггером вызывается сразу же после "
"прерывания сессии, даже если сделанные запросы не были выполнены."

#: ../doc/book/box/box_session.rst:352
msgid "**Example #1**"
msgstr "**Пример №1**"

#: ../doc/book/box/box_session.rst:354
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"

#: ../doc/book/box/box_session.rst:361
msgid "**Example #2**"
msgstr "**Пример №2**"

#: ../doc/book/box/box_session.rst:363
msgid ""
"After the following series of requests, a Tarantool instance will write a "
"message using the :ref:`log <log-module>` module whenever any user connects "
"or disconnects."
msgstr ""
"После следующей серии запросов экземпляр Tarantool'а запишет сообщение с "
"помощью модуля :ref:`log <log-module>` при подключении или отключении любого "
"пользователя."

#: ../doc/book/box/box_session.rst:366
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"

#: ../doc/book/box/box_session.rst:383
msgid "Here is what might appear in the log file in a typical installation:"
msgstr "Вот что может быть записано в файл журнала при обычной установке:"

#: ../doc/book/box/box_session.rst:385
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"

#: ../doc/book/box/box_session.rst:396
msgid ""
"Define a trigger for execution during :ref:`authentication <authentication-"
"users>`."
msgstr ""
"Определение триггера, используемого во время :ref:`аутентификации "
"<authentication-users>`."

#: ../doc/book/box/box_session.rst:398
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""
"Вызов функции ``on_auth`` с триггером происходит в следующих обстоятельствах:"

#: ../doc/book/box/box_session.rst:400
msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""
"Функция :ref:`console.connect <console-connect>` включает в себя проверку "
"аутентификации всех пользователей, кроме 'guest'. Вызов функции ``on_auth`` "
"с триггером происходит после триггера ``on_connect`` только в том случае, "
"если подключение было успешным."

#: ../doc/book/box/box_session.rst:405
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate :ref:"
"`authentication packet <box_protocol-authentication>`. For this case, "
"connection and authentication are considered to be separate steps."
msgstr ""
"В :ref:`бинарном протоколе <admin-security>` есть отдельный :ref:`пакет для "
"аутентификации <box_protocol-authentication>`. В этом случае подключение и "
"аутентификация считаются отдельными действиям."

#: ../doc/book/box/box_session.rst:409
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to \"guest"
"\", the user name before the authentication is done. To get the user name "
"**after** the authentication is done, use the special syntax: :code:"
"`function auth_function (user_name) v = user_name; end`"
msgstr ""
"В отличие от других типов триггеров, вызов функций с триггером ``on_auth`` "
"происходит **до** события. Таким образом, функция с таким триггером, как :"
"code:`function auth_function () v = box.session.user(); end`, определит :"
"code:`v` как \"guest\", то есть имя пользователя до проведения "
"аутентификации. Чтобы получить имя пользователя **после** проведения "
"аутентификации, используйте специальный синтаксис: :code:`function "
"auth_function (user_name) v = user_name; end`"

#: ../doc/book/box/box_session.rst:415
msgid ""
"If the trigger fails by raising an error, the error is sent to the client "
"and the connection is closed."
msgstr ""
"Если триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

#: ../doc/book/box/box_session.rst:427
msgid "**Example 1**"
msgstr "**Пример 1**"

#: ../doc/book/box/box_session.rst:429
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"

#: ../doc/book/box/box_session.rst:436
msgid "**Example 2**"
msgstr "**Пример 2**"

#: ../doc/book/box/box_session.rst:438
msgid "This is a more complex example, with two server instances."
msgstr "Более сложный пример с двумя экземплярами сервера."

#: ../doc/book/box/box_session.rst:440
msgid ""
"The first server instance listens on port 3301; its default user name is "
"'admin'. There are three ``on_auth`` triggers:"
msgstr ""
"Первый экземпляр сервера настроен на прослушивание по порту 3301; имя "
"пользователя по умолчанию -- 'admin'. Есть три триггера ``on_auth``:"

#: ../doc/book/box/box_session.rst:444
msgid ""
"The first trigger has a function with no arguments, it can only look at "
"``box.session.user()``."
msgstr ""
"В первом триггере есть функция без аргументов, которая только смотрит на "
"``box.session.user()``."

#: ../doc/book/box/box_session.rst:446
msgid ""
"The second trigger has a function with a ``user_name`` argument, it can look "
"at both of: ``box.session.user()`` and ``user_name``."
msgstr ""
"Во втором триггере есть функция с аргументом ``user_name``, которая может "
"смотреть на ``box.session.user()`` и ``user_name``."

#: ../doc/book/box/box_session.rst:448
msgid ""
"The third trigger has a function with a ``user_name`` argument and a "
"``status`` argument, it can look at all three of: ``box.session.user()`` and "
"``user_name`` and ``status``."
msgstr ""
"В третьем триггере есть функция с аргументом ``user_name`` и аргументом "
"``status``, которая может смотреть на ``box.session.user()`` и "
"``user_name``, и``status``."

#: ../doc/book/box/box_session.rst:453
msgid ""
"The second server instance will connect with :ref:`console.connect <console-"
"connect>`, and then will cause a display of the variables that were set by "
"the trigger functions."
msgstr ""
"Второй экземпляр сервера подключится по :ref:`console.connect <console-"
"connect>`, а затем отобразит переменные, определенные функциями с триггером."

#: ../doc/book/box/box_session.rst:458
msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""
"-- На первом экземпляре сервера, прослушивание на котором настроено на порт "
"3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"

#: ../doc/book/box/box_session.rst:481
msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""
"-- На втором экземпляре сервера, который подключается по порту 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"

#: ../doc/book/box/box_session.rst:487
msgid "The result looks like this:"
msgstr "Теперь результат выглядит следующим образом:"

#: ../doc/book/box/box_session.rst:489
msgid ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"

#: ../doc/book/box/box_session.rst:502
msgid ""
"Generate an out-of-band message. By \"out-of-band\" we mean an extra message "
"which supplements what is passed in a network via the usual channels. "
"Although ``box.session.push()`` can be called at any time, in practice it is "
"used with networks that are set up with :ref:`module net.box <net_box-"
"module>`, and it is invoked by the server (on the \"remote database system\" "
"to use our terminology for net.box), and the client has options for getting "
"such messages."
msgstr ""
"Создание внеполосного сообщения. Под внеполосным мы понимаем дополнительное "
"сообщение, которое дополняет то, что отправляется в сети по обычным каналам. "
"Хотя ``box.session. push()`` можно вызвать в любое время, на практике эта "
"функция используется в сетях, настроенных с помощью :ref:`модуля net.box "
"<net_box-module>`, и вызывается сервером (на \"удаленной системе с базой "
"данных\", если использовать нашу терминологию для net.box), а у клиента есть "
"возможность принимать такие сообщения."

#: ../doc/book/box/box_session.rst:511
msgid "This function returns an error if the session is disconnected."
msgstr "Функция возвращает ошибку, если сессия была прервана."

#: ../doc/book/box/box_session.rst:513
msgid "what to send"
msgstr "что отправляется"

#: ../doc/book/box/box_session.rst:514
msgid ""
"an optional argument to indicate what the session is, as taken from an "
"earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is "
"omitted, the default is the current ``box.session.sync()`` value."
msgstr ""
"необязательный аргумент, который показывает информацию о сессии, полученную "
"из предшествующего вызова :ref:`box_session:sync() <box_session-sync>`. Если "
"не указать, по умолчанию используется текущее значение ``box.session."
"sync()``."

#: ../doc/book/box/box_session.rst:517
msgid "{nil, error} or true:"
msgstr "{nil, ошибка} или true:"

#: ../doc/book/box/box_session.rst:519
msgid ""
"If the result is an error, then the first part of the return is ``nil`` and "
"the second part is the error object."
msgstr ""
"Если результатом будет ошибка, то вернется ``nil`` вместе с объектом ошибки."

#: ../doc/book/box/box_session.rst:521
msgid ""
"If the result is not an error, then the return is the boolean value ``true``."
msgstr ""
"Если результатом будет не ошибка, то вернется логическое значение ``true`` "
"(правда)."

#: ../doc/book/box/box_session.rst:522
msgid ""
"When the return is ``true``, the message has gone to the network buffer as "
"a :ref:`packet <box_protocol-iproto_protocol>` with the code IPROTO_CHUNK "
"(0x80)."
msgstr ""
"Если возвращается ``true``, сообщение отправлено в буфер сети в виде :ref:"
"`пакета <box_protocol-iproto_protocol>` с кодом IPROTO_CHUNK (0x80)."

#: ../doc/book/box/box_session.rst:526
msgid ""
"The server's sole job is to call ``box.session.push()``, there is no "
"automatic mechanism for showing that the message was received."
msgstr ""
"Единственная задача сервера -- вызвать ``box.session.push()``, поскольку нет "
"автоматического механизма, который показал бы, что сообщение получено."

#: ../doc/book/box/box_session.rst:529
msgid ""
"The client's job is to check for such messages after it sends something to "
"the server. The major client methods -- :ref:`conn:call <net_box-call>`, :"
"ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-select>`, :ref:`conn:"
"insert <conn-insert>`, :ref:`conn:replace <conn-replace>`, :ref:`conn:update "
"<conn-update>`, :ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-"
"delete>` -- may cause the server to send a message."
msgstr ""
"Задача клиента заключается в том, чтобы проверять наличие таких сообщений "
"после отправки чего-либо на сервер. Основные клиентские методы -- :ref:`conn:"
"call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select "
"<conn-select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-"
"replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-"
"upsert>`, :ref:`delete <conn-delete>` -- могут привести к отправке такого "
"сообщения сервером."

#: ../doc/book/box/box_session.rst:537
msgid ""
"Situation 1: when the client calls synchronously with the default "
"``{async=false}`` option. There are two optional additional options: :samp:"
"`on_push={function-name}`, and :samp:`on_push_ctx={function-argument}`. When "
"the client receives an out-of-band message for the session, it invokes "
"\"function-name(function-argument)\". For example, with options "
"``{on_push=table.insert, on_push_ctx=messages}``, the client will insert "
"whatever it receives into a table named 'messages'."
msgstr ""
"Ситуация 1: когда клиент делает синхронный вызов со значением параметра "
"``{async=false}`` по умолчанию. Есть два необязательных дополнительных "
"параметра: :samp:`on_push={function-name}` и :samp:`on_push_ctx={function-"
"argument}`. Когда клиент получает внеполосное сообщение в сессии, он "
"вызывает \"имя-функции(аргумент-функции)\". Например, с такими значениями "
"параметров: ``{on_push=table.insert, on_push_ctx=messages}`` -- клиент "
"произведет вставку полученных данных в таблицу под названием 'messages'."

#: ../doc/book/box/box_session.rst:545
msgid ""
"Situation 2: when the client calls asynchronously with the non-default "
"``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not "
"allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""
"Ситуация 2: когда клиент делает асинхронный вызов с измененным значением "
"параметра ``{async=true}``. Здесь не разрешены ``on_push`` и "
"``on_push_ctx``, но сообщения можно увидеть путем вызова ``pairs()`` в цикле."

#: ../doc/book/box/box_session.rst:549
msgid ""
"Situation 2 complication: ``pairs()`` is subject to timeout. So there is an "
"optional argument = timeout per iteration. If timeout occurs before there is "
"a new message or a final response, there is an error return. To check for an "
"error one can use the first loop parameter (if the loop starts with \"for i, "
"message in future:pairs()\" then the first loop parameter is i). If it is "
"``box.NULL`` then the second parameter (in our example, \"message\") is the "
"error object."
msgstr ""
"Осложненная ситуация 2: ``pairs()`` зависит от времени ожидания. Таким "
"образом, есть необязательный аргумент -- время ожидания для итерации. Если "
"время ожидания истечет до получения нового сообщения или окончательного "
"ответа, вернется ошибка. Чтобы проверить наличие ошибки, можно использовать "
"первый параметр в цикле (если цикл начинается с \"for i, message in future:"
"pairs()\", то первым параметром в цикле будет i). Если это будет ``box."
"NULL``, то второй параметр (в нашем примере \"message\") -- это объект "
"ошибки."

#: ../doc/book/box/box_session.rst:559
msgid ""
"-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""
"-- Создайте две оболочки. В оболочке №1 настройте сервер, а\n"
"-- в нем функцию, которая содержит box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); end\n"
"\n"
"-- В оболочке №2 подключитесь к серверу в качестве клиента, который\n"
"-- поддерживает Lua (как второй Tarantool-сервер, работающий\n"
"-- в качестве клиента), и создайте таблицу, в которую мы будем получать "
"сообщения:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- В оболочке №2 удаленно вызовите функцию и получите\n"
"-- СИНХРОННОЕ внеполосное сообщение:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- Через секунду, во время которой происходит запрос fiber.sleep()\n"
"-- в server_function, результат в таблице\n"
"--  messages_from_server будет следующим: 1. Проверим:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Хорошо. Это означает, что box.session.push(x) сработала,\n"
"-- поскольку мы знаем, что x был 1.\n"
"\n"
"-- В оболочке №2 удаленно вызовите ту же самую функцию\n"
"-- для получения АСИНХРОННОГО внеполосного сообщения. При этом мы не можем\n"
"-- использовать параметры on_push и on_push_ctx, но можем использовать "
"pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- Задержки нет, поскольку conn:call не ждет\n"
"-- окончания вызова функции server_function. После первой итерации\n"
"-- цикла pairs(), видим, что таблица пуста. Это выглядит так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- Это нормально, поскольку сервер еще не вызвал\n"
"-- box.session.push(). При второй итерации\n"
"-- цикла pairs(), видим значение x во время\n"
"-- второго вызова box.session.push(). Так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Хорошо. Это означает, что сообщение было асинхронным, и\n"
"-- box.session.push() выполнила свою задачу."
