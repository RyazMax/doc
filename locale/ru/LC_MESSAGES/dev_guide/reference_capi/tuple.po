# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: 2019-12-20 21:24+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/dev_guide/reference_capi/tuple.rst:3
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/dev_guide/reference_capi/tuple.rst:11
msgid "Tuple format."
msgstr "Формат кортежа."

#: ../doc/dev_guide/reference_capi/tuple.rst:13
msgid ""
"Each Tuple has an associated format (class). Default format is used to "
"create tuples which are not attached to any particular space."
msgstr ""
"Каждому кортежу соответствует определенный формат (класс). По умолчанию, "
"используется формат для создания кортежей, не привязанных к определенному "
"спейсу."

#: ../doc/dev_guide/reference_capi/tuple.rst:18
msgid "Tuple"
msgstr "Кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:24
msgid "Allocate and initialize a new tuple from raw MsgPack Array data."
msgstr ""
"Выделение и инициализация нового кортежа из сырых данных MsgPack-массива."

#: ../doc/dev_guide/reference_capi/tuple.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../doc/dev_guide/reference_capi/tuple.rst:26
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""
"формат кортежа. Используйте :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` для создания кортежа независимо от спейса."

#: ../doc/dev_guide/reference_capi/tuple.rst:29
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr "данные кортежа в формате MsgPack-массива ([ field1, field2, ...])"

#: ../doc/dev_guide/reference_capi/tuple.rst:30
msgid "the end of ``data``"
msgstr "конец данных ``data``"

#: ../doc/dev_guide/reference_capi/tuple.rst:0
msgid "Returns"
msgstr "Возвращает"

#: ../doc/dev_guide/reference_capi/tuple.rst:32
msgid "NULL on out of memory"
msgstr "NULL при нехватке памяти"

#: ../doc/dev_guide/reference_capi/tuple.rst:33
msgid "tuple otherwise"
msgstr "в остальных случаях кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:35
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr "См. также :ref:`box.tuple.new()<box_tuple-new>`"

#: ../doc/dev_guide/reference_capi/tuple.rst:39
msgid ""
"When working with tuples, it is the developer's responsibility to ensure "
"that enough space is allocated, taking especial caution when writing to them "
"with msgpuck functions such as ``mp_encode_array()``."
msgstr ""
"При работе с кортежами в обязанности разработчика входит выделение "
"достаточного места, уделяя особое внимание записи данных с помощью таких "
"msgpuck-функций, как ``mp_encode_array()``."

#: ../doc/dev_guide/reference_capi/tuple.rst:48
msgid "Increase the reference counter of tuple."
msgstr "Увеличение значения счетчика количества ссылок на кортеж."

#: ../doc/dev_guide/reference_capi/tuple.rst:50
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee "
"that the last returned tuple is reference counted internally until the next "
"call to API function that yields or returns another tuple."
msgstr ""
"Для кортежей подсчитываются ссылки. Все функции, которые возвращают кортежи, "
"обеспечивают внутренний подсчет ссылок для последнего возвращенного кортежа "
"до следующего вызова API-функции, которая передает управление или возвращает "
"другой кортеж."

#: ../doc/dev_guide/reference_capi/tuple.rst:54
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. The Lua garbage collector will not destroy a tuple "
"that has references, even if another fiber removes them from a space. After "
"processing, decrement the reference counter using :ref:"
"`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, otherwise the tuple will "
"leak."
msgstr ""
"Следует увеличивать значение счетчика количества ссылок перед длительной "
"обработкой кортежей в коде. Сборщик мусора в Lua не будет удалять кортежи с "
"ссылками, даже если другой файбер удалит их из спейса. После обработки "
"уменьшите значение счетчика количества ссылок с помощью :ref:"
"`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, иначе кортеж будет "
"допускать утечку."

#: ../doc/dev_guide/reference_capi/tuple.rst:62
#: ../doc/dev_guide/reference_capi/tuple.rst:75
#: ../doc/dev_guide/reference_capi/tuple.rst:88
#: ../doc/dev_guide/reference_capi/tuple.rst:94
#: ../doc/dev_guide/reference_capi/tuple.rst:113
#: ../doc/dev_guide/reference_capi/tuple.rst:128
msgid "a tuple"
msgstr "кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:64
#: ../doc/dev_guide/reference_capi/tuple.rst:77
#: ../doc/dev_guide/reference_capi/tuple.rst:106
msgid "-1 on error"
msgstr "-1 в случае ошибки"

#: ../doc/dev_guide/reference_capi/tuple.rst:65
#: ../doc/dev_guide/reference_capi/tuple.rst:78
msgid "0 otherwise"
msgstr "0 в остальных случаях"

#: ../doc/dev_guide/reference_capi/tuple.rst:67
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr "См. также :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"

#: ../doc/dev_guide/reference_capi/tuple.rst:73
msgid "Decrease the reference counter of tuple."
msgstr "Увеличение значения счетчика количества ссылок на кортеж."

#: ../doc/dev_guide/reference_capi/tuple.rst:80
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr "См. также :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"

#: ../doc/dev_guide/reference_capi/tuple.rst:86
msgid "Return the number of fields in a tuple (the size of MsgPack Array)."
msgstr "Возврат количества полей в кортеже (размер MsgPack-массива)."

#: ../doc/dev_guide/reference_capi/tuple.rst:92
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack Array)."
msgstr ""
"Возврат количества байтов, используемых для хранения внутренних данных "
"кортежа (MsgPack-массив)."

#: ../doc/dev_guide/reference_capi/tuple.rst:98
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr "Передача сырых MsgPack-данных в буфер памяти ``buf`` размера ``size``."

#: ../doc/dev_guide/reference_capi/tuple.rst:100
msgid "Store tuple fields in the memory buffer."
msgstr "Хранение полей кортежа в буфере памяти."

#: ../doc/dev_guide/reference_capi/tuple.rst:102
msgid ""
"Upon successful return, the function returns the number of bytes written. If "
"buffer size is not enough then the return value is the number of bytes which "
"would have been written if enough space had been available."
msgstr ""
"При успешном выполнении функция возвращает количество записанных байтов. "
"Если размер буфера недостаточный, возвращается количество байтов, которое "
"было бы записано, если бы было достаточно места."

#: ../doc/dev_guide/reference_capi/tuple.rst:107
msgid "number of bytes written on success."
msgstr "количество записанных байтов при успешном выполнении."

#: ../doc/dev_guide/reference_capi/tuple.rst:111
msgid "Return the associated format."
msgstr "Возврат взаимосвязанного формата."

#: ../doc/dev_guide/reference_capi/tuple.rst:115
msgid "tuple format"
msgstr "формат кортежа"

#: ../doc/dev_guide/reference_capi/tuple.rst:121
msgid ""
"Return the raw tuple field in MsgPack format. The result is a pointer to raw "
"MessagePack data which can be decoded with mp_decode functions, for an "
"example see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""
"Возврат поля кортежа в MsgPack-формате. Результатом будет указатель на сырые "
"данные в формате MessagePack, которые можно расшифровать с помощью функций "
"mp_decode. Пример можно увидеть в программе практикума :ref:`read.c "
"<f_c_tutorial-read>`."

#: ../doc/dev_guide/reference_capi/tuple.rst:126
msgid "The buffer is valid until the next call to a ``box_tuple_*`` function."
msgstr "Буфер действует до следующего вызова функции ``box_tuple_*``."

#: ../doc/dev_guide/reference_capi/tuple.rst:129
msgid "zero-based index in MsgPack array."
msgstr "индекс с основанием 0 в MsgPack-массиве."

#: ../doc/dev_guide/reference_capi/tuple.rst:131
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"
msgstr ""
"NULL, если i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"

#: ../doc/dev_guide/reference_capi/tuple.rst:132
msgid "msgpack otherwise"
msgstr "в остальных случаях msgpack"

#: ../doc/dev_guide/reference_capi/tuple.rst:147
msgid "Possible data types for tuple fields."
msgstr "Допустимые типы данных для полей кортежа."

#: ../doc/dev_guide/reference_capi/tuple.rst:149
msgid ""
"One cannot use STRS/ENUM macros for types because there is a mismatch "
"between enum name (STRING) and type name literal (\"STR\"). STR is already "
"used as a type in Objective C."
msgstr ""
"Нельзя использовать макросы STRS/ENUM для типов, поскольку есть "
"несоответствие между именем enum (STRING) и литералом имени типа (\"STR\"). "
"STR уже используется в качестве типа в Objective-C."

#: ../doc/dev_guide/reference_capi/tuple.rst:157
msgid "Key definition"
msgstr "Определение ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:161
msgid ""
"Create a key definition with the key fields with passed types on passed "
"positions."
msgstr ""
"Создание определения ключа с полям ключа с переданными типами по переданным "
"позициям."

#: ../doc/dev_guide/reference_capi/tuple.rst:163
msgid "May be used for tuple format creation and/or tuple comparison."
msgstr ""
"Можно использовать для создания формата кортежа и/или сопоставления кортежей."

#: ../doc/dev_guide/reference_capi/tuple.rst:165
msgid "array with key field identifiers"
msgstr "массив с идентификаторами поля ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:166
msgid "array with key :ref:`field types <capi-tuple_field_type>`"
msgstr "массив с :ref:`типами поля <capi-tuple_field_type>` ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:167
msgid "the number of key fields"
msgstr "количество полей ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:169
msgid "key definition on success"
msgstr "определение ключа, если выполнено"

#: ../doc/dev_guide/reference_capi/tuple.rst:170
#: ../doc/dev_guide/reference_capi/tuple.rst:188
msgid "NULL on error"
msgstr "NULL в случае ошибки"

#: ../doc/dev_guide/reference_capi/tuple.rst:174
msgid "Delete a key definition"
msgstr "Удаление определения ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:176
msgid "key definition to delete"
msgstr "удаляемое определение ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:182
msgid "Return new in-memory tuple format based on passed key definitions"
msgstr ""
"Возврат нового формата кортежа на основании переданных определений ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:184
msgid "array of keys defined for the format"
msgstr "массив ключей, определенный для формата"

#: ../doc/dev_guide/reference_capi/tuple.rst:185
msgid "count of keys"
msgstr "количество ключей"

#: ../doc/dev_guide/reference_capi/tuple.rst:187
msgid "new tuple format on success"
msgstr "новый формат кортежа, если выполнено"

#: ../doc/dev_guide/reference_capi/tuple.rst:192
msgid "Increment tuple format reference count"
msgstr "Увеличение значения подсчета ссылок на формат кортежа"

#: ../doc/dev_guide/reference_capi/tuple.rst:194
msgid "tuple format to ref"
msgstr "формат кортежа для ссылок"

#: ../doc/dev_guide/reference_capi/tuple.rst:198
msgid "Decrement tuple format reference count"
msgstr "Уменьшение значения подсчета ссылок на формат кортежа"

#: ../doc/dev_guide/reference_capi/tuple.rst:200
msgid "tuple format to unref"
msgstr "формат кортежа для уменьшения"

#: ../doc/dev_guide/reference_capi/tuple.rst:206
msgid "Compare tuples using key definition"
msgstr "Сопоставление кортежей, используя определение ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:208
msgid "the first tuple"
msgstr "первый кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:209
msgid "the second tuple"
msgstr "второй кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:210
#: ../doc/dev_guide/reference_capi/tuple.rst:224
msgid "key definition"
msgstr "определение ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:212
msgid "0  if ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"
msgstr "0, если ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:213
msgid "<0 if ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"
msgstr "<0, если ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:214
msgid ">0 if ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"
msgstr ">0, если ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:216
#: ../doc/dev_guide/reference_capi/tuple.rst:230
msgid "See also: enum :ref:`field_type <capi-tuple_field_type>`"
msgstr "См. также enum :ref:`field_type <capi-tuple_field_type>`"

#: ../doc/dev_guide/reference_capi/tuple.rst:220
msgid "Compare a tuple with a key using key definition"
msgstr "Сопоставление кортежа с ключом, используя определение ключа"

#: ../doc/dev_guide/reference_capi/tuple.rst:222
msgid "tuple"
msgstr "кортеж"

#: ../doc/dev_guide/reference_capi/tuple.rst:223
msgid "key with MessagePack array header"
msgstr "ключ с заголовком MessagePack-массива"

#: ../doc/dev_guide/reference_capi/tuple.rst:226
msgid "0  if ``key_fields(tuple)`` == ``parts(key)``"
msgstr "0, если ``key_fields(tuple)`` == ``parts(key)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:227
msgid "<0 if ``key_fields(tuple)`` < ``parts(key)``"
msgstr "<0, если ``key_fields(tuple)`` < ``parts(key)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:228
msgid ">0 if ``key_fields(tuple)`` > ``parts(key)``"
msgstr ">0, если ``key_fields(tuple)`` > ``parts(key)``"

#: ../doc/dev_guide/reference_capi/tuple.rst:234
msgid "Tuple iterator"
msgstr "Итератор кортежей"

#: ../doc/dev_guide/reference_capi/tuple.rst:238
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allows "
"iterating over fields at the root level of a MsgPack array."
msgstr ""
"Выделение и инициализация нового итератора кортежей. Итератор кортежей "
"позволяет проводить итерацию по полям на корневом уровне MsgPack-массива."

#: ../doc/dev_guide/reference_capi/tuple.rst:241
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/dev_guide/reference_capi/tuple.rst:243
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind the iterator to the first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // обработка ошибок с помощью box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // обработка сырых MsgPack-данных\n"
"}\n"
"\n"
"// перемотка итератора на начальное положение\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// перемотка на три поля\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"

#: ../doc/dev_guide/reference_capi/tuple.rst:266
msgid "Destroy and free tuple iterator"
msgstr "Удаление и освобождение итератора кортежей"

#: ../doc/dev_guide/reference_capi/tuple.rst:272
msgid ""
"Return zero-based next position in iterator. That is, this function returnы "
"the field id of the field that will be returned by the next call to :ref:"
"`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is zero after "
"initialization or rewind and :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>` after the end of iteration."
msgstr ""
"Возврат следующего положения с основанием 0 в итераторе. То есть функция "
"возвращает идентификатор поля, который вернется при следующем вызове :ref:"
"`box_tuple_next()<c_api-tuple-box_tuple_next>`. Возвращается значение 0 "
"после инициализации или перемотки и :ref:`box_tuple_field_count()<c_api-"
"tuple-box_tuple_field_count>` по окончании итерации."

#: ../doc/dev_guide/reference_capi/tuple.rst:279
#: ../doc/dev_guide/reference_capi/tuple.rst:286
#: ../doc/dev_guide/reference_capi/tuple.rst:301
#: ../doc/dev_guide/reference_capi/tuple.rst:322
msgid "a tuple iterator"
msgstr "итератор кортежей"

#: ../doc/dev_guide/reference_capi/tuple.rst:280
msgid "position"
msgstr "положение"

#: ../doc/dev_guide/reference_capi/tuple.rst:284
msgid "Rewind iterator to the initial position."
msgstr "Перемотка итератора в начальное положение."

#: ../doc/dev_guide/reference_capi/tuple.rst:288
msgid "After: ``box_tuple_position(it) == 0``"
msgstr "После: ``box_tuple_position(it) == 0``"

#: ../doc/dev_guide/reference_capi/tuple.rst:292
msgid "Seek the tuple iterator."
msgstr "Поиск итератора кортежей."

#: ../doc/dev_guide/reference_capi/tuple.rst:294
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with "
"mp_decode functions, for an example see the tutorial program :ref:`read.c "
"<f_c_tutorial-read>`. The returned buffer is valid until the next call to "
"``box_tuple_*`` API. The requested ``field_no`` is returned by the next call "
"to ``box_tuple_next(it)``."
msgstr ""
"Результатом будет указатель на сырые MessagePack-данные, которые можно "
"расшифровать с помощью функций ``mp_decode``. Пример можно увидеть в "
"программе практикума :ref:`read.c <f_c_tutorial-read>`. Возвращаемый буфер "
"действует до следующего вызова API ``box_tuple_*`` . Запрашиваемый номер "
"поля ``field_no`` возвращается при следующем вызове ``box_tuple_next(it)``."

#: ../doc/dev_guide/reference_capi/tuple.rst:302
msgid "field number - zero-based position in MsgPack array"
msgstr "номер поля -- положение с основанием 0 в MsgPack-массиве"

#: ../doc/dev_guide/reference_capi/tuple.rst:305
msgid "After:"
msgstr "После:"

#: ../doc/dev_guide/reference_capi/tuple.rst:307
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr "``box_tuple_position(it) == field_not``, если возвращается не NULL."

#: ../doc/dev_guide/reference_capi/tuple.rst:308
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value "
"is NULL."
msgstr ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)``, если "
"возвращается NULL."

#: ../doc/dev_guide/reference_capi/tuple.rst:315
msgid "Return the next tuple field from tuple iterator."
msgstr "Возврат следующего поля кортежа из итератора кортежей."

#: ../doc/dev_guide/reference_capi/tuple.rst:317
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with "
"mp_decode functions, for an example see the tutorial program :ref:`read.c "
"<f_c_tutorial-read>`. The returned buffer is valid until next call to "
"``box_tuple_*`` API."
msgstr ""
"Результатом будет указатель на сырые MessagePack-данные, которые можно "
"расшифровать с помощью функций mp_decode. Пример можно увидеть в программе "
"практикума :ref:`read.c <f_c_tutorial-read>`. Возвращаемый буфер действует "
"до следующего вызова API ``box_tuple_*``."

#: ../doc/dev_guide/reference_capi/tuple.rst:323
msgid "NULL if there are no more fields"
msgstr "NULL, если полей больше нет"

#: ../doc/dev_guide/reference_capi/tuple.rst:324
msgid "MsgPack otherwise"
msgstr "в остальных случаях MsgPack"

#: ../doc/dev_guide/reference_capi/tuple.rst:326
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is zero-"
"based ID of returned field."
msgstr ""
"Ранее: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` -- это "
"идентификатор с основанием 0 возвращаемого поля."

#: ../doc/dev_guide/reference_capi/tuple.rst:329
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if "
"returned value is NULL."
msgstr ""
"После: ``box_tuple_position(it) == box_tuple_field_count(tuple)``, если "
"возвращается NULL."
