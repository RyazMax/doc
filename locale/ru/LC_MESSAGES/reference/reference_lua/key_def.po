# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/reference/reference_lua/key_def.rst:5
#, fuzzy
msgid "Module `key_def`"
msgstr "Модуль `socket`"

#: ../doc/reference/reference_lua/key_def.rst:9
msgid ""
"The `key_def` module has a function for making a definition of the field "
"numbers and types of a tuple. The definition is usually used in conjunction "
"with an index definition to extract or compare the index key values."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:18
#, fuzzy
msgid "Create a new key_def instance."
msgstr "Создание экземпляра iconv"

#: ../doc/reference/reference_lua/key_def.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../doc/reference/reference_lua/key_def.rst:20
msgid ""
"field numbers and types. There must be at least one part and it must have at "
"least fieldno and type."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:0
msgid "returns"
msgstr "возвращает"

#: ../doc/reference/reference_lua/key_def.rst:24
msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:26
#, fuzzy
msgid ""
"The parts table has components which are the same as the ``parts`` option "
"in :ref:`Options for space_object:create_index() <box_space-create_index-"
"options>`."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

#: ../doc/reference/reference_lua/key_def.rst:30
msgid "fieldno (integer) for example fieldno=1"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:32
msgid "type (string) for example type='string'"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:34
msgid "Other components are optional."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:36
msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:42
msgid ""
"A key_def object is an object returned by :ref:`key_def.new() <key_def-"
"new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, :ref:"
"`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() <key_def-"
"totable>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:54
msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:56
#: ../doc/reference/reference_lua/key_def.rst:131
#: ../doc/reference/reference_lua/key_def.rst:132
#: ../doc/reference/reference_lua/key_def.rst:157
#: ../doc/reference/reference_lua/key_def.rst:158
msgid "tuple or Lua table with field contents"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:0
msgid "return"
msgstr "возвращает"

#: ../doc/reference/reference_lua/key_def.rst:58
msgid "the fields that were defined for the key_def object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:60
#, fuzzy
msgid "**Example #1:**"
msgstr "**Пример 1:**"

#: ../doc/reference/reference_lua/key_def.rst:62
msgid ""
"-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:85
#, fuzzy
msgid "**Example #2**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_lua/key_def.rst:87
msgid ""
"-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:101
#, fuzzy
msgid "**Example #3**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_lua/key_def.rst:103
msgid ""
"-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:125
msgid ""
"Compare the key fields of tuple_1 to the key fields of tuple_2. This is a "
"tuple-by-tuple comparison so users do not have to write code which compares "
"a field at a time. Each field's type and collation wll be taken into "
"account. In effect it is a comparison of extract_key(tuple_1) with "
"extract_key(tuple_2)."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:134
msgid ""
"> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = "
"tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:138
#: ../doc/reference/reference_lua/key_def.rst:164
#: ../doc/reference/reference_lua/key_def.rst:187
#: ../doc/reference/reference_lua/key_def.rst:212
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/reference/reference_lua/key_def.rst:140
msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:152
msgid ""
"Compare the key fields of tuple_1 to all the fields of tuple_2. This is the "
"same as :ref:`key_def_object:compare() <key_def-compare>` except that "
"tuple_2 contains only the key fields. In effect it is a comparison of "
"extract_key(tuple_1) with tuple_2."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:160
msgid ""
"> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = "
"tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:166
msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:178
msgid ""
"Combine the main key_def_object with other_key_def_object. The return value "
"is a new key_def_object containing all the fields of the main "
"key_def_object, then all the fields of other_key_def_object which are not in "
"the main key_def_object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:183
msgid "definition of fields to add"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:185
#, fuzzy
msgid "key_def_object"
msgstr "объект"

#: ../doc/reference/reference_lua/key_def.rst:189
msgid ""
"-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:202
msgid ""
"Return a table containing what is in the key_def_object. This is the reverse "
"of ``key_def.new()``:"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:205
msgid "``key_def.new()`` takes a table and returns a key_def object,"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:206
msgid ""
"``key_def_object:totable()`` takes a key_def object and returns a table."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:208
msgid "This is useful for input to ``_serialize`` methods."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:210
msgid "table"
msgstr "таблица"

#: ../doc/reference/reference_lua/key_def.rst:214
msgid ""
"-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""
