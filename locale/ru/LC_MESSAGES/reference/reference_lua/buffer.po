# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-03 19:29+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr "Модуль `buffer`"

#: ../doc/reference/reference_lua/buffer.rst:7
msgid ""
"The ``buffer`` module returns a dynamically resizable buffer which is solely "
"for use as an option for methods of the :ref:`net.box module <net_box-"
"module>`."
msgstr ""
"Модуль ``buffer`` возвращает буфер, допускающий динамическое изменение "
"размера, который используется только в качестве опции для методов :ref:"
"`модуля net.box <net_box-module>`."

#: ../doc/reference/reference_lua/buffer.rst:10
msgid ""
"Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` "
"option is used, then the ``net.box`` methods return a raw MsgPack_ string. "
"This saves time on the server, if the client application has its own routine "
"for decoding MsgPack strings."
msgstr ""
"Как правило, модуль ``net.box`` возвращает Lua-таблицу. Если используется "
"опция ``buffer``, то методы модуля ``net.box`` возвращают неформатированную "
"строку MsgPack_. Это экономит время работы на сервере, если в клиентском "
"приложении есть собственная процедура декодирования MsgPack-строк."

#: ../doc/reference/reference_lua/buffer.rst:0
msgid "return"
msgstr "возвращает"

#: ../doc/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr "дескриптор буфера."

#: ../doc/reference/reference_lua/buffer.rst:0
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/reference/reference_lua/buffer.rst:21
msgid "cdata"
msgstr "cdata."

#: ../doc/reference/reference_lua/buffer.rst:23
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/reference/reference_lua/buffer.rst:25
msgid ""
"Assume a Tarantool server is listening on farhost:3301. Assume it has a "
"space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up "
"a server on localhost:3302 and then use ``net.box`` routines to connect to "
"farhost. Then we create a buffer, and use it as an option for a ``conn."
"space...select()`` call. The result will be in MsgPack_ format. To show "
"this, we will use :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). "
"Thus we do not decode on the remote server, but we do decode on the local "
"server."
msgstr ""
"Предположим, что Tarantool-сервер настроен на прослушивание на farhost:3301. "
"Предположим, что на нем есть спейс ``T`` с одним кортежем: ``'ABCDE', "
"12345``. В данном примере запустим сервер на localhost:3302, а затем "
"используем процедуры ``net.box`` для подключения к farhost. Затем создадим "
"буфер и используем его как опцию для вызова ``conn.space...select()``. "
"Результат получим в формате MsgPack_. Чтобы показать это, используем :ref:"
"`msgpack.decode_unchecked() <msgpack-decode_unchecked>` на ``ibuf.rpos`` "
"(\"позиция для чтения\" в буфере). Таким образом, мы проведем декодирование "
"не на удаленном сервере, а на локальном."

#: ../doc/reference/reference_lua/buffer.rst:38
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#: ../doc/reference/reference_lua/buffer.rst:50
#: ../doc/reference/reference_lua/buffer.rst:110
msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

#: ../doc/reference/reference_lua/buffer.rst:52
#: ../doc/reference/reference_lua/buffer.rst:73
msgid ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

#: ../doc/reference/reference_lua/buffer.rst:62
msgid ""
"Before Tarantool version 1.7.7, the function to use for this case is "
"``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, "
"``ibuf_decode`` is deprecated."
msgstr ""
"До версии 1.7.7 Tarantool'а в данном случае следует использовать функцию "
"``msgpack.ibuf_decode(ibuf.rpos)``. Начиная с версии  1.7.7 Tarantool'а , "
"``ibuf_decode`` объявлена устаревшей."

#: ../doc/reference/reference_lua/buffer.rst:69
msgid "**Module buffer and skip-header**"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:71
msgid "The example in the previous section"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:81
msgid ""
"showed that, ordinarily, the response from net.box includes a header -- 48 "
"(hexadecimal 30) is the :ref:`key <internals-unified_packet_structure>` for "
"IPROTO_DATA. But in some situations, for example when passing the buffer to "
"a C function that expects a MsgPack byte array without a header, the header "
"can be skipped. This is done by specifying ``skip-header=true`` as an option "
"to :ref:`conn.space.space-name:select{...} <conn-select>` or :ref:`conn."
"space.space-name:insert{...} <conn-insert>` or :ref:`conn.space.space-name:"
"replace{...} <conn-replace>` or :ref:`conn.space.space-name:update{...} "
"<conn-update>` or :ref:`conn.space.space-name:upsert{...} <conn-upsert>` or :"
"ref:`conn.space.space-name:delete{...} <conn-delete>`. The default is ``skip-"
"header=false``."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:96
msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:98
#, fuzzy
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#: ../doc/reference/reference_lua/buffer.rst:112
#, fuzzy
msgid ""
"tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

#: ../doc/reference/reference_lua/buffer.rst:120
msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:122
msgid ""
"The result is still inside an array, as is clear from the fact that it is "
"shown inside square brackets. It is possible to skip the array header too, "
"with :ref:`msgpack.decode_array_header() <msgpack-decode_array_header>`."
msgstr ""
