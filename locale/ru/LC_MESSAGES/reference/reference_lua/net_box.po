# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-04 10:02+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/reference/reference_lua/net_box.rst:9
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/reference/reference_lua/net_box.rst:11
msgid ""
"The ``net.box`` module contains connectors to remote database systems. One "
"variant, to be discussed later, is for connecting to MySQL or MariaDB or "
"PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other "
"variant, which is discussed in this section, is for connecting to Tarantool "
"server instances via a network."
msgstr ""
"Модуль ``net.box`` включает в себя коннекторы для удаленных систем с базами "
"данных. Одним из вариантов, который рассматривается позднее, является "
"подключение к MySQL, MariaDB или PostgreSQL (см. справочник по :ref:"
"`Модулям  СУБД SQL <dbms_modules>`). Другим вариантом, который "
"рассматривается в данном разделе, является подключение к экземплярам "
"Tarantool-сервера по сети."

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr "Можно вызвать следующие методы:"

#: ../doc/reference/reference_lua/net_box.rst:19
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for "
"examples in this section),"
msgstr ""
"``require('net.box')`` для получения объекта ``net.box`` (который называется "
"``net_box`` для примеров в данном разделе),"

#: ../doc/reference/reference_lua/net_box.rst:21
msgid ""
"``net_box.connect()`` to connect and get a connection object (named ``conn`` "
"for examples in this section),"
msgstr ""
"``net_box.connect()`` для подключения и получения объекта подключения "
"(который называется ``conn`` для примеров в данном разделе),"

#: ../doc/reference/reference_lua/net_box.rst:23
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on the "
"remote database system,"
msgstr ""
"другие процедуры ``net.box()``, передающие ``conn:`` для выполнения запросов "
"в удаленной системе базы данных,"

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr "``conn:close`` для отключения."

#: ../doc/reference/reference_lua/net_box.rst:27
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and use "
"the same connection object across multiple concurrent fibers. In fact that "
"is perhaps the best programming practice with Tarantool. When multiple "
"fibers use the same connection, all requests are pipelined through the same "
"network socket, but each fiber gets back a correct response. Reducing the "
"number of active sockets lowers the overhead of system calls and increases "
"the overall server performance. However for some cases a single connection "
"is not enough —- for example, when it is necessary to prioritize requests or "
"to use different authentication IDs."
msgstr ""
"Все методы ``net.box`` безопасны для файберов, то есть можно безопасно "
"обмениваться и использовать один и тот же объект подключения в нескольких "
"файберах одновременно. Фактически так лучше всего работать в Tarantool'е. "
"Когда несколько файберов используют одно соединение, все запросы передаются "
"по одному сетевому сокету, но каждый файбер получает правильный ответ. "
"Уменьшение количества активных сокетов снижает затрату ресурсов на системные "
"вызовы и увеличивает общую производительность сервера. Однако, в некоторых "
"случаях отдельного соединения недостаточно -- например, когда необходимо "
"отдавать приоритет разным запросам или использовать различные идентификаторы "
"при аутентификации."

#: ../doc/reference/reference_lua/net_box.rst:36
msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""
"В большинстве методов ``net.box`` можно использовать заключительный аргумент "
"``{options}``, который может быть:"

#: ../doc/reference/reference_lua/net_box.rst:38
msgid ""
"``{timeout=...}``. For example, a method whose final argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although "
"this does not guarantee that execution will stop on the remote server node."
msgstr ""
"``{timeout=...}``. Например, метод с заключительным аргументом "
"``{timeout=1.5}`` остановится через 1,5 секунды на локальном узле, хотя это "
"не гарантирует, что выполнение остановится на удаленном сервере."

#: ../doc/reference/reference_lua/net_box.rst:41
msgid ""
"``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

#: ../doc/reference/reference_lua/net_box.rst:42
msgid ""
"``{is_async=...}``. For example, a method whose final argument is "
"``{is_async=true}`` will not wait for the result of a request. See the :ref:"
"`is_async <net_box-is_async>` description."
msgstr ""
"``{is_async=...}``. Например, метод с заключительным аргументом "
"``{is_async=true}`` не будет ждать результата выполнения запроса. См. "
"описание :ref:`is_async <net_box-is_async>`."

#: ../doc/reference/reference_lua/net_box.rst:45
msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See "
"the :ref:`box.session.push <box_session-push>` description."
msgstr ""
"``{on_push=... on_push_ctx=...}``. Для получения внеполосных сообщений. См. "
"описание :ref:`box.session.push <box_session-push>`."

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""
"На диаграмме ниже представлены возможные состояния и варианты перехода из "
"одного состояния в другое:"

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr "На этой диаграмме:"

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr "Работа начинается с начального состояния 'initial'."

#: ../doc/reference/reference_lua/net_box.rst:60
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns a "
"worker fiber."
msgstr ""
"Выполнение метода ``net_box.connect()`` переводит состояние в 'connecting', "
"создается рабочий файбер."

#: ../doc/reference/reference_lua/net_box.rst:62
msgid ""
"If authentication and schema upload are required, it's possible later on to "
"re-enter the 'fetch_schema' state from 'active' if a request fails due to a "
"schema version mismatch error, so schema reload is triggered."
msgstr ""
"Если требуются аутентификация и загрузка схемы, можно позднее повторно войти "
"в состояние загрузки схемы 'fetch_schema' из активного 'active', если запрос "
"не будет выполнен из-за ошибки несовпадения версий схемы, то есть будет "
"вызвана перезагрузка схемы."

#: ../doc/reference/reference_lua/net_box.rst:66
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. If "
"the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""
"Метод ``conn.close()`` изменяет состояние на закрытое 'closed' и отключает "
"рабочий процесс. Если транспорт уже находится в состоянии ошибки 'error', "
"``close()`` не делает ничего."

#: ../doc/reference/reference_lua/net_box.rst:71
msgid "Index"
msgstr "Указатель"

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``net.box``."

#: ../doc/reference/reference_lua/net_box.rst:81
msgid "Name"
msgstr "Имя"

#: ../doc/reference/reference_lua/net_box.rst:81
msgid "Use"
msgstr "Назначение"

#: ../doc/reference/reference_lua/net_box.rst:83
#, fuzzy
msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-"
"new>` |br| :ref:`net_box.self <net_box-self>`"
msgstr ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-"
"new>`"

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr "Создание подключения"

#: ../doc/reference/reference_lua/net_box.rst:89
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ":ref:`conn:ping() <conn-ping>`"

#: ../doc/reference/reference_lua/net_box.rst:89
msgid "Execute a PING command"
msgstr "Выполнение команды проверки состояния PING"

#: ../doc/reference/reference_lua/net_box.rst:92
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ":ref:`conn:wait_connected() <conn-wait_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:92
msgid "Wait for a connection to be active or closed"
msgstr "Ожидание активности или закрытия подключения"

#: ../doc/reference/reference_lua/net_box.rst:95
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:95
msgid "Check if a connection is active or closed"
msgstr "Проверка активности или закрытия подключения"

#: ../doc/reference/reference_lua/net_box.rst:98
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

#: ../doc/reference/reference_lua/net_box.rst:98
msgid "Wait for a target state"
msgstr "Ожидание нужного состояния"

#: ../doc/reference/reference_lua/net_box.rst:101
msgid ":ref:`conn:close() <conn-close>`"
msgstr ":ref:`conn:close() <conn-close>`"

#: ../doc/reference/reference_lua/net_box.rst:101
msgid "Close a connection"
msgstr "Закрытие подключения"

#: ../doc/reference/reference_lua/net_box.rst:104
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

#: ../doc/reference/reference_lua/net_box.rst:104
msgid "Select one or more tuples"
msgstr "Выбор одного или нескольких кортежей"

#: ../doc/reference/reference_lua/net_box.rst:107
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ":ref:`conn.space.space-name:get{field-value} <conn-get>`"

#: ../doc/reference/reference_lua/net_box.rst:107
msgid "Select a tuple"
msgstr "Выбор кортежа"

#: ../doc/reference/reference_lua/net_box.rst:110
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"

#: ../doc/reference/reference_lua/net_box.rst:110
msgid "Insert a tuple"
msgstr "Вставка кортежа"

#: ../doc/reference/reference_lua/net_box.rst:113
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"

#: ../doc/reference/reference_lua/net_box.rst:113
msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

#: ../doc/reference/reference_lua/net_box.rst:116
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ":ref:`conn.space.space-name:update{field-value} <conn-update>`"

#: ../doc/reference/reference_lua/net_box.rst:116
#: ../doc/reference/reference_lua/net_box.rst:119
msgid "Update a tuple"
msgstr "Обновление кортежа"

#: ../doc/reference/reference_lua/net_box.rst:119
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"

#: ../doc/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"

#: ../doc/reference/reference_lua/net_box.rst:122
msgid "Delete a tuple"
msgstr "Удаление кортежа"

#: ../doc/reference/reference_lua/net_box.rst:125
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

#: ../doc/reference/reference_lua/net_box.rst:125
msgid "Evaluate and execute the expression in a string"
msgstr "Оценка и выполнение выражения в строке"

#: ../doc/reference/reference_lua/net_box.rst:128
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ":ref:`conn:call() <net_box-call>`"

#: ../doc/reference/reference_lua/net_box.rst:128
msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

#: ../doc/reference/reference_lua/net_box.rst:131
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ":ref:`conn:timeout() <conn-timeout>`"

#: ../doc/reference/reference_lua/net_box.rst:131
msgid "Set a timeout"
msgstr "Установка времени ожидания"

#: ../doc/reference/reference_lua/net_box.rst:134
#, fuzzy
msgid ":ref:`conn:on_connect() <net_box-on_connect>`"
msgstr ":ref:`socket.tcp_connect() <socket-tcp_connect>`"

#: ../doc/reference/reference_lua/net_box.rst:134
#, fuzzy
msgid "Define a connect trigger"
msgstr "Создание подключения"

#: ../doc/reference/reference_lua/net_box.rst:137
#, fuzzy
msgid ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:137
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:140
#, fuzzy
msgid ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

#: ../doc/reference/reference_lua/net_box.rst:140
msgid "Define a trigger when schema is modified"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:155
msgid ""
"The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
"preferred; ``new()`` is retained for backward compatibility."
msgstr ""
"Имена ``connect()`` и ``new()`` являются синонимами: предпочтительным будет "
"``connect()``, а ``new()`` обеспечивает поддержку обратной совместимости."

#: ../doc/reference/reference_lua/net_box.rst:158
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a "
"disconnect (see ``reconnect_after`` option below). The returned ``conn`` "
"object supports methods for making remote requests, such as select, update "
"or delete."
msgstr ""
"Создание нового подключения. Подключение устанавливается по требованию во "
"время первого запроса. Можно повторно установить подключение автоматически "
"после отключения (см. ниже опцию ``reconnect_after``). Возвращается объект "
"``conn``, который поддерживает методы создание удаленных запросов, таких как "
"select, update или delete."

#: ../doc/reference/reference_lua/net_box.rst:164
msgid "Possible options:"
msgstr "Возможные опции:"

#: ../doc/reference/reference_lua/net_box.rst:166
msgid ""
"`user/password`: you have two ways to connect to a remote host: using :ref:"
"`URI <index-uri>` or using the options `user` and `password`. For example, "
"instead of ``connect('username:userpassword@localhost:33301')`` you can "
"write ``connect('localhost:33301', {user = 'username', "
"password='userpassword'})``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:171
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before returning "
"(e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""
"`wait_connected`: по умолчанию, создание подключения блокируется до тех пор, "
"пока подключение не будет установлено, но передача ``wait_connected=false`` "
"заставит метод сразу же вернуться. Передача времени ожидания заставит метод "
"ждать до возвращения (например, ``wait_connected=1.5`` заставит ожидать "
"подключения максимум 1,5 секунды)."

#: ../doc/reference/reference_lua/net_box.rst:177
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores transient "
"failures. The wait completes once the connection is established or is closed "
"explicitly."
msgstr ""
"Если присутствует ``reconnect_after``, ``wait_connected`` проигнорирует "
"неустойчивые отказы. Ожидание заканчивается, когда подключение установлено "
"или явным образом закрыто."

#: ../doc/reference/reference_lua/net_box.rst:180
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any time "
"the connection is broken or if a connection attempt fails. This makes "
"transient network failures become transparent to the application. Reconnect "
"happens automatically in the background, so queries/requests that suffered "
"due to connectivity loss are transparently retried. The number of retries is "
"unlimited, connection attempts are done over the specified timeout (e.g. "
"``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed, "
"or once the Lua garbage collector removes it, reconnects stop."
msgstr ""
"`reconnect_after`: ``net.box`` автоматически подключается повторно в случае "
"разрыва соединения или провала попытки подключения. В таком случае "
"неустойчивые сетевые отказы становятся очевидными. Повторное подключение "
"выполняется автоматически в фоновом режиме, поэтому запросы/обращения, не "
"выполненные по причине потери соединения, явным образом выполняются "
"повторно. Количество повторов не ограничено, попытки подключения выполняются "
"в течение указанного времени ожидания (например, ``reconnect_after=5`` -- 5 "
"секунд). После явного закрытия подключения или удаления сборщиком мусора в "
"Lua попытки соединения повторно не выполняются."

#: ../doc/reference/reference_lua/net_box.rst:190
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a "
"new binary protocol command for CALL, which is not backward compatible with "
"previous versions. The new CALL no longer restricts a function to returning "
"an array of tuples and allows returning an arbitrary MsgPack/JSON result, "
"including scalars, nil and void (nothing). The old CALL is left intact for "
"backward compatibility. It will be removed in the next major release. All "
"programming language drivers will be gradually changed to use the new CALL. "
"To connect to a Tarantool instance that uses the old CALL, specify "
"``call_16=true``."
msgstr ""
"`call_16`: [с 1.7.2] по умолчанию, подключения ``net.box`` соответствуют "
"команде CALL нового бинарного протокола, который не поддерживает обратную "
"совместимость с предыдущими версиями. Команда нового бинарного протокола для "
"вызова CALL больше не ограничивает функцию в возврате массива кортежей и "
"позволяет возвращать произвольный результат в формате MsgPack/JSON, включая "
"scalar (скалярные значения), nil (нулевые значения) и void (пусто). Старый "
"метод CALL оставлен нетронутым для обратной совместимости. В следующей "
"основной версии он будет удален. Все драйверы для языков программирования "
"будут постепенно переведены на использование нового метода CALL. Для "
"подключения к экземпляру Tarantool'а, в котором используется старый метод "
"CALL, укажите ``call_16=true``."

#: ../doc/reference/reference_lua/net_box.rst:199
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). With "
"``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary "
"and Lua console network protocols are supported). With ``console = false`` "
"(default), you can also use ``conn`` database methods (in this case, only "
"the binary protocol is supported). Deprecation notice: ``console = true`` is "
"deprecated, users should use :ref:`console.connect() <console-connect>` "
"instead."
msgstr ""
"`console`: в зависимости от значения параметра поддерживаются различные "
"методы (как если бы возвращались экземпляры разных классов). Если ``console "
"= true``, можно использовать методы ``conn``: ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (в этом случае "
"поддерживаются и бинарный сетевой протокол, и протокол Lua-консоли). Если "
"``console = false`` (по умолчанию), также можно использовать методы ``conn`` "
"для работы с базой данных (в этом случае поддерживается только бинарный "
"протокол). Устарел: ``console = true`` объявлен устаревшим, вместо него "
"следует использовать :ref:`console.connect() <console-connect>`."

#: ../doc/reference/reference_lua/net_box.rst:207
msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""
"`connect_timeout`: количество секунд ожидания до возврата ошибки \"error: "
"Connection timed out\"."

#: ../doc/reference/reference_lua/net_box.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../doc/reference/reference_lua/net_box.rst:209
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ":ref:`URI <index-uri>` объекта подключения"

#: ../doc/reference/reference_lua/net_box.rst:210
#, fuzzy
msgid ""
"possible options are `user`, `password`, `wait_connected`, "
"`reconnect_after`, `call_16`, `console` and `connect_timeout`"
msgstr ""
"возможные опции: `wait_connected`, `reconnect_after`, `call_16` и `console`"

#: ../doc/reference/reference_lua/net_box.rst:0
msgid "return"
msgstr "возвращает"

#: ../doc/reference/reference_lua/net_box.rst:212
msgid "conn object"
msgstr "объект подключения"

#: ../doc/reference/reference_lua/net_box.rst:0
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/reference/reference_lua/net_box.rst:213
msgid "userdata"
msgstr "пользовательские данные"

#: ../doc/reference/reference_lua/net_box.rst:215
#: ../doc/reference/reference_lua/net_box.rst:305
#: ../doc/reference/reference_lua/net_box.rst:442
#: ../doc/reference/reference_lua/net_box.rst:476
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/reference/reference_lua/net_box.rst:217
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"

#: ../doc/reference/reference_lua/net_box.rst:227
#, fuzzy
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`."
msgstr ""
"Для локального Tarantool-сервера есть заданный объект всегда установленного "
"подключения под названием :samp:`{net_box}.self`. Он создан с целью "
"облегчить полиморфное использование API модуля ``net_box``. Таким образом, :"
"samp:`conn = {net_box}.connect('localhost:3301')` можно заменить на :samp:"
"`conn = {net_box}.self`. Однако, есть важно отличие встроенного подключения "
"от удаленного. При встроенном подключении запросы без изменения данных не "
"передают управление. При использовании удаленного подключения любой запрос "
"может передавать управление исходя из :ref:`правил неявной передачи "
"управления <atomic-implicit-yields>`, и состояние базы данных может "
"измениться к тому времени, как управление вернется."

#: ../doc/reference/reference_lua/net_box.rst:233
msgid ""
"However, there is an important difference between the embedded connection "
"and a remote one:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:236
msgid ""
"With the embedded connection, requests which do not modify data do not "
"yield. When using a remote connection, due to :ref:`the implicit rules "
"<atomic-implicit-yields>` any request can yield, and the database state may "
"have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
msgid ""
"All the options passed to a request (as ``is_async``, ``on_push``, "
"``timeout``) will be ignored."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:251
msgid "Execute a PING command."
msgstr "Выполнение команды проверки состояния PING."

#: ../doc/reference/reference_lua/net_box.rst:253
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr "поддерживается опция :samp:`timeout={секунды}`"

#: ../doc/reference/reference_lua/net_box.rst:254
msgid "true on success, false on error"
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки"

#: ../doc/reference/reference_lua/net_box.rst:255
#: ../doc/reference/reference_lua/net_box.rst:271
#: ../doc/reference/reference_lua/net_box.rst:286
#: ../doc/reference/reference_lua/net_box.rst:303
msgid "boolean"
msgstr "boolean (логический)"

#: ../doc/reference/reference_lua/net_box.rst:257
#: ../doc/reference/reference_lua/net_box.rst:273
#: ../doc/reference/reference_lua/net_box.rst:288
#: ../doc/reference/reference_lua/net_box.rst:329
#: ../doc/reference/reference_lua/net_box.rst:343
#: ../doc/reference/reference_lua/net_box.rst:365
#: ../doc/reference/reference_lua/net_box.rst:379
#: ../doc/reference/reference_lua/net_box.rst:393
#: ../doc/reference/reference_lua/net_box.rst:407
#: ../doc/reference/reference_lua/net_box.rst:505
#: ../doc/reference/reference_lua/net_box.rst:557
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/reference/reference_lua/net_box.rst:259
msgid "net_box.self:ping({timeout = 0.5})"
msgstr "net_box.self:ping({timeout = 0.5})"

#: ../doc/reference/reference_lua/net_box.rst:267
msgid "Wait for connection to be active or closed."
msgstr "Ожидание активности или закрытия подключения."

#: ../doc/reference/reference_lua/net_box.rst:269
#: ../doc/reference/reference_lua/net_box.rst:301
msgid "in seconds"
msgstr "в секундах"

#: ../doc/reference/reference_lua/net_box.rst:270
msgid "true when connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/reference/reference_lua/net_box.rst:275
msgid "net_box.self:wait_connected()"
msgstr "net_box.self:wait_connected()"

#: ../doc/reference/reference_lua/net_box.rst:283
msgid "Show whether connection is active or closed."
msgstr "Проверка активности или закрытия подключения."

#: ../doc/reference/reference_lua/net_box.rst:285
msgid "true if connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/reference/reference_lua/net_box.rst:290
msgid "net_box.self:is_connected()"
msgstr "net_box.self:is_connected()"

#: ../doc/reference/reference_lua/net_box.rst:298
msgid "[since 1.7.2] Wait for a target state."
msgstr "[с 1.7.2] Ожидание нужного состояния."

#: ../doc/reference/reference_lua/net_box.rst:300
msgid "target states"
msgstr "необходимое состояние"

#: ../doc/reference/reference_lua/net_box.rst:302
msgid ""
"true when a target state is reached, false on timeout or connection closure"
msgstr ""
"true (правда) при подключении, false (ложь) при окончании времени ожидания "
"или закрытии подключения"

#: ../doc/reference/reference_lua/net_box.rst:307
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""
"-- бесконечное ожидание состояния 'active':\n"
"conn:wait_state('active')\n"
"\n"
"-- ожидание в течение максимум 1,5 секунд:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- бесконечное ожидание состояния `active` или `fetch_schema`:\n"
"conn:wait_state({active=true, fetch_schema=true})"

#: ../doc/reference/reference_lua/net_box.rst:322
msgid "Close a connection."
msgstr "Закрытие подключения."

#: ../doc/reference/reference_lua/net_box.rst:324
msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like any "
"other objects in Lua, so an explicit destruction is not mandatory. However, "
"since close() is a system call, it is good programming practice to close a "
"connection explicitly when it is no longer needed, to avoid lengthy stalls "
"of the garbage collector."
msgstr ""
"Объекты подключения удаляются сборщиком мусора в Lua, как и любой другой Lua-"
"объект, поэтому удалять их явным образом необязательно. Однако, поскольку "
"close() представляет собой системный вызов, лучше всего закрыть соединение "
"явным образом, когда оно больше не используется, с целью ускорения работы "
"сборщика мусора."

#: ../doc/reference/reference_lua/net_box.rst:331
msgid "conn:close()"
msgstr "conn:close()"

#: ../doc/reference/reference_lua/net_box.rst:339
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:select`:code:"
"`{...}`. For an additional option see :ref:`Module buffer and skip-header "
"<buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:select`:code:`({...})` -- это удаленный "
"вызов, аналогичный локальному вызову :samp:`box.space.{имя-спейса}:select`:"
"code:`{...}`."

#: ../doc/reference/reference_lua/net_box.rst:345
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr "conn.space.testspace:select({1,'B'}, {timeout=1})"

#: ../doc/reference/reference_lua/net_box.rst:351
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :"
"samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, "
"so global variables or database tuples data may change when a remote :samp:"
"`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""
"Исходя из :ref:`правил неявной передачи управления <atomic-implicit-"
"yields>`, локальный запрос :samp:`box.space.{имя-спейса}:select`:code:`{...}"
"` не передает управление, а удаленный :samp:`conn.space.{имя-спейса}:select`:"
"code:`{...}` передаст, поэтому глобальные переменные или кортежи в базе "
"данных могут измениться во время удаленного :samp:`conn.space.{имя-спейса}:"
"select`:code:`{...}`."

#: ../doc/reference/reference_lua/net_box.rst:362
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:get(...)` -- это удаленный вызов, аналогичный "
"локальному вызову :samp:`box.space.{имя-спейса}:get(...)`."

#: ../doc/reference/reference_lua/net_box.rst:367
msgid "conn.space.testspace:get({1})"
msgstr "conn.space.testspace:get({1})"

#: ../doc/reference/reference_lua/net_box.rst:375
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:insert(...)`. For an additional "
"option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:insert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:insert(...)`."

#: ../doc/reference/reference_lua/net_box.rst:381
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"

#: ../doc/reference/reference_lua/net_box.rst:389
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent "
"of the local call :samp:`box.space.{space-name}:replace(...)`. For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:replace(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:replace(...)`."

#: ../doc/reference/reference_lua/net_box.rst:395
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr "conn.space.testspace:replace({5,6,7,8})"

#: ../doc/reference/reference_lua/net_box.rst:403
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:update(...)`. For an additional "
"option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:update(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:update(...)`."

#: ../doc/reference/reference_lua/net_box.rst:409
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"

#: ../doc/reference/reference_lua/net_box.rst:417
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:upsert(...)`. For an additional "
"option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:upsert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:upsert(...)`."

#: ../doc/reference/reference_lua/net_box.rst:425
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:delete(...)`. For an additional "
"option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:delete(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:delete(...)`."

#: ../doc/reference/reference_lua/net_box.rst:433
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-"
"string, which may be any statement or series of statements. An :ref:`execute "
"privilege <authentication-owners_privileges>` is required; if the user does "
"not have it, an administrator may grant it with :samp:`box.schema.user."
"grant({username}, 'execute', 'universe')`."
msgstr ""
":samp:`conn:eval({Lua-строка})` оценивает и выполняет выражение в Lua-"
"строке, которое может представлять собой любое выражение или несколько "
"выражений. Требуются :ref:`права на выполнение <authentication-"
"owners_privileges>`; если у пользователя таких прав нет, администратор может "
"их выдать с помощью :samp:`box.schema.user.grant({имя-пользователя}, "
"'execute', 'universe')`."

#: ../doc/reference/reference_lua/net_box.rst:439
msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua expression "
"returns, begin the Lua-string with the word \"return\"."
msgstr ""
"Чтобы гарантировать, что ``conn:eval`` вернет то, что возвращает выражение "
"на Lua, начните Lua-строку со слова \"return\" (вернуть)."

#: ../doc/reference/reference_lua/net_box.rst:444
msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""
"tarantool> --Lua-строка\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}, {парметры}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:468
msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure "
"call. The return from ``conn:call`` is whatever the function returns."
msgstr ""
"``conn:call('func', {'1', '2', '3'})`` -- это удаленный вызов, аналогичный "
"``func('1', '2', '3')``. Таким образом, ``conn:call`` представляет собой "
"удаленный вызов хранимой процедуры. ``conn:call`` возвращает то, что "
"возвращает функция."

#: ../doc/reference/reference_lua/net_box.rst:472
msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then ``conn:"
"call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""
"Ограничение: вызванная функция не может вернуть функцию, например, если "
"``func2`` определяется как ``function func2 () return func end``, то ``conn:"
"call(func2)`` вернет ошибку \"error: unsupported Lua type 'function'\"."

#: ../doc/reference/reference_lua/net_box.rst:478
msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""
"tarantool> -- создание 2 функций с conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- вызов первой функции без параметров и опций\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- вызов второй функции с двумя параметрами и одной опцией\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:501
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it. Since version 1.7.4 this method is deprecated -- it is better to "
"pass a timeout value for a method's ``{options}`` parameter."
msgstr ""
"``timeout(...)`` -- это надстройка, которая определяет время ожидания для "
"запроса. С версии 1.7.4 этот метод объявлен устаревшим -- лучше передать "
"значение времени ожидания с помощью параметра ``{options}``."

#: ../doc/reference/reference_lua/net_box.rst:507
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"

#: ../doc/reference/reference_lua/net_box.rst:511
msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its use. "
"Using a wrapper object makes the remote connection API compatible with the "
"local one, removing the need for a separate ``timeout`` argument, which the "
"local version would ignore. Once a request is sent, it cannot be revoked "
"from the remote server even if a timeout expires: the timeout expiration "
"only aborts the wait for the remote server response, not the request itself."
msgstr ""
"Хотя ``timeout(...)`` объявлен устаревшим, все удаленные вызовы поддерживают "
"его. Использование надстройки обеспечивает совместимость API удаленного "
"соединения с локальным, поэтому отпадает необходимость в отдельном аргументе "
"``timeout``, который проигнорирует локальная версия. После отправки запроса "
"его нельзя отменить с удаленного сервера даже по истечении времени задержки: "
"окончание времени задержки прерывает только ожидание ответа от удаленного "
"сервера, а не сам запрос."

#: ../doc/reference/reference_lua/net_box.rst:523
msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn."
"space.space-name`` requests."
msgstr ""
"``{is_async=true|false}`` -- это опция, которую можно применить во всех "
"запросах ``net_box``, включая ``conn:call``, ``conn:eval`` и запросы ``conn."
"space.space-name``."

#: ../doc/reference/reference_lua/net_box.rst:527
msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for the "
"fiber. The fiber is blocked, waiting until there is a reply to the request "
"or until timeout expires. Before Tarantool version 1.10, the only way to "
"make asynchronous requests was to put them in separate fibers."
msgstr ""
"По умолчанию, ``is_async=false``, что означает, что запросы будут "
"синхронными для файбера. Файбер блокируется в ожидании ответа на запрос или "
"до истечения времени ожидания. До версии Tarantool'а 1.10 единственным "
"способом выполнения асинхронных запросов было использование отдельных "
"файберов."

#: ../doc/reference/reference_lua/net_box.rst:533
msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous for "
"the fiber. The request causes a yield but there is no waiting. The immediate "
"return is not the result of the request, instead it is an object that the "
"calling program can use later to get the result of the request."
msgstr ""
"``is_async=true`` означает, что запросы будут асинхронными для файбера. "
"Запрос вызывает передачу управления, но файбер не входит в режим ожидания. "
"Сразу же возвращается результат, но это будет не результат запроса, а "
"объект, который может использовать вызывающая программа для получения "
"результат запроса."

#: ../doc/reference/reference_lua/net_box.rst:539
msgid ""
"This immediately-returned object, which we'll call \"future\", has its own "
"methods:"
msgstr ""
"У такого сразу же возвращаемого объекта, который мы называем \"future"
"\" (будущий), есть собственные методы:"

#: ../doc/reference/reference_lua/net_box.rst:542
msgid ""
"``future:is_ready()`` which will return true when the result of the request "
"is available,"
msgstr ""
"``future:is_ready()`` вернет true (правда), если доступен результат запроса,"

#: ../doc/reference/reference_lua/net_box.rst:544
msgid ""
"``future:result()`` to get the result of the request (returns the response "
"or **nil** in case it's not ready yet or there has been an error),"
msgstr ""
"``future:result()`` используется для получения результата запроса "
"(возвращает ответ на запрос или **nil** в случае, если ответ еще не готов "
"или произошла какая-либо ошибка),"

#: ../doc/reference/reference_lua/net_box.rst:546
msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request is "
"available and then get it,"
msgstr ""
"``future:wait_result(timeout)`` будет ждать, когда результат запроса будет "
"доступен, а затем получит его."

#: ../doc/reference/reference_lua/net_box.rst:548
msgid "``future:discard()`` to abandon the object."
msgstr "``future:discard()`` откажется от объекта."

#: ../doc/reference/reference_lua/net_box.rst:550
msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, then "
"either loop checking ``future:is_ready()`` until it is true and then say "
"``request_result=future:result()``, or say ``request_result=future:"
"wait_result(...)``. Alternatively the client could check for \"out-of-band\" "
"messages from the server by calling ``pairs()`` in a loop -- see :ref:`box."
"session.push() <box_session-push>`."
msgstr ""
"В обычной ситуации пользователь введет команду ``future=имя-запроса(..."
"{is_async=true})``, а затем либо цикл с проверкой ``future:is_ready()`` до "
"тех пор, пока он не вернет true, и получением результата с помощью  "
"``request_result=future:result()``, либо же команду ``request_result=future:"
"wait_result(...)``. Возможен вариант, когда клиент проверяет наличие "
"внеполосных сообщений от сервера, вызывая в цикле ``pairs()`` -- см. :ref:"
"`box.session.push() <box_session-push>`."

#: ../doc/reference/reference_lua/net_box.rst:559
msgid ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:581
msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more than "
"100,000 requests per second) and latency is large (more than 1 second), or "
"when it is necessary to send multiple requests in parallel then collect "
"responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""
"Как правило, ``{is_async=true}`` используется только при большой загрузке "
"(более 100 000 запросов в секунду) и большой задержке чтения (более 1 "
"секунды), или же при необходимости отправки нескольких одновременных "
"запросов, которые собирают ответы (что иногда называется \"отображение-"
"свертка\")."

#: ../doc/reference/reference_lua/net_box.rst:589
msgid ""
"Although the final result of an async request is the same as the result of a "
"sync request, it is structured differently: as a table, instead of as the "
"unpacked values."
msgstr ""
"Хотя окончательный результат асинхронного запроса не отличается от "
"результата синхронного запроса, у него другая структура: таблица, а не "
"неупакованные значения."

#: ../doc/reference/reference_lua/net_box.rst:597
msgid "Triggers"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:599
msgid ""
"With the ``net.box`` module, you can use the following :ref:`triggers "
"<triggers-box_triggers>`:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:606
msgid ""
"Define a trigger for execution when a new connection is created due to an "
"event such as ``net_box.connect``. The trigger function will be the first "
"thing executed after a new connection is created. If the trigger execution "
"fails and raises an error, the error is sent to the client and the "
"connection is closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:611
#: ../doc/reference/reference_lua/net_box.rst:625
#: ../doc/reference/reference_lua/net_box.rst:638
msgid ""
"function which will become the trigger function. Takes the ``conn`` object "
"as the first argument"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:613
#: ../doc/reference/reference_lua/net_box.rst:627
#: ../doc/reference/reference_lua/net_box.rst:640
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:614
#: ../doc/reference/reference_lua/net_box.rst:628
#: ../doc/reference/reference_lua/net_box.rst:641
#, fuzzy
msgid "nil or function pointer"
msgstr "функция или ссылка на функцию"

#: ../doc/reference/reference_lua/net_box.rst:620
msgid ""
"Define a trigger for execution after a connection is closed. If the trigger "
"function causes an error, the error is logged but otherwise is ignored. "
"Execution stops after a connection is explicitly closed, or once the Lua "
"garbage collector removes it."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:634
msgid ""
"Define a trigger executed when some operation has been performed on the "
"remote server after schema has been updated. So, if a server request fails "
"due to a schema version mismatch error, schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:645
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old trigger "
"is deleted."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:648
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:651
msgid ""
"Details about trigger characteristics are in the :ref:`triggers <triggers-"
"box_triggers>` section."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:656
msgid "Example"
msgstr "Пример"

#: ../doc/reference/reference_lua/net_box.rst:658
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr "Ниже приводится пример использования большинства методов ``net.box``."

#: ../doc/reference/reference_lua/net_box.rst:660
msgid "The sandbox configuration for this example assumes that:"
msgstr ""
"Данный пример сработает на конфигурации из песочницы, предполагается, что:"

#: ../doc/reference/reference_lua/net_box.rst:662
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr "экземпляр Tarantool'а запущен на ``localhost 127.0.0.1:3301``,"

#: ../doc/reference/reference_lua/net_box.rst:663
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""
"создан спейс под названием ``tester`` с первичным числовым ключом и "
"кортежем, в котором есть ключ со значением= 800,"

#: ../doc/reference/reference_lua/net_box.rst:665
msgid "the current user has read, write and execute privileges."
msgstr "у текущего пользователя есть права на чтение, запись и выполнение."

#: ../doc/reference/reference_lua/net_box.rst:667
msgid "Here are commands for a quick sandbox setup:"
msgstr "Ниже приведены команды для быстрой настройки песочницы:"

#: ../doc/reference/reference_lua/net_box.rst:669
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/reference/reference_lua/net_box.rst:677
msgid "And here starts the example:"
msgstr "А здесь приведен пример:"

#: ../doc/reference/reference_lua/net_box.rst:679
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-"
"established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} "
"was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-"
"established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} "
"was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
